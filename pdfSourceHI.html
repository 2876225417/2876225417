<html><head><meta charset="UTF-8"><script src="https://cdn.jsdelivr.net/npm/prismjs/prism.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-cpp.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs/prism.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-none.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs/prism.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-python.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs/prism.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-sql.min.js"></script><style>
        .article {
            position: relative;
            padding-bottom: 24px;
        }
        

        .bordered-element-rounded {
            border: 1px solid #c4c4c4;
            border-radius: 7px;
            overflow: hidden;
        }
        

        .center {
            display: block;
            margin-left: auto;
            margin-right: auto;
        }
        

        .center-text {
            text-align: center;
        }
        

        .code-block {
            overflow: hidden;
            position: relative;
            padding: 0;
            border-radius: 8px;
            font-variant-ligatures: none;
            background-color: rgba(25, 25, 28, .05);
            word-break: break-all;
        }
        

        .container {
            max-width: 100%;
            overflow: hidden;
            page-break-inside: avoid;
            display: block;
        }
        

        .control {
            color: #19191c;
            font-size: 16px;
            font-weight: 670;
        }
        

        .detached {
            margin-block-start: 0;
            margin-block-end: 0;
            margin-bottom: 8px;
        }
        

        .emphasis {
            color: inherit;
            font-weight: inherit;
            font-style: italic;
        }
        

        .flex {
            display: flex;
        }
        

        .header-row {
            background: #e6e6e6;
        }
        

        .image {
            max-width: 100%;
            max-height: 90vh;
            width: auto;
        }
        

        .image-container {
            max-width: 100vw;
        }
        

        .image-size {
            height: auto;
        }
        

        .inline-code {
            border-radius: 4px;
            display: inline;
            padding: 2px 1px;
            font-family: JetBrains Sans,monospace;
            background: #e6e6e6;
        }
        

        .list {
            list-style-type: disc;
            padding-left: 0;
            margin-left: 15px;
        }
        

        .list-decimal {
            list-style-type: decimal;
        }
        

        .list-item {
            margin-top: 6px;
            margin-bottom: 6px;
            margin-left: 4px;
        }
        

        .main-title {
            padding-bottom: 24px;
            margin-top: 0;
            font-size: 40px;
            margin-block-start: 0;
            margin-block-end: 0;
        }
        

        .prism {
            page-break-inside: avoid;
        }
        
        /* PrismJS 1.29.0
https://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript+abap+abnf+actionscript+ada+agda+al+antlr4+apacheconf+apex+apl+applescript+aql+arduino+arff+armasm+arturo+asciidoc+aspnet+asm6502+asmatmel+autohotkey+autoit+avisynth+avro-idl+awk+bash+basic+batch+bbcode+bbj+bicep+birb+bison+bnf+bqn+brainfuck+brightscript+bro+bsl+c+csharp+cpp+cfscript+chaiscript+cil+cilkc+cilkcpp+clojure+cmake+cobol+coffeescript+concurnas+csp+cooklang+coq+crystal+css-extras+csv+cue+cypher+d+dart+dataweave+dax+dhall+diff+django+dns-zone-file+docker+dot+ebnf+editorconfig+eiffel+ejs+elixir+elm+etlua+erb+erlang+excel-formula+fsharp+factor+false+firestore-security-rules+flow+fortran+ftl+gml+gap+gcode+gdscript+gedcom+gettext+gherkin+git+glsl+gn+linker-script+go+go-module+gradle+graphql+groovy+haml+handlebars+haskell+haxe+hcl+hlsl+hoon+http+hpkp+hsts+ichigojam+icon+icu-message-format+idris+ignore+inform7+ini+io+j+java+javadoc+javadoclike+javastacktrace+jexl+jolie+jq+jsdoc+js-extras+json+json5+jsonp+jsstacktrace+js-templates+julia+keepalived+keyman+kotlin+kumir+kusto+latex+latte+less+lilypond+liquid+lisp+livescript+llvm+log+lolcode+lua+magma+makefile+markdown+markup-templating+mata+matlab+maxscript+mel+mermaid+metafont+mizar+mongodb+monkey+moonscript+n1ql+n4js+nand2tetris-hdl+naniscript+nasm+neon+nevod+nginx+nim+nix+nsis+objectivec+ocaml+odin+opencl+openqasm+oz+parigp+parser+pascal+pascaligo+psl+pcaxis+peoplecode+perl+php+phpdoc+php-extras+plant-uml+plsql+powerquery+powershell+processing+prolog+promql+properties+protobuf+pug+puppet+pure+purebasic+purescript+python+qsharp+q+qml+qore+r+racket+cshtml+jsx+tsx+reason+regex+rego+renpy+rescript+rest+rip+roboconf+robotframework+ruby+rust+sas+sass+scss+scala+scheme+shell-session+smali+smalltalk+smarty+sml+solidity+solution-file+soy+sparql+splunk-spl+sqf+sql+squirrel+stan+stata+iecst+stylus+supercollider+swift+systemd+t4-templating+t4-cs+t4-vb+tap+tcl+tt2+textile+toml+tremor+turtle+twig+typescript+typoscript+unrealscript+uorazor+uri+v+vala+vbnet+velocity+verilog+vhdl+vim+visual-basic+warpscript+wasm+web-idl+wgsl+wiki+wolfram+wren+xeora+xml-doc+xojo+xquery+yaml+yang+zig&plugins=highlight-keywords */
code[class*=language-],pre[class*=language-]{color:#000;background:0 0;text-shadow:0 1px #fff;font-family:Consolas,Monaco,'Andale Mono','Ubuntu Mono',monospace;font-size:1em;text-align:left;white-space:pre-wrap;word-spacing:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}code[class*=language-] ::-moz-selection,code[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection{text-shadow:none;background:#b3d4fc}code[class*=language-] ::selection,code[class*=language-]::selection,pre[class*=language-] ::selection,pre[class*=language-]::selection{text-shadow:none;background:#b3d4fc}@media print{code[class*=language-],pre[class*=language-]{text-shadow:none}}pre[class*=language-]{padding:16px;margin:0;overflow:auto}:not(pre)>code[class*=language-],pre[class*=language-]{background:#f5f2f0}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#708090}.token.punctuation{color:#999}.token.namespace{opacity:.7}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol,.token.tag{color:#905}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string{color:#690}.language-css .token.string,.style .token.string,.token.entity,.token.operator,.token.url{color:#9a6e3a;background:hsla(0,0%,100%,.5)}.token.atrule,.token.attr-value,.token.keyword{color:#07a}.token.class-name,.token.function{color:#dd4a68}.token.important,.token.regex,.token.variable{color:#e90}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}

        

        .prompt {
            flex-direction: row;
            letter-spacing: .0015em;
            font-size: 16px;
            font-weight: 400;
            line-height: 24px;
            margin-left: 0;
            margin-right: 0;
        }
        

        .prompt-content {
            padding: 15px;
            overflow: hidden;
            flex: 1 1 auto;
        }
        

        .prompt-content-p p {
            margin-block-start: 0;
            margin-block-end: 0;
        }
        

        .prompt-icon {
            flex: 0 0 auto;
            margin-left: 15px;
            margin-top: 15px;
            fill: currentcolor;
            width: 24px;
            height: 24px;
        }
        

        :root {
            width: 95%;
            max-width: 95vw;
            padding: 0 0 0 30px;
        }
        
        body {
            font-family: JetBrains Sans,serif;
        }
        
        a {
            overflow-wrap: anywhere;
            width: 100vw;
        }
        
        
        @font-face {
            font-family: JetBrains Sans;
            src: url(https://resources.jetbrains.com/storage/jetbrains-sans/JetBrainsSans-Light.woff2) format("woff2"), url(https://resources.jetbrains.com/storage/jetbrains-sans/JetBrainsSans-Light.woff) format("woff");
            font-weight: 300;
            font-style: normal;
        }

        @font-face {
            font-family: JetBrains Sans;
            src: url(https://resources.jetbrains.com/storage/jetbrains-sans/JetBrainsSans-Regular.woff2) format("woff2"), url(https://resources.jetbrains.com/storage/jetbrains-sans/JetBrainsSans-Regular.woff) format("woff");
            font-weight: 400;
            font-style: normal;
        }

        @font-face {
            font-family: JetBrains Sans;
            src: url(https://resources.jetbrains.com/storage/jetbrains-sans/JetBrainsSans-SemiBold.woff2) format("woff2"), url(https://resources.jetbrains.com/storage/jetbrains-sans/JetBrainsSans-SemiBold.woff) format("woff");
            font-weight: 600;
            font-style: normal;
        }
        
        
        code {
            display: inline;
            word-break: break-word;
            font-size: 15px;
            line-height: inherit;
            font-variant-ligatures: none;
            font-family: JetBrains Sans,monospace;
            white-space: pre-line;
            overflow-wrap: break-word;
        }
        
        figcaption {
            margin-top: 5px;
        }
        
        h2 {
            padding-top: 16px;
            padding-bottom: 8px;
            margin-block-start: 0;
            margin-block-end: 0;
        }
        
        h3 {
            padding-top: 8px;
            padding-bottom: 8px;
            margin-block-start: 0;
            margin-block-end: 0;
        }
        
        h4 {
            padding-top: 4px;
            padding-bottom: 8px;
            margin-block-start: 0;
            margin-block-end: 0;
        }
        
        p {
            padding: 0;
            border: 0;
            line-height: 25px;
            margin-block-start: 0;
            margin-block-end: 0;
            padding-bottom: 8px;
        }
        
        div {
            display: block;
        }
        
        table {
            border-collapse: collapse;
            width: 100%;
            page-break-inside: avoid;
        }
        
        th, td {
            border: 1px solid #c4c4c4;
            padding: 10px;
            text-align: left;
            word-break: break-all;
        }
        
        .entry {
            display: grid;
            grid-template-columns: auto max-content;
            grid-template-areas: "chapter page";
            align-items: end;
            gap: 0 .25rem;
            line-height: 25px;
        }
        
        .toc-link-container{
            grid-area: chapter;
            position: relative;
            overflow: hidden;
        }
        
        .toc-link{
            text-decoration: none;
            color: black;
        }
        
        .toc-link-container::after {
            position: absolute;
            padding-left: .25ch;
            content: " . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . "
            ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . "
            ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
            text-align: right;
        }
        
        .page {
            grid-area: page;
            width: 30px;
            text-align: right;
        }
        

        .table-wrapper {
            overflow: hidden;
            box-sizing: border-box;
            font: inherit;
        }
        

        .tip {
            background-color: rgba(25, 25, 28, .05);
        }
        

        .topic {
            page-break-before: always;
        }
        </style></head><body><div><section class="topic"><div><article class="article"><h1 class="main-title">Table of contents</h1><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#1762734136">Flask_Tutorial</a></div><div class="page">3</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#-1881649746">Topic title</a></div><div class="page">4</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#-699101681">C++ Templates</a></div><div class="page">5</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#2085723537">1. 关于本书</a></div><div class="page">8</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#-279074367">第一部分 基础</a></div><div class="page">9</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#2124123276">2. 函数模板</a></div><div class="page">10</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#79933087">3. 类模板</a></div><div class="page">11</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#138059425">4. 非类型模板参数</a></div><div class="page">12</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#1010038415">5. 技巧性基础知识</a></div><div class="page">13</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#-1871829137">6. 模板实战</a></div><div class="page">14</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#-1843097486">7. 模板术语</a></div><div class="page">15</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#1731608449">第二部分 深入模板</a></div><div class="page">16</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#1994043956">8. 深入模板基础</a></div><div class="page">17</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#-1786003200">9. 模板中的名称</a></div><div class="page">18</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#-1861629327">10. 实例化</a></div><div class="page">19</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#-2029156375">11. 模板实参演绎</a></div><div class="page">20</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#-134753707">12. 特化与重载</a></div><div class="page">21</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#-1756370890">13. 未来的方向</a></div><div class="page">22</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#1954205409">第三部分 模板与设计</a></div><div class="page">23</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#-1800528579">14. 模板的多态威力</a></div><div class="page">24</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#-102969376">15. trait与policy类</a></div><div class="page">25</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#1598116640">16. 模板与继承</a></div><div class="page">26</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#319895480">17. metaprogram</a></div><div class="page">27</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#-2042610287">18. 表达式模板</a></div><div class="page">28</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#956828551">第四部分 高级应用程序</a></div><div class="page">29</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#-1111971583">19. 类型区分</a></div><div class="page">30</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#-639604333">20. 智能指针</a></div><div class="page">31</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#-1116752198">21. tuple</a></div><div class="page">32</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#2018541609">22. 函数对象和回调</a></div><div class="page">33</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#1670512938">附录A 一处定义原则</a></div><div class="page">34</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#1075189977">附录B 重载解析</a></div><div class="page">35</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#-824599500">C++ Conccurency</a></div><div class="page">36</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#474158456">1. 你好，C++的并发世界</a></div><div class="page">37</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#-1824287380">2. 线程管理</a></div><div class="page">38</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#1205900422">3. 线程间数据共享</a></div><div class="page">39</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#-413288036">4. 同步并发操作</a></div><div class="page">40</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#-1398536899">5. C++内存模型和原子类型操作</a></div><div class="page">41</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#-1647455493">6. 基于锁的并发数据结构设计</a></div><div class="page">42</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#680159428">7. 无锁并发数据结构设计</a></div><div class="page">43</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#-110063759">8. 并发代码设计</a></div><div class="page">44</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#-591672300">9. 高级线程管理</a></div><div class="page">45</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#-1300936308">10. 多线程程序的测试和调试</a></div><div class="page">46</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#1941208249">C++ Lambda Story</a></div><div class="page">47</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#1734441692">1. Lambdas in C++98/03</a></div><div class="page">48</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#822245526">2. Lambdas in C++11</a></div><div class="page">55</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#858187682">汇编语言</a></div><div class="page">102</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#185893544">第一章 基础知识</a></div><div class="page">103</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#-2081311865">第二章 寄存器</a></div><div class="page">118</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#-1670513275">第三章 寄存器(内存访问)</a></div><div class="page">119</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#-262646426">现代操作系统</a></div><div class="page">120</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#789304755">操作系统</a></div><div class="page">121</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#1534051343">Functional Programming_</a></div><div class="page">122</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#1004310786">编译原理</a></div><div class="page">125</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#1573558248">内存池(Memory Pool)</a></div><div class="page">126</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#-956561027">Effective C++</a></div><div class="page">127</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#1162768069">第一章 让自己习惯 C++</a></div><div class="page">128</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#1706899533">第二章 构造/析构/赋值运算</a></div><div class="page">143</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#-12458821">第三章 资源管理</a></div><div class="page">166</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#539570669">第四章 设计与声明</a></div><div class="page">182</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#-298164730">STL源码分析</a></div><div class="page">183</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#158479441">The Terms in Book 《STL源码分析》</a></div><div class="page">246</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#756852540">Algorithm_Tutorial</a></div><div class="page">251</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#79725369">Topic title</a></div><div class="page">281</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#-1529361291">《TCP/IP详解卷一：协议》</a></div><div class="page">288</div></div></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="1762734136">Flask_Tutorial</h1><p id="1762734136#n8979x_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="-1881649746">Topic title</h1><section><h2 id="-1881649746#ppqwqqq-s-github" data-toc="ppqwqqq-s-github#README.md-ppqwqqq-s-github">ppQwQqq's GitHub</h2></section></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="-699101681">C++ Templates</h1><section><h2 id="-699101681#1" data-toc="1#C-Templates.md-1">1. 函数模板</h2><section><h3 id="-699101681#1-1" data-toc="1-1#C-Templates.md-1-1">1.1 初探函数模板</h3><section><h4 id="-699101681#1-1-1" data-toc="1-1-1#C-Templates.md-1-1-1">1.1.1 定义模板</h4><p id="-699101681#z3l1sr2_8">此处定义了一个返回两数中较大者的函数</p><div class="detached code-block" id="-699101681#z3l1sr2_9"><pre><code class="language-cpp">template&lt;typename T&gt;
inline T const&amp; max(T const&amp; a, T const&amp; b){
    return a &gt; b ? a : b;
}</code></pre></div><p id="-699101681#z3l1sr2_10">上述代码中的typename为模板参数，T则为模板参数名。  T可以换成其他任意的合法字符，如：MyType。</p><p id="-699101681#z3l1sr2_11">模板参数typename可以替换为class，在当前语义环境下class与typename的效果是相同的。  注意：引入类型参数时，typename不能替换为struct。</p><div class="detached code-block" id="-699101681#z3l1sr2_12"><pre><code class="language-cpp">template&lt;class T&gt;
inline T const&amp; max(T const&amp; a, T const&amp; b){
    return a &gt; b ? a : b;
}</code></pre></div></section><section><h4 id="-699101681#1-1-2" data-toc="1-1-2#C-Templates.md-1-1-2">1.1.2 使用模板</h4><p id="-699101681#z3l1sr2_15">此处为模板函数的使用：</p><div class="detached code-block" id="-699101681#z3l1sr2_16"><pre><code class="language-cpp">#include &lt;iostream&gt;

template&lt;typename T&gt;
inline T const&amp; max(T const&amp; a, T const&amp; b){
    using Type = decltype(a);
    std::cout &lt;&lt; &quot;Type:&quot; &lt;&lt; typeid(std::type_identity_t&lt;T&gt;).name() &lt;&lt; '\n';
    return a &gt; b ? a : b;
}

int main(){
    printf(&quot;Result: %lf\n&quot;, ::max(3.0, 4.4));
    printf(&quot;Result: %d\n&quot;, ::max(3, 5));
    printf(&quot;Result: %c\n&quot;, ::max('a', 'b'));
    printf(&quot;Result: %s\n&quot;, ::max(&quot;abcf&quot;, &quot;abcd&quot;));
    return 0;
}

/* output:
 * Type:d
 * Result: 4.400000
 * Type:i
 * Result: 5
 * Type:c
 * Result: b
 * Type:A5_c
 * Result: abcf
 */</code></pre></div><p id="-699101681#z3l1sr2_17">注：使用域限定符::是为了保证调用的是全局命名空间内的max()(即自己定义的max函数)， 因为在标准库中也存在一个std::max()，为避免二义性所以添加域限定符。</p><p id="-699101681#z3l1sr2_18">由输出结果可知，类型T被转换为了传入参数的类型。  因为对于模板函数的每次调用，模板参数T都被实例化(instantiation)为了对应的类型。  operator&lt;(以及其他运算符) 适用于内置类型。如果需要对自定义类进行比较运算，则需要手动重载该运算符。</p><div class="detached code-block" id="-699101681#z3l1sr2_19"><pre><code class="language-cpp">MyClass t1, t2;
std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; ::max(t1, t2);
/*
 * Compiling Error
 */</code></pre></div><p id="-699101681#z3l1sr2_20">由此可知，模板实例化会经历两次编译：</p><ol class="list list-decimal" id="-699101681#z3l1sr2_21" type="1" start="1"><li class="list-item" id="-699101681#z3l1sr2_24"><p>实例化之前，检查模板本身是否存在语法错误。</p></li><li class="list-item" id="-699101681#z3l1sr2_25"><p>实例化期间，检查模板函数调用是否有效(对指定的类型是否存在重载函数)。</p></li></ol></section></section><section><h3 id="-699101681#1-2-deduction" data-toc="1-2-deduction#C-Templates.md-1-2-deduction">1.2 实参的推导(deduction)</h3><p id="-699101681#z3l1sr2_26">模板参数T的类型由调用函数的实参决定。  当实参类型不同时，例如：</p><div class="detached code-block" id="-699101681#z3l1sr2_27"><pre><code class="language-cpp">template&lt;typename T&gt;    
inline T const&amp; max(T const&amp; a, T const&amp; b);
max('a', 23);   // Error
max(23, 43);    // Ok</code></pre></div><p id="-699101681#z3l1sr2_28">这里的T不允许进行自动的类型转换，所以当接受的实参类型不同时就会导致编译器报错。  处理上述问题的三种方法：</p><ol class="list list-decimal" id="-699101681#z3l1sr2_29" type="1" start="1"><li class="list-item" id="-699101681#z3l1sr2_32"><p id="-699101681#z3l1sr2_35">对实参进行强制类型转换，使其类型相互匹配：</p><div class="detached code-block" id="-699101681#z3l1sr2_36"><pre><code class="language-cpp">max(static_cast&lt;int&gt;('a'), 32);
max&lt;double&gt;(3, 3.4)</code></pre></div></li><li class="list-item" id="-699101681#z3l1sr2_33"><p id="-699101681#z3l1sr2_37">显示指定或限定T的类型</p></li><li class="list-item" id="-699101681#z3l1sr2_34"><p id="-699101681#z3l1sr2_38">指定两个参数可以具有不同类型的参数</p></li></ol></section></section></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="2085723537">1. 关于本书</h1><p id="2085723537#j0dgkc_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="-279074367">第一部分 基础</h1><p id="-279074367#-24kjl0_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="2124123276">2. 函数模板</h1><p id="2124123276#-r4ia4f_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="79933087">3. 类模板</h1><p id="79933087#-z3fxs2_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="138059425">4. 非类型模板参数</h1><p id="138059425#z1eexvg_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="1010038415">5. 技巧性基础知识</h1><p id="1010038415#knd172_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="-1871829137">6. 模板实战</h1><p id="-1871829137#-nz9h1e_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="-1843097486">7. 模板术语</h1><p id="-1843097486#-3dcqcl_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="1731608449">第二部分 深入模板</h1><p id="1731608449#kcdxr0_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="1994043956">8. 深入模板基础</h1><p id="1994043956#-3032p3_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="-1786003200">9. 模板中的名称</h1><p id="-1786003200#-1wgwj7_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="-1861629327">10. 实例化</h1><p id="-1861629327#z10ch8c_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="-2029156375">11. 模板实参演绎</h1><p id="-2029156375#-oosg98_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="-134753707">12. 特化与重载</h1><p id="-134753707#z4v9f4o_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="-1756370890">13. 未来的方向</h1><p id="-1756370890#z835dg7_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="1954205409">第三部分 模板与设计</h1><p id="1954205409#s1u5sc_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="-1800528579">14. 模板的多态威力</h1><p id="-1800528579#-sydvdc_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="-102969376">15. trait与policy类</h1><p id="-102969376#bjbo8d_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="1598116640">16. 模板与继承</h1><p id="1598116640#-l1brgz_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="319895480">17. metaprogram</h1><p id="319895480#ua28id_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="-2042610287">18. 表达式模板</h1><p id="-2042610287#-mgz944_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="956828551">第四部分 高级应用程序</h1><p id="956828551#nrxau_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="-1111971583">19. 类型区分</h1><p id="-1111971583#-qgxgxi_2">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="-639604333">20. 智能指针</h1><p id="-639604333#h518lm_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="-1116752198">21. tuple</h1><p id="-1116752198#-n5ruzx_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="2018541609">22. 函数对象和回调</h1><p id="2018541609#-p1p5do_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="1670512938">附录A 一处定义原则</h1><p id="1670512938#-q80r31_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="1075189977">附录B 重载解析</h1><p id="1075189977#-vzd6i4_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="-824599500">C++ Conccurency</h1><p id="-824599500#vsjseh_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="474158456">1. 你好，C++的并发世界</h1><p id="474158456#z5sah91_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="-1824287380">2. 线程管理</h1><p id="-1824287380#u4y1cx_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="1205900422">3. 线程间数据共享</h1><p id="1205900422#-bczjt5_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="-413288036">4. 同步并发操作</h1><p id="-413288036#z5vcqb5_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="-1398536899">5. C++内存模型和原子类型操作</h1><p id="-1398536899#sf1880_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="-1647455493">6. 基于锁的并发数据结构设计</h1><p id="-1647455493#qhnhwy_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="680159428">7. 无锁并发数据结构设计</h1><p id="680159428#-3186pj_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="-110063759">8. 并发代码设计</h1><p id="-110063759#n1h8ak_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="-591672300">9. 高级线程管理</h1><p id="-591672300#-gsxx6v_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="-1300936308">10. 多线程程序的测试和调试</h1><p id="-1300936308#-5qc69r_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="1941208249">C++ Lambda Story</h1><p id="1941208249#j52l84_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="1734441692">1. Lambdas in C++98/03</h1><section><h2 id="1734441692#tcetpt_3" data-toc="tcetpt_3#1-Lambdas-in-C-98-03.md-tcetpt_3">本章的主要内容</h2><ol class="list list-decimal" id="1734441692#tcetpt_4" type="1" start="1"><li class="list-item" id="1734441692#tcetpt_8"><p>如何将仿函数(functor)传给标准库中的算法</p></li><li class="list-item" id="1734441692#tcetpt_9"><p>仿函数和函数指针(function pointer)的限制</p></li><li class="list-item" id="1734441692#tcetpt_10"><p>为什么函数辅助工具不够好</p></li></ol><section><h3 id="1734441692#c-98-03-callable-object" data-toc="c-98-03-callable-object#1-Lambdas-in-C-98-03.md-c-98-03-callable-object">在 C++98/03 中的可调用对象(callable object)</h3><p id="1734441692#tcetpt_11">在C++标准库的设计理念中，像&quot;std::sort&quot;、&quot;std::for_each&quot;、&quot;std::transform&quot;等算法可以接受任何可调用对象(callable objects)， 并将其应用于输入容器的元素，然而，在C++98/03标准中，这些算法只能接受函数指针和仿函数(函数对象)。</p><p id="1734441692#tcetpt_12">此处使用一个函数输出vector中的元素。  一般的实现：</p><div class="detached code-block" id="1734441692#tcetpt_13"><pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

void PrintFunc(int x){
    std::cout &lt;&lt; x &lt;&lt; '\n';
}

int main(){
    std::vector&lt;int&gt; v;
    v.push_back(1);
    v.push_back(2);
    for_each(v.begin(), v.end(), PrintFunc);
}
/* output：
 * 1
 * 2
 */</code></pre></div><p id="1734441692#tcetpt_14">上面的代码使用std::for_each遍历整个vector容器(使用for_each的原因是C++98/03还不支持范围遍历)， 并且它将PrintFunc作为一个可调用对象进行传递。</p><p id="1734441692#tcetpt_15">接下来，将这个函数转换为一个仿函数(functor)：</p><div class="detached code-block" id="1734441692#tcetpt_16"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

struct PrintFunctor{
    void operator()(int x) const {
        std::cout &lt;&lt; x &lt;&lt; '\n';
    }
};

/* or this version
class PrintFunctor{
public:
    void operator()(int x) const {
        std::cout &lt;&lt; x &lt;&lt; '\n';
    }
};
*/

int main(){
    std::vector&lt;int&gt; v;
    v.push_back(1);
    v.push_back(2);
    for_each(v.begin(), v.end(), PrintFunctor());
}
/* output:
 * 1
 * 2
 */</code></pre></div><p id="1734441692#tcetpt_17">上述例子使用了一个具有operator()的仿函数。</p><p id="1734441692#tcetpt_18">然而函数指针(function pointer)通常是无状态的，即它们只是指向一个函数，并不能存储任何额外的信息或状态， 相比之下仿函数可以拥有成员变量，从而允许它们在多个调用之间存储状态。</p><p id="1734441692#tcetpt_19">定义一个简单的仿函数，让其记录自己被调用的次数，其关键在于定义仿函数中的状态量：</p><div class="detached code-block" id="1734441692#tcetpt_20"><pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

class printFunctor{
public:
    printFunctor(const std::string str): strText(str), numCalls(0) { }
    void operator()(int x){
        std::cout &lt;&lt; strText &lt;&lt; x &lt;&lt; '\n';
    }
    int getNumCalls() const{
        return numCalls;
    }
private:
    std::string strText;
    mutable int numCalls;
};

int main(){
    std::vector v = {1, 2, 3, 4, 5, 6};
    std::string preText = &quot;Elem: &quot;;
    printFunctor visitor = 
    std::for_each(v.begin(), v.end(), printFunctor(preText));
    std::cout &lt;&lt; &quot;numCalls: &quot; &lt;&lt; visitor.getNumCalls() &lt;&lt; '\n';
}
/* output:
 * 1
 * 2
 * 3
 * 4
 * 5
 * 6
 * numCalls: 6
 */</code></pre></div></section><section><h3 id="1734441692#functor" data-toc="functor#1-Lambdas-in-C-98-03.md-functor">仿函数(functor)的问题</h3><p id="1734441692#tcetpt_22">虽然可以使用一个单独的类去设计仿函数， 但是在与算法调用不同的地方编写函数和仿函数， 这导致函数代码在源文件中的位置与算法调用的位置相距很远，由此增加了代码的阅读和维护难度。</p><p id="1734441692#tcetpt_23">在C++98/03中，有一个限制是不能使用局部类型(在函数内部定义的类型)作为模板参数，例如：</p><div class="detached code-block" id="1734441692#tcetpt_24"><pre><code class="language-cpp">int main(){
    /* define a type inside a function */
    struct PrintFunctor{
        void operator()(int x) const{
            std::cout &lt;&lt; x &lt;&lt; '\n';
        }
    };
    
    std::vector&lt;int&gt; v(10, 1);
    std::for_each(v.begin(), v.end(), PrintFunctor());
}</code></pre></div><p id="1734441692#tcetpt_25">使用 GCC 的 -std=C++98 标准进行编译，会出现如下错误：</p><div class="detached code-block" id="1734441692#tcetpt_26"><pre><code class="language-cpp">error: template argument for
'template&lt;class _IIter, class _Funct&gt; _Funct
std::for_each(_IIter, _IIter, _Funct)'
uses local type 'main()::PrintFunctor'</code></pre></div></section><section><h3 id="1734441692#functional-helper" data-toc="functional-helper#1-Lambdas-in-C-98-03.md-functional-helper">使用 辅助函数(functional helper) 解决</h3><p id="1734441692#tcetpt_27">在标准库中 <span class="inline-code" id="1734441692#tcetpt_39">&lt;functional&gt;</span> 头文件，有很多类型和函数可以与标准算法一起使用： <span class="inline-code" id="1734441692#tcetpt_41">std::plus&lt;T&gt;()</span>: 接受两个参数并返回它们的和。 <span class="inline-code" id="1734441692#tcetpt_43">std::minus&lt;T&gt;()</span>: 接受两个参数并返回它们的差。</p><div class="detached code-block" id="1734441692#tcetpt_28"><pre><code class="language-cpp">#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main(){
    std::vector&lt;int&gt; vi1 = {1, 2, 3, 4, 5, 6};
    std::vector&lt;int&gt; vi2 = {2, 3, 4, 5, 6, 7};
    std::vector&lt;int&gt; vRes(vi1.size());
    
    std::transform(vi1.begin(), vi1.end(), vi2.begin(), 
                    vRes.begin(), std::plus&lt;int&gt;());
    std::cout &lt;&lt; &quot;Res for plus: &quot;;
    for(int n: vRes) std::cout &lt;&lt; n &lt;&lt; ' ';
    
    std::transform(vi1.begin(), vi1.end(), vi2.begin(),
                    vRes.begin(), std::minus&lt;int&gt;());
    std::cout &lt;&lt; &quot;\nRes for minus: &quot;;
    for(int n: vRes) std::cout &lt;&lt; n &lt;&lt; ' ';  
}
/* output:
 * Res for plus: 3 5 7 9 11 13
 * Res for minus: -1 -1 -1 -1 -1 -1
 */</code></pre></div><p id="1734441692#tcetpt_29"><span class="inline-code" id="1734441692#tcetpt_44">std::less&lt;T&gt;()</span>: 接受两个参数并返回第一个参数是否小于第二个参数。 <span class="inline-code" id="1734441692#tcetpt_46">std::greater_equal&lt;T&gt;()</span>: 接受两个参数并返回第一个参数是否大于或等于第二个参数。 <span class="inline-code" id="1734441692#tcetpt_48">std::bind1st</span>: 创建一个可调用对象，将第一个参数固定为给定值。 <span class="inline-code" id="1734441692#tcetpt_50">std::bind2nd</span>: 创建一个可调用对象，将第二个参数固定为给定值。</p><p id="1734441692#tcetpt_30">使用辅助函数的好处：</p><div class="detached code-block" id="1734441692#tcetpt_31"><pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;vector&gt;

int main(){
    std::vector&lt;int&gt; v = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    
    const size_t smaller5 = std::count_if(
    v.begin(), v.end(), 
    std::bind2nd(std::less&lt;int&gt;(), 5));

    return smaller5;
}</code></pre></div><p id="1734441692#tcetpt_32">上面的代码中，使用std::bind2nd将 5 绑定至std::less函数(x &lt; y)的第二个参数(x &lt; 5)， 即返回的值为 return x &lt; 5。</p><div class="detached code-block" id="1734441692#tcetpt_33"><pre><code class="language-cpp">const size_t greater5 = std::count_if(
v.begin(), v.end(), 
std::bind1st(std::less&lt;int&gt;(), 5));</code></pre></div><p id="1734441692#tcetpt_34">同理，此处使用std::bind1st将 5 绑定至std::less函数(x &gt; y)的第一个参数(5 &lt; x)， 即返回值的为 return 5 &lt; x。</p><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="1734441692#tcetpt_51">补充：std::bind的用法</p><div class="detached code-block" id="1734441692#tcetpt_52"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;functional&gt;

int add(int x, int y){ 
  std::cout &lt;&lt; &quot;1st param: &quot; &lt;&lt; x &lt;&lt; '\n';
  return x + y; 
}

int main(){
  /* 创建一个绑定第一个参数为10的函数对象 */
  auto res = std::bind(add, 10, std::placeholders::_1);

  std::cout &lt;&lt; &quot;12 + 10 = &quot; &lt;&lt; res(12) &lt;&lt; '\n';
}
/* output:
 * 12 + 10 = 1st param: 10 
 * 22
 */</code></pre></div></div>
</blockquote>
<p id="1734441692#tcetpt_36">然而，在很多情况下，一个功能实现会有很多函数组成，那么此处语法就会显得很复杂：</p><div class="detached code-block" id="1734441692#tcetpt_37"><pre><code class="language-cpp">std::vector&lt;int&gt; v = {1, 2, 3, 4, 5, 6, 7, 8};
const size_t val = std::count_if(v.begin(), v.end(),
                           std::bind(std::logical_and&lt;bool&gt;(),
                           std::bind(std::greater&lt;int&gt;(), _1, 2),
                           std::bind(std::less_equal&lt;int&gt;(), _1, 6)));</code></pre></div><p id="1734441692#tcetpt_38">上面这么复杂的语法其实实现的结果就是 return x &gt; 2 &amp;&amp; x &lt;= 6。  这些问题在后面的C++11中得到了改善。</p></section></section></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="822245526">2. Lambdas in C++11</h1><p id="822245526#g5pg4n_3">关于C++11的最终草案N3337 (<a href="https://timsong-cpp.github.io/cppwp/n3337/expr.prim.lambda">https://timsong-cpp.github.io/cppwp/n3337/expr.prim.lambda</a>)中Lambda表达式的内容如下：  Lambda表达式(Lambda Expressions):</p><ol class="list list-decimal" id="822245526#g5pg4n_4" type="1" start="1"><li class="list-item" id="822245526#g5pg4n_9"><p>Lambda 表达式的目的和语法 </p><ul class="list" id="822245526#g5pg4n_32" start="1"><li class="list-item" id="822245526#g5pg4n_33"><p>Lambda 表达式提供了一种简洁的方式来创建简单的函数对象。</p></li><li class="list-item" id="822245526#g5pg4n_34"><p>示例：</p></li><li class="list-item" id="822245526#g5pg4n_35"><div class="detached code-block" id="822245526#g5pg4n_38"><pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;cmath&gt;
void abssort(float* x, unsigned N){
  std::sort(x, x + N, [](float a, float b){ 
     return std::abs(a) &lt; std::abs(b); 
   });
}</code></pre></div></li><li class="list-item" id="822245526#g5pg4n_36"><p>Lambda 表达式的语法:</p></li><li class="list-item" id="822245526#g5pg4n_37"><div class="detached code-block" id="822245526#g5pg4n_39"><pre><code class="language-python">lambda-expression: 
      lambda-introducer lambda-declaratoropt compound-statement
lambda-introducer:
      [ lambda-captureopt ]
lambda-capture:
      capture-default
      capture-list
      capture-default, capture-list
lambda-default:
      &amp;
      =
lambda-list:
      capture-opt
      capture-list, capture ...opt
capture:
      identifier
      &amp; identifier
      this
lambda-declarator:
      ( parameter-declaration-clause ) mutableopt
      exception-specificationopt attribute-specifier-seqopt trailing-return-typeopt</code></pre></div></li></ul></li><li class="list-item" id="822245526#g5pg4n_10"><p>Lambda表达式计算的结果 </p><ul class="list" id="822245526#g5pg4n_40" start="1"><li class="list-item" id="822245526#g5pg4n_41"><p>计算Lambda 表达式会生成一个prvalue临时对象(closure object)。</p></li><li class="list-item" id="822245526#g5pg4n_42"><p>Lambda 表达式不应出现在未计算的操作数中。</p></li><li class="list-item" id="822245526#g5pg4n_43"><p>闭包对象的行为类似于函数对象。</p></li></ul></li><li class="list-item" id="822245526#g5pg4n_11"><p>Lambda 表达式类型 </p><ul class="list" id="822245526#g5pg4n_44" start="1"><li class="list-item" id="822245526#g5pg4n_45"><p>Lambda 表达式的类型是唯一的、未命名的的非联合类型，成为闭包类型(closure type)。</p></li><li class="list-item" id="822245526#g5pg4n_46"><p>闭包类型在包含相应 Lambda 表达式的最小块作用域、类作用域或命名空间作用域中声明。</p></li></ul></li><li class="list-item" id="822245526#g5pg4n_12"><p>Lambda 表达式的默认行为 </p><ul class="list" id="822245526#g5pg4n_47" start="1"><li class="list-item" id="822245526#g5pg4n_48"><p>如果 Lambda 表达式不包含 Lambda 声明符，则默认为'()'。</p></li><li class="list-item" id="822245526#g5pg4n_49"><p>如果 Lambda 表达式不包含尾返回类型，则尾返回类型默认为以下类型： </p><ul class="list" id="822245526#g5pg4n_50" start="1"><li class="list-item" id="822245526#g5pg4n_51"><p>如果复合语句的形式为''， 则返回表达式的类型。</p></li><li class="list-item" id="822245526#g5pg4n_52"><p>否则，返回'void'。</p></li></ul></li></ul></li><li class="list-item" id="822245526#g5pg4n_13"><p>闭包类型的函数调用运算符 </p><ul class="list" id="822245526#g5pg4n_53" start="1"><li class="list-item" id="822245526#g5pg4n_54"><p>闭包类型具有一个公共的内联函数调用运算符，其参数和返回类型由 Lambda 表达式的参数声明子句和尾返回类型描述。</p></li><li class="list-item" id="822245526#g5pg4n_55"><p>如果参数声明子句后没有'mutable'，则函数调用运算符被声明为'const'。</p></li><li class="list-item" id="822245526#g5pg4n_56"><p>该运算符既不是虚拟的也不是声明为'volatile'。</p></li><li class="list-item" id="822245526#g5pg4n_57"><p>Lambda 声明符中的任何异常规范适用于相应的函数调用运算符。</p></li></ul></li><li class="list-item" id="822245526#g5pg4n_14"><p>无捕获的 Lambda 表达式的函数指针转换 </p><ul class="list" id="822245526#g5pg4n_58" start="1"><li class="list-item" id="822245526#g5pg4n_59"><p>无捕获的 Lambda 表达式的闭包类型具有一个公共的非虚拟的'const'转换函数，该函数转换为具有相同参数和返回类型的函数指针。</p></li><li class="list-item" id="822245526#g5pg4n_60"><p>该转换函数返回的值是一个函数的地址，调用该函数具有与调用闭包类型的函数调用运算符相同的效果。</p></li></ul></li><li class="list-item" id="822245526#g5pg4n_15"><p>Lambda 表达式的复合语句 </p><ul class="list" id="822245526#g5pg4n_61" start="1"><li class="list-item" id="822245526#g5pg4n_62"><p>Lambda 表达式的复合语句生成函数调用运算符的函数体，但在名称查找和类型确定方面，复合语句被视为 Lambda 表达式的一部分。</p></li></ul></li><li class="list-item" id="822245526#g5pg4n_16"><p>捕获规则 </p><ul class="list" id="822245526#g5pg4n_63" start="1"><li class="list-item" id="822245526#g5pg4n_64"><p>如果 Lambda 捕获包含默认捕获'&amp;'，则捕获列表中的标识符前不应有'&amp;'。</p></li><li class="list-item" id="822245526#g5pg4n_65"><p>如果 Lambda 捕获包含默认捕获'='，则捕获列表中的标识符前不应有&lsquo;this',且每个标识符前应有'&amp;'。</p></li><li class="list-item" id="822245526#g5pg4n_66"><p>捕获列表中的标识符或'this'不能重复。</p></li></ul></li><li class="list-item" id="822245526#g5pg4n_17"><p>本地 Lambda 表达式 </p><ul class="list" id="822245526#g5pg4n_67" start="1"><li class="list-item" id="822245526#g5pg4n_68"><p>如果 Lambda 表达式的最小封闭作用域是块作用域，则称为本地 Lambda 表达式；否则，不应在 Lambda 引入器中有捕获列表。</p></li></ul></li><li class="list-item" id="822245526#g5pg4n_18"><p>捕获列表中的标识符查找 </p><ul class="list" id="822245526#g5pg4n_69" start="1"><li class="list-item" id="822245526#g5pg4n_70"><p>捕获列表中的标识符使用无资格名称查找规则进行查找，每个查找应找到在本地 Lambda 表达式的到达作用域中声明的具有自动存储持续时间的变量。</p></li></ul></li><li class="list-item" id="822245526#g5pg4n_19"><p>隐式捕获 </p><ul class="list" id="822245526#g5pg4n_71" start="1"><li class="list-item" id="822245526#g5pg4n_72"><p>如果 Lambda 表达式具有捕获默认值且复合语句 odr-使用'this'或具有自动存储持续时间的变量，则这些实体被隐式捕获。</p></li></ul></li><li class="list-item" id="822245526#g5pg4n_20"><p>实体的捕获 </p><ul class="list" id="822245526#g5pg4n_73" start="1"><li class="list-item" id="822245526#g5pg4n_74"><p>如果实体被显式或隐式捕获，则称其捕获。捕获的实体在包含 Lambda 表达式的作用域中被 odr-使用。</p></li></ul></li><li class="list-item" id="822245526#g5pg4n_21"><p>默认参数中的 Lambda表达式 </p><ul class="list" id="822245526#g5pg4n_75" start="1"><li class="list-item" id="822245526#g5pg4n_76"><p>出现在默认参数中的 Lambda 表达式不应显式或隐式捕获任何实体。</p></li></ul></li><li class="list-item" id="822245526#g5pg4n_22"><p>按值捕获 </p><ul class="list" id="822245526#g5pg4n_77" start="1"><li class="list-item" id="822245526#g5pg4n_78"><p>实体按值捕获，如果它被隐式捕获且捕获默认值为'='，或被显式捕获且捕获不包括'&amp;'。</p></li></ul></li><li class="list-item" id="822245526#g5pg4n_23"><p>按引用捕获 </p><ul class="list" id="822245526#g5pg4n_79" start="1"><li class="list-item" id="822245526#g5pg4n_80"><p>实体按引用捕获，如果它被隐式或显式捕获，但不是按值捕获。</p></li></ul></li><li class="list-item" id="822245526#g5pg4n_24"><p>嵌套 Lambda 表达式的捕获转换 </p><ul class="list" id="822245526#g5pg4n_81" start="1"><li class="list-item" id="822245526#g5pg4n_82"><p>如果一个 Lambda 表达式 m2 捕获一个实体，而该实体被其直接封闭的 Lambda 表达式 m1 捕获，则 m2 的捕获根据 m1 的捕获方式进行转换。</p></li></ul></li><li class="list-item" id="822245526#g5pg4n_25"><p>按值捕获的 id 表达式 </p><ul class="list" id="822245526#g5pg4n_83" start="1"><li class="list-item" id="822245526#g5pg4n_84"><p>每个按值捕获的实体的 id 表达式被转换为对闭包类型中相应未命名数据成员的访问。</p></li></ul></li><li class="list-item" id="822245526#g5pg4n_26"><p>decltype 操作符中的捕获 </p><ul class="list" id="822245526#g5pg4n_85" start="1"><li class="list-item" id="822245526#g5pg4n_86"><p>decltype((x)) 中的 x 被视为对闭包类型中相应数据成员的访问。</p></li></ul></li><li class="list-item" id="822245526#g5pg4n_27"><p>闭包类型的构造函数和赋值运算符 </p><ul class="list" id="822245526#g5pg4n_87" start="1"><li class="list-item" id="822245526#g5pg4n_88"><p>与 Lambda 表达式关联的闭包类型具有被删除的默认构造函数和被删除的复制赋值运算符。它具有隐式声明的复制构造函数，并且可能具有隐式声明的移动构造函数。</p></li></ul></li><li class="list-item" id="822245526#g5pg4n_28"><p>闭包类型的析构函数 </p><ul class="list" id="822245526#g5pg4n_89" start="1"><li class="list-item" id="822245526#g5pg4n_90"><p>与 Lambda 表达式关联的闭包类型具有隐式声明的析构函数。</p></li></ul></li><li class="list-item" id="822245526#g5pg4n_29"><p>捕获的实体的初始化 </p><ul class="list" id="822245526#g5pg4n_91" start="1"><li class="list-item" id="822245526#g5pg4n_92"><p>在评估 Lambda 表达式时，按值捕获的实体用于直接初始化生成的闭包对象的每个相应非静态数据成员。</p></li></ul></li><li class="list-item" id="822245526#g5pg4n_30"><p>按引用捕获的生命周期 </p><ul class="list" id="822245526#g5pg4n_93" start="1"><li class="list-item" id="822245526#g5pg4n_94"><p>如果按引用捕获的实体在其生命周期结束后调用函数调用运算符，可能会导致未定义行为。</p></li></ul></li><li class="list-item" id="822245526#g5pg4n_31"><p>捕获的包展开 </p><ul class="list" id="822245526#g5pg4n_95" start="1"><li class="list-item" id="822245526#g5pg4n_96"><p>捕获后跟随省略号表示包展开。</p></li></ul></li></ol><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="822245526#g5pg4n_97">补充：移动构造函数和移动赋值运算符</p><ul class="list" id="822245526#g5pg4n_98" start="1"><li class="list-item" id="822245526#g5pg4n_101"><p>移动构造函数的实现示例：</p></li></ul><div class="detached code-block" id="822245526#g5pg4n_99"><pre><code class="language-cpp">class MyClass{
  int* data;

  MyClass(int size): data(new int[size]){ }
  
  MyClass(MyClass&amp;&amp; other/* 此处接受一个右值 */) noexcept: data(other.data){
    // 将其他对象的数据指针置为空，表示资源所有权已经转移  
    other.data = nullptr;
  }
  
  ~MyClass(){
      delete[] data;
  }
  
  MyClass(const MyClass&amp;) = delete;
  MyClass&amp; operator=(const MyClass&amp;) = delete;
};

int main(){
  MyClass obj1(10);   // 调用普通构造函数
  MyClass obj2 = std::move(obj1); // 调用移动构造函数
  
  // 此时 ojb1.data 为 nullptr，资源所有权已经转移给 obj2
}</code></pre></div><ul class="list" id="822245526#g5pg4n_100" start="1"><li class="list-item" id="822245526#g5pg4n_102"><p id="822245526#g5pg4n_106">移动构造函数的用途：</p><ul class="list" id="822245526#g5pg4n_107" start="1"><li class="list-item" id="822245526#g5pg4n_108"><p>提高性能：在处理大型数据结构或资源密集型对象时，移动构造函数可以显著减少不必要的深度拷贝操作，从而提高程序性能。</p></li><li class="list-item" id="822245526#g5pg4n_109"><p>资源管理：在实现资源管理类（如智能指针、容器类）时，移动构造函数可以更高效地管理资源转移。</p></li></ul></li><li class="list-item" id="822245526#g5pg4n_103"><p id="822245526#g5pg4n_110">什么时候会调用移动构造函数：</p><ul class="list" id="822245526#g5pg4n_111" start="1"><li class="list-item" id="822245526#g5pg4n_112"><p>当一个临时对象(右值)被用来初始化另一个对象时。</p></li><li class="list-item" id="822245526#g5pg4n_113"><p>当返回一个局部对象时，如果启用了返回值优化(ROV)，则可能会调用移动构造函数。</p></li><li class="list-item" id="822245526#g5pg4n_114"><p>当使用标准库函数如'std::move'将一个对象转换为右值引用时。</p></li></ul></li><li class="list-item" id="822245526#g5pg4n_104"><p id="822245526#g5pg4n_115">注意事项：</p><ul class="list" id="822245526#g5pg4n_116" start="1"><li class="list-item" id="822245526#g5pg4n_117"><p>移动构造函数通常与移动赋值运算符一起实现，以确保对象在移动语义下的正确行为。</p></li><li class="list-item" id="822245526#g5pg4n_118"><p>实现移动构造函数时，通常需要禁用复制构造函数和复制赋值运算符，以避免不必要的拷贝。</p></li></ul></li><li class="list-item" id="822245526#g5pg4n_105"><p id="822245526#g5pg4n_119">移动赋值运算符</p><ul class="list" id="822245526#g5pg4n_120" start="1"><li class="list-item" id="822245526#g5pg4n_121"><div class="detached code-block" id="822245526#g5pg4n_122"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;utility&gt;

MyClass{
public:
   int* data;

   MyClass(int size): data(new int[size]) { }
   MyClass(MyClass&amp;&amp; other) noexcept: data(other.data) {
      other.data = nullptr;
   }
   MyClass&amp; operator=(MyClass&amp;&amp; other) noexcept{
      if(this != other){
         // 释放当前对象持有的资源
         delete[] data;
         // 获取源对象的资源
         data = other.data;
         // 将源对象的资源指针置为空
         other.data = nullptr;
      }
      return *this;
   }

   ~MyClass(){
      delete[] data;   
   }

   MyClass(const MyClass&amp;) = delete;
   MyClass&amp; operator=(const MyClass&amp;) = delete;
};

int main(){
  MyClass obj1(10);
  MyClass obj2(20);

  obj2 = std::move(obj1);

  /* 此时obj1.data为nullptr，
         obj2.data为obj1.data的地址
   */
}</code></pre></div></li></ul></li></ul></div>
</blockquote>
<section><h2 id="822245526#g5pg4n_6" data-toc="g5pg4n_6#2-Lambdas-in-C-11.md-g5pg4n_6">本章的主要内容</h2><ul class="list" id="822245526#g5pg4n_123" start="1"><li class="list-item" id="822245526#g5pg4n_138"><p>Lambda 的基本语法</p></li><li class="list-item" id="822245526#g5pg4n_139"><p>如何捕获变量</p></li><li class="list-item" id="822245526#g5pg4n_140"><p>如何捕获成员变量</p></li><li class="list-item" id="822245526#g5pg4n_141"><p>Lambda 的返回类型</p></li><li class="list-item" id="822245526#g5pg4n_142"><p>什么是闭包对象</p></li><li class="list-item" id="822245526#g5pg4n_143"><p>如何将 Lambda 转换为函数指针并在 C 风格的 API 中使用</p></li><li class="list-item" id="822245526#g5pg4n_144"><p>什么是 IIFE(立即调用函数表达式)</p></li><li class="list-item" id="822245526#g5pg4n_145"><p>如何从 Lambda 表达式继承以及为什么这会有用</p></li></ul><section><h3 id="822245526#lambda" data-toc="lambda#2-Lambdas-in-C-11.md-lambda">Lambda 表达式的语法</h3><p id="822245526#g5pg4n_146">Lambda表达式的语法结构如下所示：</p><div class="detached code-block" id="822245526#g5pg4n_147"><pre><code class="language-cpp">[]() specifiers exception attr -&gt; ret { /* code */ }
^ ^  ^                            ^
| |  |                            |
| |  |                            optional: trailing return type
| |  |
| |  optional: mutable, exception specification or noexcept, attributes
| |
| parameter list (optional when no specifiers added)
|
Lambda introducer with an optional capture list</code></pre></div><p id="822245526#g5pg4n_148">关于Lambda 表达式在C++中的明确定义：</p><ol class="list list-decimal" id="822245526#g5pg4n_149" type="1" start="1"><li class="list-item" id="822245526#g5pg4n_150"><p>Lambda 表达式计算的结果 </p><ul class="list" id="822245526#g5pg4n_152" start="1"><li class="list-item" id="822245526#g5pg4n_153"><p>计算Lambda 表达式会生成一个prvalue(pure rvalue，纯右值)临时对象(closure object)。</p></li><li class="list-item" id="822245526#g5pg4n_154"><p>Lambda 表达式不应出现在未计算的操作数中。</p></li><li class="list-item" id="822245526#g5pg4n_155"><p>闭包对象的行为类似于函数对象。</p></li></ul></li><li class="list-item" id="822245526#g5pg4n_151"><p>Lambda 表达式类型 </p><ul class="list" id="822245526#g5pg4n_156" start="1"><li class="list-item" id="822245526#g5pg4n_157"><p>Lambda 表达式的类型是唯一的、未命名的的非联合类型，成为闭包类型(closure type)。</p></li><li class="list-item" id="822245526#g5pg4n_158"><p>闭包类型在包含相应 Lambda 表达式的最小块作用域、类作用域或命名空间作用域中声明。</p></li></ul></li></ol></section><section><h3 id="822245526#lambda_1" data-toc="lambda_1#2-Lambdas-in-C-11.md-lambda_1">Lambda 表达式的一些示例</h3><ol class="list list-decimal" id="822245526#g5pg4n_159" type="1" start="1"><li class="list-item" id="822245526#g5pg4n_163"><p id="822245526#g5pg4n_168">最简单的 Lambda 表达式：</p><div class="detached code-block" id="822245526#g5pg4n_169"><pre><code class="language-cpp">[]{};</code></pre></div><p id="822245526#g5pg4n_170">此 Lambda 表达式只需要'[]'和空的'{}'作为函数体。参数列表'()'是可选的。</p></li><li class="list-item" id="822245526#g5pg4n_164"><p id="822245526#g5pg4n_171">带有两个参数的 Lambda 表达式：</p><div class="detached code-block" id="822245526#g5pg4n_172"><pre><code class="language-cpp">[](float f, int a) { return a * f; }
[](int a, int b) { return a &lt; b; }</code></pre></div><p id="822245526#g5pg4n_173">这是 Lambda 表达式最常见的类型之一，参数通过'()'部分进行传递，这和常规的函数是一样的，不需要指定返回类型，编译器会自动推断。</p></li><li class="list-item" id="822245526#g5pg4n_165"><p id="822245526#g5pg4n_174">带尾返回类型的 Lambda 表达式：</p><div class="detached code-block" id="822245526#g5pg4n_175"><pre><code class="language-cpp">[](MyClass t) -&gt; int { auto a = t.compute(); print(a); return a; };</code></pre></div><p id="822245526#g5pg4n_176">此 Lambda 表达式显式定义了返回值类型，尾返回类型从 C++11 开始也适用于常规函数声明。</p><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="822245526#g5pg4n_178">补充：尾返回类型</p><ul class="list" id="822245526#g5pg4n_179" start="1"><li class="list-item" id="822245526#g5pg4n_187"><p>尾返回类型语法：尾返回类型使用关键字'auto&lsquo;和'-&gt;'符号。</p></li><li class="list-item" id="822245526#g5pg4n_188"><div class="detached code-block" id="822245526#g5pg4n_189"><pre><code class="language-cpp">auto functionName(parameters) -&gt; returnType</code></pre></div></li></ul><p id="822245526#g5pg4n_180">示例:</p><ol class="list list-decimal" id="822245526#g5pg4n_181" type="1" start="1"><li class="list-item" id="822245526#g5pg4n_190"><p>简单函数的尾返回类型</p></li></ol><div class="detached code-block" id="822245526#g5pg4n_182"><pre><code class="language-cpp">auto add(int a, int b) -&gt; int{
   return a + b;
}</code></pre></div><ol class="list list-decimal" id="822245526#g5pg4n_183" type="1" start="2"><li class="list-item" id="822245526#g5pg4n_191"><p>模板函数的尾返回类型</p></li></ol><div class="detached code-block" id="822245526#g5pg4n_184"><pre><code class="language-cpp">template&lt;typename T, typename U&gt;
auto add(T a, U b) -&gt; decltype(a + b){
   return a + b;
}</code></pre></div><ol class="list list-decimal" id="822245526#g5pg4n_185" type="1" start="3"><li class="list-item" id="822245526#g5pg4n_192"><p>Lambda 表达式的尾返回类型</p></li></ol><div class="detached code-block" id="822245526#g5pg4n_186"><pre><code class="language-cpp">auto lambda = [](int a, int b) -&gt; int {
   return a + b;
}</code></pre></div></div>
</blockquote>
</li><li class="list-item" id="822245526#g5pg4n_166"><p id="822245526#g5pg4n_193">额外的修饰符：</p><div class="detached code-block" id="822245526#g5pg4n_194"><pre><code class="language-cpp">[x](int a, int b) mutable { ++x; return a &lt; b; };
[](float param) noexcept { return param * param; };
[x](int a, int b) mutable noexcept { ++x; return a &lt; b; };</code></pre></div><p id="822245526#g5pg4n_195">在此示例中， Lambda 函数体前添加了修饰符：'mutable'(以便可以更改捕获的变量)和'noexcept'， 第三个 Lambda 表达式中的 'mutable noexcept' 是固定的顺序，若写成 'noexcept mutable' 则不能通过编译， 当使用了'mutable'和'noexcept&lsquo;，则需要在表达式中添加'()'。</p></li><li class="list-item" id="822245526#g5pg4n_167"><p id="822245526#g5pg4n_196">关于可选的'()'：</p></li></ol><div class="detached code-block" id="822245526#g5pg4n_160"><pre><code class="language-cpp">[x] { std::cout &lt;&lt; x; } // 不需要'()'
[x] mutable { ++x; }; // 编译错误，因为mutable存在，故需要'()'
[x]() mutable { ++x; }; // 编译正常
[] noexcept { };    // 编译错误，因为noexcept存在，故需要'()'
[]() noexcept { }; // 编译正常</code></pre></div><p id="822245526#g5pg4n_161">对于后面的C++17和C++20中的'constexpr'和'consteval'也适用。</p><section><h4 id="822245526#g5pg4n_162" data-toc="g5pg4n_162#2-Lambdas-in-C-11.md-g5pg4n_162">属性</h4><p id="822245526#g5pg4n_197">Lambda 表达式的语法还允许使用以'[[attr_name]]'形式引入的属性。 然而，如果将属性应用于Lambda，那么它应用于调用运算符的类型，而不是运算符本身。 尝试以下表达式：</p><div class="detached code-block" id="822245526#g5pg4n_198"><pre><code class="language-cpp">auto myLambda = [](int a) [[nodiscard]] { return a * a; };</code></pre></div><p id="822245526#g5pg4n_199">Clang会生成如下错误信息：</p><div class="detached code-block" id="822245526#g5pg4n_200"><pre><code class="language-none">error: 'nodiscard' attribute cannot be applied to types</code></pre></div></section></section><section><h3 id="822245526#g5pg4n_126" data-toc="g5pg4n_126#2-Lambdas-in-C-11.md-g5pg4n_126">编译展开</h3><p id="822245526#g5pg4n_201">Lambda 表达式传给std::for_each的示例：</p><div class="detached code-block" id="822245526#g5pg4n_202"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algortihm&gt;
#include &lt;vector&gt;

int main(){
    // 定义一个functor与下面一般的 Lambda 表达式做对比
    struct{ /* anonymous */
        void operator()(int x) const{
            std::cout &lt;&lt; x &lt;&lt; 'x';
        }
    } someInstances;
    
    const std::vector&lt;int&gt; v{1, 2, 3, 4, 5};
    std::for_each(v.cbegin(), v.cend(), someInstance);
    std::for_each(v.cbegin(), v.cend(), [](int x){
        std::cout &lt;&lt; x &lt;&lt; '\n'; 
    });
}</code></pre></div><p id="822245526#g5pg4n_203">在这个示例中，编译器将以下 Lambda 表达式：</p><div class="detached code-block" id="822245526#g5pg4n_204"><pre><code class="language-cpp">[](int x) { std::cout &lt;&lt; x &lt;&lt; '\n'; }</code></pre></div><p id="822245526#g5pg4n_205">转换为一个匿名仿函数，简化形式如下：</p><div class="detached code-block" id="822245526#g5pg4n_206"><pre><code class="language-cpp">struct{
    void operator()(int x){
        std::cout &lt;&lt; x &lt;&lt; '\n';
    }
}someInstances;</code></pre></div><p id="822245526#g5pg4n_207">编译器具体的展开结果如下：</p><div class="detached code-block" id="822245526#g5pg4n_208"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main()
{
  std::vector&lt;int, std::allocator&lt;int&gt; &gt; v = std::vector&lt;int, std::allocator&lt;int&gt; &gt;{std::initializer_list&lt;int&gt;{1, 2, 3, 4, 5}, std::allocator&lt;int&gt;()};
    
  class __lambda_7_39
  {
    public: 
    inline /*constexpr */ void operator()(int x) const
    {
      std::operator&lt;&lt;(std::cout.operator&lt;&lt;(x), '\n');
    }
    
    using retType_7_39 = void (*)(int);
    inline constexpr operator retType_7_39 () const noexcept
    {
      return __invoke;
    };
    
    private: 
    static inline /*constexpr */ void __invoke(int x)
    {
      __lambda_7_39{}.operator()(x);
    }
    
    public: 
    // inline /*constexpr */ __lambda_7_39(__lambda_7_39 &amp;&amp;) noexcept = default;
    // /*constexpr */ __lambda_7_39() = default;
    
  };
  
  std::for_each(v.cbegin(), v.cend(), __lambda_7_39{});
  return 0;
}</code></pre></div></section><section><h3 id="822245526#lambda_2" data-toc="lambda_2#2-Lambdas-in-C-11.md-lambda_2">Lambda 表达式的类型</h3><section><h4 id="822245526#g5pg4n_209" data-toc="g5pg4n_209#2-Lambdas-in-C-11.md-g5pg4n_209">编译器生成闭包类型</h4><ul class="list" id="822245526#g5pg4n_211" start="1"><li class="list-item" id="822245526#g5pg4n_212"><p id="822245526#g5pg4n_214">编译器为每个 Lambda 表达式生成一个唯一的闭包类型(closure type)，无法预测这个类型名。</p></li><li class="list-item" id="822245526#g5pg4n_213"><p id="822245526#g5pg4n_215">因此，需要使用'auto'(或'decltype')来推断类型</p><div class="detached code-block" id="822245526#g5pg4n_216"><pre><code class="language-cpp">auto myLambda = [](int a) -&gt; double { return 2.0 * a; };</code></pre></div></li></ul></section><section><h4 id="822245526#g5pg4n_210" data-toc="g5pg4n_210#2-Lambdas-in-C-11.md-g5pg4n_210">不同的闭包类型</h4><ul class="list" id="822245526#g5pg4n_217" start="1"><li class="list-item" id="822245526#g5pg4n_218"><p id="822245526#g5pg4n_219">即使两个 Lambda 表达式完全相同，它们的类型也是不同的：</p><div class="detached code-block" id="822245526#g5pg4n_220"><pre><code class="language-cpp">auto firstLam = [](int x) { return x * 2; };
auto secondLam = [](int x) { return x * 2; };</code></pre></div><ul class="list" id="822245526#g5pg4n_221" start="1"><li class="list-item" id="822245526#g5pg4n_222"><p id="822245526#g5pg4n_224">编译器必须为每个 Lambda 声明两个独特的未命名类型：</p><div class="detached code-block" id="822245526#g5pg4n_225"><pre><code class="language-cpp">#include &lt;type_traits&gt;
int main(){
    const auto firstLam = [](int x) { return x * 2; };
    const auto secondLam = [](int x) { return x * 2; };
    static_assert(!std::is_same(decltype(firstLam), 
                    decltype(secondType)&gt;::value,
                     &quot;must be different!&quot;);
}</code></pre></div><p id="822245526#g5pg4n_226">在编译器眼中，可知这样两个 Lambda 表达式生成的是两个不同的闭包类型：</p><div class="detached code-block" id="822245526#g5pg4n_227"><pre><code class="language-cpp">#include &lt;type_traits&gt;

int main()
{

  class __lambda_4_25
  {
    public: 
    inline /*constexpr */ int operator()(int x) const
    {
      return x * 2;
    }

    using retType_4_25 = int (*)(int);
    inline constexpr operator retType_4_25 () const noexcept
    {
      return __invoke;
    };

    private: 
    static inline /*constexpr */ int __invoke(int x)
    {
      return __lambda_4_25{}.operator()(x);
    }


    public:
    // /*constexpr */ __lambda_4_25() = default;

  };

  const __lambda_4_25 firstLam = __lambda_4_25{};

  class __lambda_5_27
  {
    public: 
    inline /*constexpr */ int operator()(int x) const
    {
      return x * 2;
    }

    using retType_5_27 = int (*)(int);
    inline constexpr operator retType_5_27 () const noexcept
    {
      return __invoke;
    };

    private: 
    static inline /*constexpr */ int __invoke(int x)
    {
      return __lambda_5_27{}.operator()(x);
    }


    public:
    // /*constexpr */ __lambda_5_27() = default;

  };

  const __lambda_5_27 secondLam = __lambda_5_27{};
  /* PASSED: static_assert(!std::integral_constant&lt;bool, false&gt;::value, &quot;must be different&quot;); */
  return 0;
}</code></pre></div><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="822245526#g5pg4n_229">C++17中的改进：  C++17中可以使用没有消息的'static_assert'和辅助变量模板'is_same_v'：</p><div class="detached code-block" id="822245526#g5pg4n_230"><pre><code class="language-cpp">static_assert(std::is_same_v(double, decltype(func(10))&gt;);</code></pre></div></div>
</blockquote>
</li><li class="list-item" id="822245526#g5pg4n_223"><p id="822245526#g5pg4n_232">使用'std::function'</p><ul class="list" id="822245526#g5pg4n_233" start="1"><li class="list-item" id="822245526#g5pg4n_234"><p id="822245526#g5pg4n_236">尽管不能确切知道 Lambda 的类型，但可以指定 Lambda 的签名，并将其存储在'std::function'中：</p><div class="detached code-block" id="822245526#g5pg4n_237"><pre><code class="language-cpp">/* std::function&lt;返回值类型(接受参数类型)&gt; */
std::function&lt;double(int)&gt; myFunc = [](int a) -&gt; double { return 2.0 * a; };</code></pre></div></li><li class="list-item" id="822245526#g5pg4n_235"><p id="822245526#g5pg4n_238">需要注意的是，'std::function'是一个重量级对象，因为它需要处理所有可调用对象，其内部机制较复杂，涉及类型转换或内存动态分配，现检查其大小：</p><div class="detached code-block" id="822245526#g5pg4n_239"><pre><code class="language-cpp">#include &lt;functional&gt;
#include &lt;iostream&gt;

int main(){
     const auto myLambda = [](int a) noexcept -&gt; double { return 2.0 * a; };

     const std::function&lt;double(int)&gt; myFunc = [](int a) noexcept -&gt; double { return 2.0 * a; };

     std::cout &lt;&lt; &quot;sizeof(myLambda) is &quot; &lt;&lt; sizeof(myLambda) &lt;&lt; '\n';
     std::cout &lt;&lt; &quot;sizeof(myFunc) is &quot; &lt;&lt; sizeof(myFunc) &lt;&lt; '\n';

     return myLambda(10) == myFunc(10);      
}
/* output:
 * sizeof(myLambda) is 1
 * sizeof(myFunc) is 64
 */</code></pre></div><ul class="list" id="822245526#g5pg4n_240" start="1"><li class="list-item" id="822245526#g5pg4n_241"><p>由于'myLambda'只是一个无状态的 Lambda，它也是一个空类，没有任何数据成员字段，所以它的大小只有一个字节。</p></li><li class="list-item" id="822245526#g5pg4n_242"><p>而'std::function'版本要大得多，为64字节(不同的编译器及编译器版本和当前操作系统版本会导致此值不同)，如果可能，依赖&lsquo;auto'推断以获得最小的闭包对象。</p></li></ul></li></ul></li></ul></li></ul></section></section><section><h3 id="822245526#g5pg4n_128" data-toc="g5pg4n_128#2-Lambdas-in-C-11.md-g5pg4n_128">构造函数与复制</h3><ol class="list list-decimal" id="822245526#g5pg4n_243" type="1" start="1"><li class="list-item" id="822245526#g5pg4n_244"><p id="822245526#g5pg4n_249">Lambda 表达式的闭包类型</p><ul class="list" id="822245526#g5pg4n_250" start="1"><li class="list-item" id="822245526#g5pg4n_251"><p>根据C++规范： </p><ul class="list" id="822245526#g5pg4n_252" start="1"><li class="list-item" id="822245526#g5pg4n_253"><p>Lambda 表达式关联的闭包类型有一个被删除的默认构造函数(default constructor)。</p></li><li class="list-item" id="822245526#g5pg4n_254"><p>闭包类型还有一个被删除的复制赋值运算符(copy assignment operator)。</p></li></ul></li></ul></li><li class="list-item" id="822245526#g5pg4n_245"><p id="822245526#g5pg4n_255">不能默认构造和赋值，即进行一般的copying操作 由于默认构造函数和复制赋值运算符被禁用，如下代码进行编译会报错：</p><div class="detached code-block" id="822245526#g5pg4n_256"><pre><code class="language-cpp">auto foo = [&amp;x, &amp;y]() { ++x; ++y; };
decltype(foo) fooCopy;</code></pre></div><p id="822245526#g5pg4n_257">编译结果：</p><div class="detached code-block" id="822245526#g5pg4n_258"><pre><code class="language-none">error: no matching constructor for initialization of 'decltype(foo)'</code></pre></div></li><li class="list-item" id="822245526#g5pg4n_246"><p id="822245526#g5pg4n_260">可以复制 Lambda 虽然不能默认构造和赋值 Lambda，但可以复制 Lambda：</p><div class="detached code-block" id="822245526#g5pg4n_261"><pre><code class="language-cpp">#include &lt;type_traits&gt;

int main(){
    const auto firstLam = [](int x) noexcept { return x * 2; };
    const auto secondLam = firstLam;
    static_assert(std::is_same&lt;decltype&lt;firstLam), decltype(secondLam)&gt;::value, &quot;must be the same!&quot;);
}
/* verify the same type of firstLam and secondLam */</code></pre></div></li><li class="list-item" id="822245526#g5pg4n_247"><p id="822245526#g5pg4n_263">捕获变量的复制 当复制 Lambda 时，其状态也会被复制。这在涉及捕获变量时尤为重要。闭包类型将捕获的变量存储为成员字段，复制 Lambda 会复制这些数据成员字段。</p></li><li class="list-item" id="822245526#g5pg4n_248"><p id="822245526#g5pg4n_265">C++20 的改进 在 C+20 中，无状态的 Lambda 将具有默认构造函数和赋值运算符，使其更加灵活和易用。</p></li></ol></section><section><h3 id="822245526#lambda_3" data-toc="lambda_3#2-Lambdas-in-C-11.md-lambda_3">Lambda 表达式的调用运算符</h3><ol class="list list-decimal" id="822245526#g5pg4n_267" type="1" start="1"><li class="list-item" id="822245526#g5pg4n_268"><p>Lambda 表达式的内部实现 </p><ul class="list" id="822245526#g5pg4n_270" start="1"><li class="list-item" id="822245526#g5pg4n_271"><p>在 Lambda 表达式的函数体中编写的代码，会被编译成对应闭包类型的'operator()'函数中的代码。</p></li></ul></li><li class="list-item" id="822245526#g5pg4n_269"><p>默认行为 </p><ul class="list" id="822245526#g5pg4n_272" start="1"><li class="list-item" id="822245526#g5pg4n_273"><p>在 C++11 中，'operator()'默认是一个'const'的内联成员函数。</p></li><li class="list-item" id="822245526#g5pg4n_274"><p>Lambda 表达式：</p></li><li class="list-item" id="822245526#g5pg4n_275"><div class="detached code-block" id="822245526#g5pg4n_278"><pre><code class="language-cpp">auto lam = [](double param) { /* do something 8*/ };</code></pre></div></li><li class="list-item" id="822245526#g5pg4n_276"><p>编译展开后：</p></li><li class="list-item" id="822245526#g5pg4n_277"><div class="detached code-block" id="822245526#g5pg4n_279"><pre><code class="language-cpp">struct __anonymousLambda{
   inline void operator()(double param) const { /* do something */ }
};</code></pre></div></li></ul></li></ol></section><section><h3 id="822245526#g5pg4n_130" data-toc="g5pg4n_130#2-Lambdas-in-C-11.md-g5pg4n_130">重载</h3><ol class="list list-decimal" id="822245526#g5pg4n_280" type="1" start="1"><li class="list-item" id="822245526#g5pg4n_281"><p>Lambda 表达式不支持重载 </p><ul class="list" id="822245526#g5pg4n_283" start="1"><li class="list-item" id="822245526#g5pg4n_284"><p id="822245526#g5pg4n_286">Lambda 表达式无法定义&quot;重载&quot;版本，无法接受不同的参数类型：</p></li><li class="list-item" id="822245526#g5pg4n_285"><div class="detached code-block" id="822245526#g5pg4n_287"><pre><code class="language-cpp">auto lam = [](double param) { /* do something */ };
auto lam = [](int param) { /* do something */ };</code></pre></div><p id="822245526#g5pg4n_288">上述代码无法通过编译，因为编译器无法将这两个 Lambda 转换为单个functor，而且不能重定义相同的变量。</p></li></ul></li><li class="list-item" id="822245526#g5pg4n_282"><p>使用仿函数实现重载 </p><ul class="list" id="822245526#g5pg4n_289" start="1"><li class="list-item" id="822245526#g5pg4n_290"><p>使用functor实现重载</p></li><li class="list-item" id="822245526#g5pg4n_291"><div class="detached code-block" id="822245526#g5pg4n_293"><pre><code class="language-cpp">struct MyFunctor{
  inline void operator()(double param) const { /* do something */ };
  inline void operator()(int param) const { /* do something */ };
};</code></pre></div></li><li class="list-item" id="822245526#g5pg4n_292"><p>'MyFunctor'现在可以处理'double'和'int'类型的参数。</p></li></ul></li></ol></section><section><h3 id="822245526#lambda_4" data-toc="lambda_4#2-Lambdas-in-C-11.md-lambda_4">Lambda 表达式的修饰符和捕获</h3><section><h4 id="822245526#modifier" data-toc="modifier#2-Lambdas-in-C-11.md-modifier">修饰符(modifier)</h4><ol class="list list-decimal" id="822245526#g5pg4n_310" type="1" start="1"><li class="list-item" id="822245526#g5pg4n_311"><p id="822245526#g5pg4n_313">默认声明：在默认情况下，Lambda 表达式生成的调用运算符('operator()')是'const'内联成员函数。</p></li><li class="list-item" id="822245526#g5pg4n_312"><p id="822245526#g5pg4n_314">其他修饰符：在C++11中，可以使用'mutable'和异常规范('noexcept')来修饰调用运算符：  Lambda 表达式：</p><div class="detached code-block" id="822245526#g5pg4n_315"><pre><code class="language-cpp">auto myLambda = [](int a) mutable noexcept { /* do something */ };</code></pre></div><p id="822245526#g5pg4n_316">编译展开后：</p><div class="detached code-block" id="822245526#g5pg4n_317"><pre><code class="language-cpp">struct __anonymousLambda{
    inline void operator()(int a) noexcept { /* do something */ };
};</code></pre></div></li></ol></section><section><h4 id="822245526#capture" data-toc="capture#2-Lambdas-in-C-11.md-capture">捕获(capture)</h4><ul class="list" id="822245526#g5pg4n_319" start="1"><li class="list-item" id="822245526#g5pg4n_320"><p>捕获子句：'[]'不仅引入 Lambda 表达式，还包含捕获的变量列表，称为&quot;捕获子句&quot;。</p></li><li class="list-item" id="822245526#g5pg4n_321"><p>捕获变量：捕获变量会在闭包类型中作为成员变量(非静态static数据成员)存储，可以在 Lambda 体内访问。</p></li></ul></section><section><h4 id="822245526#g5pg4n_296" data-toc="g5pg4n_296#2-Lambdas-in-C-11.md-g5pg4n_296">捕获方式</h4><ul class="list" id="822245526#g5pg4n_322" start="1"><li class="list-item" id="822245526#g5pg4n_325"><p>'[&amp;]': 按引用捕获所有在作用域中的自动存储变量。</p></li><li class="list-item" id="822245526#g5pg4n_326"><p>'[=]': 按值捕获所有在作用域中的自动存储变量。</p></li><li class="list-item" id="822245526#g5pg4n_327"><p>'[x, &amp;y]': 显式按值捕获'x'和按引用捕获'y'。</p></li><li class="list-item" id="822245526#g5pg4n_328"><p>'[args...]': 按值捕获模板参数包。</p></li><li class="list-item" id="822245526#g5pg4n_329"><p>'[&amp;args...]': 按引用捕获模板参数包。</p></li></ul><p id="822245526#g5pg4n_323">捕获示例：</p><div class="detached code-block" id="822245526#g5pg4n_324"><pre><code class="language-cpp">int x = 2, y = 3;
const auto l1 = []() { return 1; };         // 无捕获
const auto l2 = [=]() { return x; };        // 全部按值捕获
const auto l3 = [&amp;]() { return y; };        // 全部按引用捕获
const auto l4 = [x]() { return x; };        // 仅按值捕获 x
const auto l5 = [&amp;y]() { return y; };       // 仅按引用捕获 y
const auto l6 = [x, &amp;y]() { return x * y; };// x 按值捕获， y 按引用捕获
const auto l7 = [=, &amp;x]() { return x + y; };// 全部按值捕获， x 按引用捕获
const auto l8 = [&amp;, y]() { return x - y; };// 全部按引用捕获， y 按值捕获</code></pre></div></section><section><h4 id="822245526#g5pg4n_297" data-toc="g5pg4n_297#2-Lambdas-in-C-11.md-g5pg4n_297">捕获变量行为</h4><ul class="list" id="822245526#g5pg4n_330" start="1"><li class="list-item" id="822245526#g5pg4n_331"><p>按值捕获：变量在 Lambda 定义时被复制。 </p><ul class="list" id="822245526#g5pg4n_334" start="1"><li class="list-item" id="822245526#g5pg4n_335"><p id="822245526#g5pg4n_337">Lambda 表达式：</p><div class="detached code-block" id="822245526#g5pg4n_338"><pre><code class="language-cpp">std::string str{&quot;Hello Lambda&quot;};
auto foo = [str]() { std::cout &lt;&lt; str &lt;&lt; '\n'; }
foo();</code></pre></div></li><li class="list-item" id="822245526#g5pg4n_336"><p id="822245526#g5pg4n_339">编译展开后：</p><div class="detached code-block" id="822245526#g5pg4n_340"><pre><code class="language-cpp">struct _unnamedLambda{
    _unnamedLambda(std::string s): str(s) { }
    void operator()() const {
        std::cout &lt;&lt; str &lt;&lt; '\n';
    }
    std::string str;
};</code></pre></div></li></ul></li><li class="list-item" id="822245526#g5pg4n_332"><p>按引用捕获：变量在 Lambda 调用时使用当前值。 </p><ul class="list" id="822245526#g5pg4n_341" start="1"><li class="list-item" id="822245526#g5pg4n_342"><p id="822245526#g5pg4n_344">Lambda 表达式</p><div class="detached code-block" id="822245526#g5pg4n_345"><pre><code class="language-cpp">int x, y = 1;
const auto foo = [&amp;x, &amp;y]() noexcept { ++x; ++y; };
foo()</code></pre></div></li><li class="list-item" id="822245526#g5pg4n_343"><p id="822245526#g5pg4n_346">编译展开后：</p><div class="detached code-block" id="822245526#g5pg4n_347"><pre><code class="language-cpp">struct _unnamedLambda{
  _unnamedLambda(int&amp; a, int&amp; b): x(a), y(b) { }
  void operator()() const noexcept{
      ++x; ++y;
  }
  int&amp; x;
  int&amp; y;
};</code></pre></div></li></ul></li><li class="list-item" id="822245526#g5pg4n_333"><p>注意事项： </p><ul class="list" id="822245526#g5pg4n_348" start="1"><li class="list-item" id="822245526#g5pg4n_349"><p>捕获模式：虽然'[=]'或'[&amp;]'捕获所有变量很方便，但显式捕获变量更安全，避免意外副作用。</p></li><li class="list-item" id="822245526#g5pg4n_350"><p>生命周期：C++ 闭包不会延长捕获引用的生命周期，确保在 Lambda 调用时捕获的变量仍然存在。</p></li></ul></li></ul></section><section><h4 id="822245526#mutable" data-toc="mutable#2-Lambdas-in-C-11.md-mutable">mutable 关键字</h4><p id="822245526#g5pg4n_351">在默认情况下，Lambda 表达式的闭包类型的'operator()'被标记为'const'，因此不能在 Lambda 体内修改捕获的变量。 但如果要改变这种行为，就需要在参数列表后添加'mutable&lsquo;关键字，这种用法实际上从闭包类型的调用操作符声明中移除了'const'： Lambda 表达式：</p><div class="detached code-block" id="822245526#g5pg4n_352"><pre><code class="language-cpp">int x = 1;
auto foo = [x]() mutable { ++x; };</code></pre></div><p id="822245526#g5pg4n_353">编译展开：</p><div class="detached code-block" id="822245526#g5pg4n_354"><pre><code class="language-cpp">struct __lambda_x1{
    void operator()(){ ++x; }
    int x;
};</code></pre></div></section><section><h4 id="822245526#mutable_1" data-toc="mutable_1#2-Lambdas-in-C-11.md-mutable_1">使用 mutable 拷贝捕获两个变量</h4><div class="detached code-block" id="822245526#g5pg4n_355"><pre><code class="language-cpp">#include &lt;iostream&gt;

int main(){
    const auto print = [](const char* str, int x, int y){
        std::cout &lt;&lt; str &lt;&lt; &quot;: &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; '\n';
    };
    
    int x = 1, y = 1;
    print(&quot;in main()&quot;, x, y);
    
    auto foo = [x, y, &amp;print]() mutable {
        ++x;
        ++y;
        print(&quot;in foo()&quot;, x, y);
    };
    
    foo();
    print(&quot;in main()&quot;, x, y);
}
/* output:
 * in main(): 1 1
 * in foo(): 2 2
 * in main(): 1 1
 */</code></pre></div><p id="822245526#g5pg4n_356">上述代码中，Lambda 表达式通过拷贝捕获了'x'和'y'，并通过引用捕获了'print'。 在'foo'内部，'x'和'y'的值被修改，但这些修改并不影响外部作用域中的原始变量'x'和'y'。</p><section><h5 id="822245526#g5pg4n_357" data-toc="g5pg4n_357#2-Lambdas-in-C-11.md-g5pg4n_357">通过引用捕获变量</h5><p id="822245526#g5pg4n_359">当通过引用捕获时，Lambda可以在不使用'mutable'的情况下修改引用的值：</p><div class="detached code-block" id="822245526#g5pg4n_360"><pre><code class="language-cpp">int x = 1;
std::cout &lt;&lt; x &lt;&lt; '\n';
const auto foo = [&amp;x]() noexcept { ++x; };
foo();
std::cout &lt;&lt; x &lt;&lt; '\n';

/* output:
 * 1
 * 2
 */</code></pre></div></section><section><h5 id="822245526#mutable-const" data-toc="mutable-const#2-Lambdas-in-C-11.md-mutable-const">关于 mutable 和 const</h5><p id="822245526#g5pg4n_361">使用'mutable'时，不能将生成的闭包对象标记为'const'，因为这会阻止调用 Lambda：</p><div class="detached code-block" id="822245526#g5pg4n_362"><pre><code class="language-cpp">int x = 10;
const auto lam = [x]() mutable { ++x; };
// lam(); 将导致编译出错</code></pre></div><p id="822245526#g5pg4n_363">导致编译出错的原因是不能在'const'对象上调用非'const'成员函数。</p></section></section><section><h4 id="822245526#g5pg4n_300" data-toc="g5pg4n_300#2-Lambdas-in-C-11.md-g5pg4n_300">捕获变量的实例-调用计数器</h4><p id="822245526#g5pg4n_364">例子背景： Lambda 表达式在需要使用标准库中的算法并改变其默认行为时很有用。在'std::sort'中，通常可以自定义比较函数， 现在，可以在其中引入一个计数器来增强比较器的功能。 代码示例：</p><div class="detached code-block" id="822245526#g5pg4n_365"><pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main(){
    std::vector&lt;int&gt; vec = {0, 5, 2, 9, 7, 6, 1, 3, 4, 8};
    size_t compCounter = 0;
    
    std::sort(vec.begin(), vec.end(), [&amp;compCounter](){
        ++compCounter;
        return a &lt; b;
    });
    
    std::cout &lt;&lt; &quot;Number of comparisons: &quot; &lt;&lt; compCounter &lt;&lt; '\n';
    for(const auto&amp; v: vec) std::cout &lt;&lt; v &lt;&lt; ',';
}
/* output:
 * Number of comparisons: 54
 * 0,1,2,3,4,5,6,7,8,9,
 */</code></pre></div></section><section><h4 id="822245526#g5pg4n_301" data-toc="g5pg4n_301#2-Lambdas-in-C-11.md-g5pg4n_301">捕获全局变量</h4><p id="822245526#g5pg4n_366">在 Lambda 表达式中使用'[=]'按值捕获所有变量，但对于全局变量而言，并不如此：</p><div class="detached code-block" id="822245526#g5pg4n_367"><pre><code class="language-cpp">#include &lt;iostream&gt;

int global = 10;

int main(){
    std::cout &lt;&lt; global &lt;&lt; '\n';
    
    auto foo [=]() mutable noexcept { ++global; };
    foo();
    std::cout &lt;&lt; global &lt;&lt; '\n';
    
    const auto increaseGlobal = []() noexcept { ++global; };
    increaseGlobal();
    std::cout &lt;&lt; global &lt;&lt; '\n';
    
 /* compile error
  * const auto moreIncreaseGlobal = [global]() noexcept { ++global; };
  * moreIncreaseGlobal();
  * std::cout &lt;&lt; global &lt;&lt; '\n';
  */
}
/* output:
 * 10
 * 11
 * 12
 */</code></pre></div><p id="822245526#g5pg4n_368">无论使用什么方式捕获，Lambda 表达式始终引用全局对象，而不会创建局部副本。  最后一个moreIncreaseGlobal()使用Clang会编译失败，说明不能捕获全局变量。</p></section><section><h4 id="822245526#g5pg4n_302" data-toc="g5pg4n_302#2-Lambdas-in-C-11.md-g5pg4n_302">捕获静态变量</h4><p id="822245526#g5pg4n_370">与捕获全局变量类似，捕获静态对象时也会遇到同样的问题：</p><div class="detached code-block" id="822245526#g5pg4n_371"><pre><code class="language-cpp">#include &lt;iostream&gt;

void bar(){
    static int static_int = 10;
    std::cout &lt;&lt; static_int &lt;&lt; '\n';
    
    auto foo = [=]() mutable noexcept { ++static_int; };
    foo();
    std::cout &lt;&lt; static_int &lt;&lt; '\n';
    
    const auto increase = []() noexcept { ++static_int; };
    increase();
    std::cout &lt;&lt; static_int &lt;&lt; '\n';
    
 /* compile error
  * const auto moreIncrease = [static_int]() { ++static_int; };
  * moreIncrease();
  * std::cout &lt;&lt; static_int &lt;&lt; '\n';
  */
}
/* output:
 * 10
 * 11
 * 12
 */</code></pre></div><p id="822245526#g5pg4n_372">与全局变量相同，静态变量不能按值捕获，使用Clang进行编译会报错，因为不能捕获具有非自动存储持续时间的变量。</p></section><section><h4 id="822245526#this" data-toc="this#2-Lambdas-in-C-11.md-this">捕获类成员变量和'this'指针</h4><p id="822245526#g5pg4n_374">在类成员函数中捕获成员变量会更加复杂，因为所有数据成员都与'this'指针相关联。  一个错误示例：</p><div class="detached code-block" id="822245526#g5pg4n_375"><pre><code class="language-cpp">#include &lt;iostream&gt;

struct Baz{
    void foo(){
        const auto lam = [s]() { std::cout &lt;&lt; s; };
        lam();
    }
    std::string s;
};

int main(){
    Baz b;
    b.foo();
}</code></pre></div><p id="822245526#g5pg4n_376">错误原因：不能捕获'Baz::s'并且'this'指针没有捕获。</p><div class="detached code-block" id="822245526#g5pg4n_377"><pre><code class="language-cpp">struct Baz{
    void foo(){
        const auto lam = [this]() { std::cout &lt;&lt; s; };
        lam();
    };
    std::string s;
};</code></pre></div><p id="822245526#g5pg4n_378">通过使用&lsquo;this'指针，可以捕获成员变量。</p></section><section><h4 id="822245526#lambda_5" data-toc="lambda_5#2-Lambdas-in-C-11.md-lambda_5">从方法返回 Lambda</h4><div class="detached code-block" id="822245526#g5pg4n_381"><pre><code class="language-cpp">#include &lt;iostream&gt;

struct Baz{
    std::function&lt;void()&gt; foo(){
        return [=, this] { std::cout &lt;&lt; s &lt;&lt; '\n'; }
    }
    std::string s;
};

int main(){
    auto f1 = Baz{&quot;abc&quot;}.foo(); /* temporary object */
    auto f2 = Baz{&quot;xyz&quot;}.foo(); /* temporary object */
    f1();
    f2();
    Baz b(&quot;ex&quot;);
    auto func = b.foo();
    func();
}
/* output:
 *
 *
 * ex
 */</code></pre></div><p id="822245526#g5pg4n_382">'foo()'方法返回一个 Lambda ，该 Lambda 捕获类的成员变量。 <span id="822245526#g5pg4n_388"><span style="text-decoration:line-through">以下类似</span></span>：</p><div class="detached code-block" id="822245526#g5pg4n_383"><pre><code class="language-cpp">struct Bar{
    std::string const&amp; foo() const { return s; };
    std::string s;
};

auto&amp;&amp; f1 = Bar{&quot;abc&quot;}.foo();   // dangling reference</code></pre></div><p id="822245526#g5pg4n_384"><span id="822245526#g5pg4n_389"><span style="text-decoration:line-through">或者</span></span>：</p><div class="detached code-block" id="822245526#g5pg4n_385"><pre><code class="language-cpp">std::function&lt;void()&gt; foo(){
    return[s] { std::cout &lt;&lt; s &lt;&lt; '\n'; };
}</code></pre></div><p id="822245526#g5pg4n_386">上面的代码中'f1'和'f2&lsquo;使用的都是临时对象，可能会出现空悬引用(dangling reference)的问题，导致未定义行为。  捕获'this'在 Lambda 的生命周期可能超过对象本事时可能会出现其他问题，特别是在异步调用(async)和多线程(multithreading)中。</p></section><section><h4 id="822245526#moveable-only-object" data-toc="moveable-only-object#2-Lambdas-in-C-11.md-moveable-only-object">只能移动对象(moveable-only object)</h4><p id="822245526#g5pg4n_391">对于一个只能移动的对象(例如&lsquo;unique_ptr&rsquo;)，那么不能将其作为捕获变量按值捕获到 Lambda 表达式中，只能够按引用捕获，但是这并不会转移对象的所有权：</p><div class="detached code-block" id="822245526#g5pg4n_392"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

int main(){
    std::unique_ptr&lt;int&gt; p(new int{10});
    
    // 按值捕获 - 编译错误
    // auto foo = [p]() {};
    
    // 按引用捕获 - 可通过编译，但不转移所有权
    auto foo_ref = [&amp;p]() { std::cout &lt;&lt; *p &lt;&lt; '\n'; };
    foo_ref();
}
/* output:
 * 10
 */</code></pre></div><p id="822245526#g5pg4n_393">在上面这种情况中，捕获'std::unique_ptr'的唯一方法时按引用捕获，然后，这种方法不能转移指针的所有权。  解决方法：使用 C++14 中的初始化捕获：通过初始化捕获，可以在 Lambda 表达式中捕获一个移动的对象，从而转移其所有权。</p><div class="detached code-block" id="822245526#g5pg4n_394"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

int main(){
    std::unique_ptr&lt;int&gt; p(new int{10});
    
    // 使用初始化捕获 - 转移所有权
    auto foo = [p = std::move(p)](){
        std::cout &lt;&lt; *p &lt;&lt; '\n';
    };
    
    foo();
    
    if(!p) std::cout &lt;&lt; &quot;p is nullptr after being moved&quot; &lt;&lt; '\n';
}
/* output:
 * 10
 * p is nullptr after being moved
 */</code></pre></div></section><section><h4 id="822245526#const-preserving" data-toc="const-preserving#2-Lambdas-in-C-11.md-const-preserving">保持常量性(const preserving)</h4><p id="822245526#g5pg4n_396">如果捕获了一个常量变量，其常量性会被保留：</p><div class="detached code-block" id="822245526#g5pg4n_397"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;type_traits&gt;

int main(){
    const int x = 10;
    auto foo = [x]() mutable{
        std::cout &lt;&lt; std::is_const&lt;decltype(x)&gt;::value &lt;&lt; '\n';
        // x = 11; 编译错误
    }
    foo();
}
/* output:
 * 1
 */</code></pre></div><p id="822245526#g5pg4n_398">由上面的代码可知，即使在 Lambda 表达式中使用 'mutable' 关键字，'x'的常量性依然保留，不能被修改。</p></section><section><h4 id="822245526#g5pg4n_307" data-toc="g5pg4n_307#2-Lambdas-in-C-11.md-g5pg4n_307">参数包捕获</h4><p id="822245526#g5pg4n_399">在捕获子句中，也可以利用可变参数模板(variadic templates)来捕获参数包：</p><div class="detached code-block" id="822245526#g5pg4n_400"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;tuple&gt;

template&lt;class... args&gt;
void captureTest(Args... args){
    const auto lambda = [args...]{
        const auto tup = std::make_tuple(args...);
        std::cout &lt;&lt; &quot;tuple size: &quot; &lt;&lt; std::tuple_size&lt;decltype(tup)&gt;::value &lt;&lt; '\n';
        std::cout &lt;&lt; &quot;tuple 1st: &quot; &lt;&lt; std::get&lt;0&gt;(tup) &lt;&lt; '\n';
    };
    lambda();
}

int main(){
    captureTest(1, 2, 3, 4);
    captureTest(&quot;Hello Lambda&quot;, 10.0f);
}
/* output:
 * tuple size: 4
 * tuple 1st: 1
 * tuple size: 2
 * tuple 1st: Hello Lambda</code></pre></div><p id="822245526#g5pg4n_401">编译展开：</p><div class="detached code-block" id="822245526#g5pg4n_402"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;tuple&gt;

template&lt;class ... Args&gt;
void captureTest(Args... args)
{
    
  class __lambda_6_22
  {
    public: 
    inline auto operator()() const
    {
      const auto tup = std::make_tuple(args... );
      (std::operator&lt;&lt;(std::cout, &quot;tuple size:  &quot;) &lt;&lt; std::tuple_size&lt;decltype(tup)&gt;::value) &lt;&lt; '\n';
      (std::operator&lt;&lt;(std::cout, &quot;tuple 1st: &quot;) &lt;&lt; std::get&lt;0&gt;(tup)) &lt;&lt; '\n';
    }
    
    private: 
    Args... args;
    
    public:
    __lambda_6_22(const type_parameter_0_0... &amp; _args)
    : args{_args...}
    {}
    
  };
  
  const auto lambda = __lambda_6_22{args};
  lambda();
}

/* First instantiated from: insights.cpp:15 */
#ifdef INSIGHTS_USE_TEMPLATE
template&lt;&gt;
void captureTest&lt;int, int, int, int&gt;(int __args0, int __args1, int __args2, int __args3)
{
    
  class __lambda_6_22
  {
    public: 
    inline /*constexpr */ void operator()() const
    {
      const std::tuple&lt;int, int, int, int&gt; tup = std::make_tuple(__args0, __args1, __args2, __args3);
      std::operator&lt;&lt;(std::operator&lt;&lt;(std::cout, &quot;tuple size:  &quot;).operator&lt;&lt;(std::integral_constant&lt;unsigned long, 4&gt;::value), '\n');
      std::operator&lt;&lt;(std::operator&lt;&lt;(std::cout, &quot;tuple 1st: &quot;).operator&lt;&lt;(std::get&lt;0&gt;(tup)), '\n');
    }
    
    private: 
    int __args0;
    int __args1;
    int __args2;
    int __args3;
    
    public:
    __lambda_6_22(int &amp; ___args0, int &amp; ___args1, int &amp; ___args2, int &amp; ___args3)
    : __args0{___args0}
    , __args1{___args1}
    , __args2{___args2}
    , __args3{___args3}
    {}
    
  };
  
  const __lambda_6_22 lambda = __lambda_6_22{__args0, __args1, __args2, __args3};
  lambda.operator()();
}
#endif


/* First instantiated from: insights.cpp:16 */
#ifdef INSIGHTS_USE_TEMPLATE
template&lt;&gt;
void captureTest&lt;const char *, float&gt;(const char * __args0, float __args1)
{
    
  class __lambda_6_22
  {
    public: 
    inline /*constexpr */ void operator()() const
    {
      const std::tuple&lt;const char *, float&gt; tup = std::make_tuple(__args0, __args1);
      std::operator&lt;&lt;(std::operator&lt;&lt;(std::cout, &quot;tuple size:  &quot;).operator&lt;&lt;(std::integral_constant&lt;unsigned long, 2&gt;::value), '\n');
      std::operator&lt;&lt;(std::operator&lt;&lt;(std::operator&lt;&lt;(std::cout, &quot;tuple 1st: &quot;), std::get&lt;0&gt;(tup)), '\n');
    }
    
    private: 
    const char * __args0;
    float __args1;
    
    public:
    __lambda_6_22(const char * ___args0, float &amp; ___args1)
    : __args0{___args0}
    , __args1{___args1}
    {}
    
  };
  
  const __lambda_6_22 lambda = __lambda_6_22{__args0, __args1};
  lambda.operator()();
}
#endif

int main()
{
  captureTest(1, 2, 3, 4);
  captureTest(&quot;Hello Lambda&quot;, 10.0F);
  return 0;
}</code></pre></div><p id="822245526#g5pg4n_403">可以通过可变参数模板在 Lambda 表达式中捕获参数包，捕获的参数包可以存储在'tuple'对象中，便于访问和操作。</p></section><section><h4 id="822245526#g5pg4n_308" data-toc="g5pg4n_308#2-Lambdas-in-C-11.md-g5pg4n_308">返回类型推断</h4><p id="822245526#g5pg4n_404">在很多情况下，可以省略 Lambda 表达式的返回类型，从 C++11 开始，编译器能够推断返回类型，只要所有的 return 语句返回的表达式类型相同：</p><div class="detached code-block" id="822245526#g5pg4n_405"><pre><code class="language-cpp">#include &lt;type_traits&gt;

int main(){
    const auto baz = [](int x) noexcept{
        if(x &lt; 20) return x * 1.1;  // return double
        else return x * 2.1;        // return double
    };
    static_assert(std::is_same(dobule, decltype(baz(10))&gt;::value, &quot;has to be the same);
}</code></pre></div><p id="822245526#g5pg4n_406">在上面的 Lambda 表达式中，两个返回语句的返回类型都为 double，因此编译器可以推断出返回类型。</p></section><section><h4 id="822245526#g5pg4n_309" data-toc="g5pg4n_309#2-Lambdas-in-C-11.md-g5pg4n_309">尾置返回类型语法</h4><p id="822245526#g5pg4n_407">使用尾置返回类型语法可以显式地指定返回类型：</p><div class="detached code-block" id="822245526#g5pg4n_408"><pre><code class="language-cpp">#include &lt;iostream&gt;

int main(){
    const auto testSpeedString = [](int speed) noexcept{
        if(speed &gt; 100) return &quot;you're a super fast&quot;;
        else return &quot;you're a regular&quot;;
    };
    auto str = testSpeedString(100);
    str += &quot; driver&quot;;
    std::cout &lt;&lt; str;
}</code></pre></div><p id="822245526#g5pg4n_409">上述代码会出现编译错误，因为 const char* 没有 += 操作符，调整后：</p><div class="detached code-block" id="822245526#g5pg4n_410"><pre><code class="language-cpp">auto testSpeedString = [](int speed) -&gt; std::string {
        if(speed &gt; 100) return &quot;you're a super fast&quot;;
        else return &quot;you're a regular&quot;;
    };
    auto str = testSpeedString(100);
    str += &quot; driver&quot;;
/* output:
 * you're a regular driver
 */</code></pre></div><p id="822245526#g5pg4n_411">注意，此处在显式设置了返回类型为'std::string'后，需要移除'noexcept'，因为创建了'std::string'可能会抛出异常。  或者使用'std::string_literals'，然后返回'&quot;you're a regular&quot;s'来表示'std::string'类型。</p><p id="822245526#g5pg4n_412">此处也可实现一个'std::string'的继承类speedString，并实现operator+=的重载：</p><div class="detached code-block" id="822245526#g5pg4n_413"><pre><code class="language-cpp">#include &lt;iostream&gt;

class speedString: public std::string{
public:
    using std::string::string;  // 继承 std::string 的构造函数
    
    speedString&amp; operator+=(const std::string&amp; rhs){
        std::string::operator+=(rhs);
        return *this;
    }
    
    // 重载 operator+= 以支持 const char* 类型
    speedString&amp; operator+=(const char* rhs){
        std::string::operator+=(rhs);
        return *this;
    }
};

int main(){
    const auto testSpeedString = [](int speed) noexcept -&gt; speedString{
        if(speed &gt; 100) return &quot;you're a super fase&quot;;
        else return &quot;you're a regular&quot;;
    };
    
    speedString str = testSpeedString(100);
    str += &quot; driver&quot;;
    std::cout &lt; str;
}
/* output:
 * you're a regular driver
 */</code></pre></div></section></section><section><h3 id="822245526#conversion-function-pointer" data-toc="conversion-function-pointer#2-Lambdas-in-C-11.md-conversion-function-pointer">函数指针转换(Conversion Function Pointer)</h3><p id="822245526#g5pg4n_415">如果 Lambda 表达式没有捕获任何变量，编译器可以将其转换为常规函数指针，标准中描述如下：</p><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="822245526#g5pg4n_424">对于没有捕获的 Lambda 表达式，其闭包类型具有一个公共的、非虚的、非显式的 const 转换函数， 该函数转化为为具有与闭包类型的函数调用运算符相同参数和返回类型的函数指针。该转换函数返回的值应该是一个函数的地址， 当调用该函数时，其效果与调用闭包类型的函数调用运算符相同。</p></div>
</blockquote>
<p id="822245526#g5pg4n_417">例如：</p><div class="detached code-block" id="822245526#g5pg4n_418"><pre><code class="language-cpp">#include &lt;iostream&gt;
void callWith10(void (*bar)(int)){
    bar(10);
}

int main(){
    struct{
        using f_ptr = void(*)(int);
        void operator()(int s) const { return call(s); }
        operator f_ptr() const { return &amp;call; }
    private:
        static void call(int s) { std::cout &lt;&lt; s &lt;&lt; '\n'; };
    } baz;
    
    callWith10(baz);
    callWith10([](int x) { std::cout &lt;&lt; x &lt;&lt; '\n'; };
}</code></pre></div><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="822245526#g5pg4n_425">解释：</p><ol class="list list-decimal" id="822245526#g5pg4n_426" type="1" start="1"><li class="list-item" id="822245526#g5pg4n_427"><p>'callWith10()'：'void(*bar)(int)'是一个函数指针，指向返回为类型为'void',参数类型为'int'的函数，'callWith10()'这个函数接受一个这样的函数指针作为参数，然后调用该函数并传入参数&lsquo;10&rsquo;。</p></li><li class="list-item" id="822245526#g5pg4n_428"><p>'using f_ptr = void(*)(int)(等价于 typedef void(*f_ptr)(int));'定义了一个函数指针类型'f_ptr'。</p></li><li class="list-item" id="822245526#g5pg4n_429"><p>'void operator()(int s) const { return call(s); }'重载了'operator()'，使得对象'baz'对象可以像函数一样被调用，并且会调用私有的静态成员函数'call'。</p></li><li class="list-item" id="822245526#g5pg4n_430"><p>'operator f_ptr() const { return &amp; call; }'定义了从结构体类型到函数指针类型的隐式转换操作符，也就是说，这个结构体实例'baz'可以被隐式转换为指向静态成员函数'call'的函数指针。</p></li></ol></div>
</blockquote>
<p id="822245526#g5pg4n_420">示例：使用Lambda 调用C库中的'std::qsort'进行反向排序：</p><div class="detached code-block" id="822245526#g5pg4n_421"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdlib&gt;

int main(){
    int values[] = {8, 9, 2, 5, 1, 4, 7, 3, 6};
    constexpr size_t numElements = sizeof(values) / sizeof(values[0]);
    
    std::qsort(values, numElements, sizeof(int), 
                [](const void* a, const void* b) noexcept {
        return (*(int*)b - *(int*)a);
    }
    );
    
    for(const auto&amp; val: values) std::cout &lt;&lt; val &lt;&lt; &quot;, &quot;;
}
/* output:
 * 9, 8, 7, 6, 5, 4, 3, 2, 1
 */</code></pre></div><p id="822245526#g5pg4n_422">上面的代码中，'std::qsort'只接受函数指针作为比较器，编译器可以隐式地将传递地无状态 Lambda 表达式转换为函数指针。</p><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="822245526#g5pg4n_431">总结：</p><ol class="list list-decimal" id="822245526#g5pg4n_432" type="1" start="1"><li class="list-item" id="822245526#g5pg4n_433"><p>无捕获 Lambda 转换为函数指针： </p><ul class="list" id="822245526#g5pg4n_435" start="1"><li class="list-item" id="822245526#g5pg4n_436"><p>无捕获地 Lambda 表达式可以转换为与其函数调用运算符具有相同参数和返回类型地函数指针。</p></li><li class="list-item" id="822245526#g5pg4n_437"><p>这种转换由编译器自动完成，方便在需要C风格回调地情况下使用。</p></li></ul></li><li class="list-item" id="822245526#g5pg4n_434"><p>仿函数(functor)显式转换： </p><ul class="list" id="822245526#g5pg4n_438" start="1"><li class="list-item" id="822245526#g5pg4n_439"><p>通过定义一个转换操作符，仿函数可以显式地转换为函数指针。</p></li><li class="list-item" id="822245526#g5pg4n_440"><p>这在需要传递复杂对象(如仿函数)到需要函数指针地接口时非常有用。</p></li></ul></li></ol></div>
</blockquote>
</section><section><h3 id="822245526#g5pg4n_133" data-toc="g5pg4n_133#2-Lambdas-in-C-11.md-g5pg4n_133">一个棘手的案例</h3><p id="822245526#g5pg4n_441">案例如下：</p><div class="detached code-block" id="822245526#g5pg4n_442"><pre><code class="language-cpp">#include &lt;type_traits&gt;

int main(){
    auto funcPtr = +[]{};
    static_assert(std::is_same(decltype(funcPtr), void(*)()&gt;::value);
}</code></pre></div><p id="822245526#g5pg4n_443">编译展开：</p><div class="detached code-block" id="822245526#g5pg4n_444"><pre><code class="language-cpp">#include &lt;type_traits&gt;

int main()
{
      
  class __lambda_8_19
  {
    public: 
    inline /*constexpr */ void operator()() const
    {
    }
    
    using retType_8_19 = auto (*)() -&gt; void;
    inline constexpr operator retType_8_19 () const noexcept
    {
      return __invoke;
    }
    
    private: 
    static inline /*constexpr */ void __invoke()
    {
      __lambda_8_19{}.operator()();
    }
    
    
    public:
    // /*constexpr */ __lambda_8_19() = default;
    
  };
  
  using FuncPtr_8 = auto (*)() -&gt; void;
  FuncPtr_8 funcPtr = +__lambda_8_19{}.operator __lambda_8_19::retType_8_19();
  /* PASSED: static_assert(std::integral_constant&lt;bool, true&gt;::value); */
  return 0;
}</code></pre></div><p id="822245526#g5pg4n_445">源代码使用了'+'，这是一个一元运算符，这个运算符可以用于指针，因此编译器将无状态的 Lambda 转换为函数指针，然后赋值给'funcPtr'， 相反，如果没有一元运算符'+'，'funcPtr'就只是一个常规的闭包对象，同时'static_assert'也会失效。</p><p id="822245526#g5pg4n_446">在这种情况下，一元操作符'+'和'static_cast&lsquo;的作用效果相同，如果不希望编译器创建太多函数实例化时，可以进行如下操作：</p><div class="detached code-block" id="822245526#g5pg4n_447"><pre><code class="language-cpp">template&lt;typename F&gt;
void call_function(F f){
    f(10);
}

int main(){
    call_function(static_cast&lt;int(*)(int)&gt;([](int x) {
        return x + 2;
    }));
    call_function(static_cast&lt;int(*)(int)&gt;([](int x) {
        return x * 2;
    }));
}</code></pre></div><p id="822245526#g5pg4n_448">在上面的代码中，编译器只需要创建一个'call_function'的实例，因为它只接受一个函数指针'int(*)(int)'，如果去掉了'static_cast'，那么编译器就会为每个 Lambda 创建两个不同类型的'call_function'实例。</p></section><section><h3 id="822245526#iief-immediately-invoked-expression-function" data-toc="iief-immediately-invoked-expression-function#2-Lambdas-in-C-11.md-iief-immediately-invoked-expression-function">IIEF(Immediately Invoked Expression Function) - 立即调用的函数表达式</h3><p id="822245526#g5pg4n_449">直接调用 Lambda 表达式示例：</p><div class="detached code-block" id="822245526#g5pg4n_450"><pre><code class="language-cpp">#include &lt;iostream&gt;

int main(){
    int x = 1, y = 1;
    [&amp;]() noexcept { ++x; ++y; }();
    std::cout &lt;&lt; x &lt;&lt; ',' &lt;&lt; y;
}
/* output:
 * 2, 2
 */</code></pre></div><p id="822245526#g5pg4n_451">此时， Lambda 表达式创建后没有分配给任何闭包对象，而是直接通过'()'调用。</p><p id="822245526#g5pg4n_452">这样的 Lambda 表达式，在初始化一个复杂的'const'对象时比较有用。</p><div class="detached code-block" id="822245526#g5pg4n_453"><pre><code class="language-cpp">const auto val = [](){
/* do something */
}();</code></pre></div><p id="822245526#g5pg4n_454">此时，'val'是一个由 Lambda 表达式返回的类型常量值：</p><div class="detached code-block" id="822245526#g5pg4n_455"><pre><code class="language-cpp">/* val1 是 int */
const auto val1 = []() { return 10; }();
/* val2 是 std::string */
const auto val2 = []() -&gt; std::string { return &quot;ABC&quot;; }();</code></pre></div><p id="822245526#g5pg4n_456">一个更具体的示例： 使用IIFE作为助手 Lambda 来在函数内部创建一个常量值&mdash;&mdash;IIFE 与 HTML 生成示例：</p><div class="detached code-block" id="822245526#g5pg4n_457"><pre><code class="language-cpp">#include &lt;iostream&gt;

void Valiate(const std::string&amp;) {}

std::string BuildHred(const std::string&amp; link, 
                        const std::string&amp; text){
    const std::string html = [&amp;link, &amp;text] {
        const std::string inText = text.empty() ? link : text;
        return &quot;&lt;a href=\&quot;&quot; + link + &quot;\&quot;&gt;&quot; + inText + &quot;&lt;/a&gt;&quot;;
    }();
    Validate(html);
    return html;
}

int main(){
    try{
        const auto ahref = BuildHref(&quot;ppqwqqq.space&quot;, &quot;ppQwQqq&quot;);
        std::cout &lt;&lt; ahref;
    }
    catch (...) {
        std::cout &lt;&lt; &quot;bad format...&quot;;
    }
}</code></pre></div><p id="822245526#g5pg4n_458">上面的代码中，'BuildHref'函数，接受两个参数，然后生成一个<span class="inline-code" id="822245526#g5pg4n_459">'&lt;a&gt;&lt;/a&gt;'</span>HTML标签， 基于输入参数，构建'html&lsquo;变量，如果'text'不为空，则将其用作内部HTML值，否则使用'link'。 通过使用 IIEF 可以在对多输入参数的条件下使表达式更加简洁：编写一个独立的 Lambda 表达式， 然后将其变量标记为'const'，之后即可将'const'变量传递给'ValidateHTML'。</p></section><section><h3 id="822245526#iief" data-toc="iief#2-Lambdas-in-C-11.md-iief">提高 IIEF 代码可读性的方法</h3><ol class="list list-decimal" id="822245526#g5pg4n_460" type="1" start="1"><li class="list-item" id="822245526#g5pg4n_461"><p>避免使用'auto' </p><ul class="list" id="822245526#g5pg4n_463" start="1"><li class="list-item" id="822245526#g5pg4n_464"><p>明确地指定类型，以便更清楚地看到变量的类型：</p></li><li class="list-item" id="822245526#g5pg4n_465"><div class="detached code-block" id="822245526#g5pg4n_466"><pre><code class="language-cpp">const bool EnableErrorReporting = [&amp;]() {
    if(HighLevelWarningEnabled()) return true;
    if(HighLevelWarningEnabled()) return UsersWantReporting();
    return false;
}();</code></pre></div></li></ul></li><li class="list-item" id="822245526#g5pg4n_462"><p>添加注释： </p><ul class="list" id="822245526#g5pg4n_467" start="1"><li class="list-item" id="822245526#g5pg4n_468"><p>在'}'后面添加一个注释，指明这是&lsquo;IIEF'： </p><ul class="list" id="822245526#g5pg4n_469" start="1"><li class="list-item" id="822245526#g5pg4n_470"><div class="detached code-block" id="822245526#g5pg4n_471"><pre><code class="language-cpp">const bool EnableErrorReporting = [&amp;]() {
    if (HighLevelWarningEnabled()) return true;
    if (HighLevelWarningEnabled()) return UserWantReporting();
    return false;
}();    // call it now</code></pre></div></li></ul></li></ul></li></ol></section><section><h3 id="822245526#Lambda_7" data-toc="Lambda_7#2-Lambdas-in-C-11.md-Lambda_7">Lambda 表达式的继承与多态</h3><p id="822245526#g5pg4n_472">Lambda 表达式的继承： 由于编译器会将 Lambda 表达式展开为带有'operator()'的仿函数对象，因此可以从这种类型继承：</p><div class="detached code-block" id="822245526#g5pg4n_473"><pre><code class="language-cpp">#include &lt;iostream&gt;

template&lt;typename Callable&gt;
class ComplexFunctor: public Callable{
public: explicit ComplexFunctor(Callable f): Callable(f) { }
}

template&lt;typename Callable&gt;
ComplexFunctor&lt;Callable&gt; MakeComplexFunctor(Callable&amp;&amp; cal){
    return ComplexFunctor&lt;Callable&gt;(cal);
}

int main(){
    const auto func = MakeComplexFunctor([]() {
        std::cout &lt;&lt; &quot;Hello Functor\n&quot;;
    });
    func();
}</code></pre></div><p id="822245526#g5pg4n_474">在这个例子中，'ComplexFunctor'类从模板参数'Callable'继承，如果想从 Lambda 继承， 必须添加一些额外的操作，因为无法明确知道闭包类型的确切类型(除非将其封装在'std::function'中)， 因此需要'MakeComplexFunctor'函数来执行模板参数推导并获取 Lambda 闭包类型。</p><p id="822245526#g5pg4n_475">多重 Lambda 继承： 示例： 从两个 Lambda 继承并创建一个重载集：</p><div class="detached code-block" id="822245526#g5pg4n_476"><pre><code class="language-cpp">#include &lt;iostream&gt;

template&lt;typename TCall, typename UCall&gt;
class SimpleOverLoaded: public TCall, UCall{
public:
    SimpleOverLoaded(TCall tf, UCall uf): TCall(tf), UCall(uf){}
    using TCall::operaotr();
    using UCall::operator();
};

template&lt;typename TCall, typename UCall&gt;
SimpleOverLoaded&lt;TCall, UCall&gt; MakeOverloaded(TCall&amp;&amp; tf, UCall&amp;&amp; uf){
    return SimpleOverLoaded&lt;TCall, UCall&gt;(tf, uf);
}

int main(){
    const auto func = MakeOverloaded(
        [](int) { std::cout &lt;&lt; &quot;Int!\n&quot;; },
        [](float) { std::cout &lt;&lt; &quot;Float!\n&quot;; }
    );
    func(10);
    func(10.0f);
}
/* output:
 * Int!
 * Float!
 */</code></pre></div><p id="822245526#g5pg4n_477">此处从两个模板进行继承，并显示暴露它们的'operator()'。</p><section><h4 id="822245526#g5pg4n_478" data-toc="g5pg4n_478#2-Lambdas-in-C-11.md-g5pg4n_478">为什么需要显式暴露</h4><p id="822245526#g5pg4n_479">编译器在寻找正确的重载函数时，要求它们得在同一个作用域中：</p><div class="detached code-block" id="822245526#g5pg4n_480"><pre><code class="language-cpp">#include&lt;iostream&gt;

struct BaseInt{
    void Func(int) { std::cout &lt;&lt; &quot;BaseInt...\n&quot;; };
};

struct BaseDobule{
    void Func(double) { std::cout &lt;&lt; &quot;BaseDouble...\n&quot;; }
};

struct Derived: public BaseInt, BaseDouble{
    using BaseInt::Func;
    using BaseFunc::Func;
};

int main(){
    Derived d;
    d.Func(10.0);
}
/* output:
 * BaseDouble...
 */</code></pre></div><p id="822245526#g5pg4n_481">如果没有'using'语句，编译器就会报错，因为'Func()'可以来自'BaseInt'或'BaseDouble'的作用域，编译器无法决定使用哪个。</p></section></section><section><h3 id="822245526#Lambda_11" data-toc="Lambda_11#2-Lambdas-in-C-11.md-Lambda_11">在容器中存储 Lambda 表达式</h3><p id="822245526#g5pg4n_482">使用函数指针存储 Lambda:  Lambda 表达式不能默认创建和赋值，然而利用无状态 Lambda 表达式转换为函数指针的特性，虽然无法直接存储闭包对象，但可以保存从 Lambda 表达式转换出来的函数指针：</p><div class="detached code-block" id="822245526#g5pg4n_483"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

int main(){
    using Func = void(*)(int&amp;);
    std::vector&lt;TFunc&gt; ptrFuncVec;
    
    ptrFuncVec.push_back([](int&amp; x) { std::cout &lt;&lt; x &lt;&lt; '\n'; });
    prtFuncVec.push_back([](int&amp; x) { x *= 2; });
    ptrFuncVec.push_back(ptrFuncVec[0]);
    
    int x = 10;
    for(const auto&amp; entry: ptrFuncVec) entry(x);
}
/* output:
 * 10
 * 20
 */</code></pre></div><p id="822245526#g5pg4n_484">在'ptrFuncVec'中有三个变量：</p><ol class="list list-decimal" id="822245526#g5pg4n_485" type="1" start="1"><li class="list-item" id="822245526#g5pg4n_491"><p>输出输入参数的值。</p></li><li class="list-item" id="822245526#g5pg4n_492"><p>修改该值</p></li><li class="list-item" id="822245526#g5pg4n_493"><p>是第一个的副本，再次输出该值。</p></li></ol><p id="822245526#g5pg4n_486">这种方法虽然有效，但仅限于无状态的 Lambda 表达式。</p><p id="822245526#g5pg4n_487">使用std::function封装Lambda：  为了能够在容器中能够使用其他的状态的 Lambda 表达式，可以使用'std::function'处理， 这样，使其不仅可以处理整数，还可以处理字符串对象：</p><div class="detached code-block" id="822245526#g5pg4n_488"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;functional&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main(){
    std::vector&lt;std::function&lt;std::string(const std::string&amp;)&gt;&gt; vecFilters;
    
    size_t removedSpaceCounter = 0;
    const auto removeSpaces = [&amp;removedSpaceCounter](const std::string&amp; str){
        std::string tmp;
        std::copy_if(str.begin(), str.end(), std::back_inserter(tmp),
                    [](char ch) { return !isspace(ch); });
        removedSpaceCounter += str.length() - tmp.length();
        return tmp;
    }
    
    const auto makeUpperCase = [](const std::string&amp; str){
        std::string tmp = str;
        std::transform(tmp.begin(), tmp.end(), tmp.begin(),
                        [](unsigned char c) { return std::toupper(c); });
        return tmp;
    };
    
    vecFilters.emplace_back(removeSpaces);
    vecFilters.emplace_back([](const std::string&amp; x){
        return x + &quot; Amazing&quot;;
    });
    vecFilters.emplace_back([](const std::string&amp; x){
        return x + &quot; Modern&quot;;
    });
    vecFilters.emplace_back([](const std::string&amp; x){
        return x + &quot; C++&quot;;
    });
    vecFilters.emplace_back([](const std::string&amp; x){
        return x + &quot; World!&quot;;
    });
    vecFilters.emplace_back(makeUpperCase);

    const std::string str = &quot;   H e l l o     &quot;;
    auto temp = str;
    for(const auto&amp; entryFunc: vecFilters) temp = entryFunc(temp);
    std::cout &lt;&lt; temp &lt;&lt; '\n';
    std::cout &lt;&lt; &quot;Removed spaces: &quot; &lt;&lt; removedSpaceCounter &lt;&lt; '\n';
}
/* output:
 * HELLO AMAZING MODERN C++ WORLD!
 * Removed spaces: 12
 */</code></pre></div><p id="822245526#g5pg4n_489">此代码，在容器中存储'std::function&lt;std::string(const std::string&amp;)&gt;'允许使用任何类型的函数对象，包括捕获变量的 Lambda 表达式。</p></section></section></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="858187682">汇编语言</h1><p id="858187682#-rh5vo5_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="185893544">第一章 基础知识</h1><section><h2 id="185893544#1-1" data-toc="1-1#第一章-基础知识.md-1-1">1.1 机器语言</h2><p id="185893544#befe05_19"><span class="control" id="185893544#befe05_25">机器语言是机器指令的集合。</span></p><p id="185893544#befe05_20">机器指令就是一台计算机可以正确执行的命令， <span class="control" id="185893544#befe05_26">机器指令是一列二进制数字</span>， 计算机将其转换为一列高低电平，使计算机的电子器件受到驱动，然后进行运算。</p><p id="185893544#befe05_21">在现代的PC机中，负责执行上述操作的硬件为CPU(<span class="emphasis" id="185893544#befe05_27">Central Processing Unit</span>， 中央处理单元)。</p><p id="185893544#befe05_22"><span class="control" id="185893544#befe05_28">一般来说，一个计算机是由CPU及其它受CPU直接或间接控制的芯片、器件、设备组成的计算机系统。</span></p><p id="185893544#befe05_23">不同的CPU，其硬件设计和内部结构都是不相同的，因此就需要用不同的电平脉冲对其进行控制，使其工作，所以<span class="control" id="185893544#befe05_29">每一种CPU都有自己的机器指令集，也就是机器语言。</span></p><p id="185893544#befe05_24">早机器的程序设计使用的机器语言，也就是使用0和1来进行一系列的编程工作，这导致书写和阅读机器码十分困难，并且在后期的调试过程中也会显得十分麻烦，为了解决这样的问题，在后续就引入了汇编语言。</p></section><section><h2 id="185893544#1-2" data-toc="1-2#第一章-基础知识.md-1-2">1.2 汇编语言</h2><p id="185893544#befe05_30"><span class="control" id="185893544#befe05_35">汇编语言的主体使汇编指令。</span> 因为汇编语言的出现主要是为了简化机器码的表示，所以汇编指令和机器指令的差别主要在于指令的表示方法上。</p><p id="185893544#befe05_31">例如：</p><ul class="list" id="185893544#befe05_32" start="1"><li class="list-item" id="185893544#befe05_37"><p>操作： 寄存器 BX 的内容发送到 AX 中</p></li><li class="list-item" id="185893544#befe05_38"><p>机器指令： 1000100111011000</p></li><li class="list-item" id="185893544#befe05_39"><p>汇编指令： mov ax, bx</p></li></ul><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="185893544#befe05_40">寄存器：在CPU中可以存储的器件，一个CPU中有多个寄存器。 AX 是其中一个寄存器的代号， BX 是另一个寄存器的代号。</p></div>
</blockquote>
<div class="container"><figure class="image-container"><img class="center image image-size" id="185893544#befe05_34" alt="Assembly0.png" title="Assembly0.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/Assembly0.png" width="610" height="147"><figcaption class="center-text">Assembly0.png</figcaption></figure></div></section><section><h2 id="185893544#1-3" data-toc="1-3#第一章-基础知识.md-1-3">1.3 汇编语言组成</h2><p id="185893544#befe05_41">汇编语言由以下3类指令组成：</p><ol class="list list-decimal" id="185893544#befe05_42" type="1" start="1"><li class="list-item" id="185893544#befe05_44"><p><span class="control" id="185893544#befe05_47">汇编指令</span> ：机器码的助记符，有对应的机器码。</p></li><li class="list-item" id="185893544#befe05_45"><p><span class="control" id="185893544#befe05_48">伪指令</span> ：没有对应的机器码，由编译器执行，计算机并不执行。</p></li><li class="list-item" id="185893544#befe05_46"><p><span class="control" id="185893544#befe05_49">其他符号</span> ：如+、-、*、/等，由编译器识别，没有对应的机器码。</p></li></ol><p id="185893544#befe05_43"><span class="control" id="185893544#befe05_50">汇编语言的核心是汇编指令，它决定了汇编语言的特性。</span></p></section><section><h2 id="185893544#1-4" data-toc="1-4#第一章-基础知识.md-1-4">1.4 存储器</h2><p id="185893544#befe05_51">CPU 是计算机的核心硬件，它控制整个计算机的运行并进行计算。  要让一个CPU工作， 就必须要向它提供指令和数据，而<span class="control" id="185893544#befe05_53">指令和数据会存放在存储器中</span> ，即内存。</p></section><section><h2 id="185893544#1-5" data-toc="1-5#第一章-基础知识.md-1-5">1.5 指令和数据</h2><p id="185893544#befe05_54">指令和数据是应用上的概念，它们都是二进制信息，CPU在工作时会把有的信息的看作指令，有的信息看作数据。</p><p id="185893544#befe05_55">例如：内存中的一段二进制信息 1000100111011000，计算机(CPU)可以既可以将其当作数据进行计算，也可以当作指令执行</p><ul class="list" id="185893544#befe05_56" start="1"><li class="list-item" id="185893544#befe05_57"><p>1000100111011000 -&gt; 89D8H(数据)</p></li><li class="list-item" id="185893544#befe05_58"><p>1000100111011000 -&gt; mov ax, bx(程序)</p></li></ul></section><section><h2 id="185893544#1-6" data-toc="1-6#第一章-基础知识.md-1-6">1.6 存储单元</h2><p id="185893544#befe05_59">存储器被划分为若干个存储单元。每个存储单元从0开始编号。 对于一个有128个存储单元的存储器而言，其编号顺序如下图所示：</p><div class="container"><figure class="image-container"><img class="center image image-size" id="185893544#befe05_60" alt="Assembly1.png" title="Assembly1.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/Assembly1.png" width="170" height="297"><figcaption class="center-text">Assembly1.png</figcaption></figure></div><p id="185893544#befe05_61">8bit(比特)组成1Byte(字节)，存储器中的存储单元可以存储1Byte，即8个二进制位(bit)，对于上面的存储器而言，它可以存储128Byte。  对于拥有128个存储单元的存储器，其容量为128个字节(Byte)。</p><div class="table-wrapper detached"><table id="185893544#befe05_62"><tr class="header-row" id="185893544#befe05_64"><th id="185893544#befe05_69"><p>存储单位</p></th><th id="185893544#befe05_70"><p>换算关系</p></th></tr><tr class="" id="185893544#befe05_65"><td id="185893544#befe05_71"><p>KB</p></td><td id="185893544#befe05_72"><p>1KB=1024B</p></td></tr><tr class="" id="185893544#befe05_66"><td id="185893544#befe05_73"><p>MB</p></td><td id="185893544#befe05_74"><p>1MB=1024KB</p></td></tr><tr class="" id="185893544#befe05_67"><td id="185893544#befe05_75"><p>GB</p></td><td id="185893544#befe05_76"><p>1GB=1024MB</p></td></tr><tr class="" id="185893544#befe05_68"><td id="185893544#befe05_77"><p>TB</p></td><td id="185893544#befe05_78"><p>1TB=1024GB</p></td></tr></table></div></section><section><h2 id="185893544#1-7-cpu" data-toc="1-7-cpu#第一章-基础知识.md-1-7-cpu">1.7 CPU对存储器的读写</h2><p id="185893544#befe05_79">CPU 要从内存中读取数据，首先要确定存储单元的地址，同时也要确定是对哪一个器件进行操作，进行哪种操作。</p><p id="185893544#befe05_80">CPU 想要进行数据的读写，必须和芯片进行下面三类信息的交互：</p><ul class="list" id="185893544#befe05_81" start="1"><li class="list-item" id="185893544#befe05_91"><p>存储的单元的地址(地址信息)</p></li><li class="list-item" id="185893544#befe05_92"><p>器件的选择，读或写的命令(控制信息)</p></li><li class="list-item" id="185893544#befe05_93"><p>读或写的数据(数据信息)</p></li></ul><p id="185893544#befe05_82">在计算机中，电信号通过导线进行传输，这种连接CPU和其他芯片的导线被称为总线。  在物理层面上来讲，就是一根根导线的集合。 根据传送信息的不同，总线从逻辑上又分为3类，地址总线、控制总线和数据总线。</p><p id="185893544#befe05_83">CPU 从 3 号单元中读取数据的过程如下：</p><div class="container"><figure class="image-container"><img class="center image image-size" id="185893544#befe05_84" alt="Assembly2.png" title="Assembly2.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/Assembly2.png" width="366" height="241"><figcaption class="center-text">Assembly2.png</figcaption></figure></div><p id="185893544#befe05_85">读操作：</p><ol class="list list-decimal" id="185893544#befe05_86" type="1" start="1"><li class="list-item" id="185893544#befe05_95"><p>CPU 通过<span class="control" id="185893544#befe05_98">地址线将地址信息 3 发出</span></p></li><li class="list-item" id="185893544#befe05_96"><p>CPU 通过<span class="control" id="185893544#befe05_99">控制线发出内存读命令</span> ，选中存储芯片，并通知它，将要从中读取数据。</p></li><li class="list-item" id="185893544#befe05_97"><p>存储器将 3 号单元中的<span class="control" id="185893544#befe05_100">数据 8 通过数据线送入 CPU</span>。</p></li></ol><p id="185893544#befe05_87">写操作：</p><ol class="list list-decimal" id="185893544#befe05_88" type="1" start="1"><li class="list-item" id="185893544#befe05_101"><p>CPU 通过地址线将地址信息 3 发出。</p></li><li class="list-item" id="185893544#befe05_102"><p>CPU 通过控制线发出内存写命令，选中存储芯片，并通知它，将要向其中写入数据。</p></li><li class="list-item" id="185893544#befe05_103"><p>CPU 通过数据线将数据 26 送入内存的 3 号单元中。</p></li></ol><p id="185893544#befe05_89">对于 8086CPU， 下面的机器码，可以实现从 3 号单元中读数据：  机器码： 101000010000001100000000 含义： 从 3 号单元读取数据送入寄存器 AX</p><p id="185893544#befe05_90">完成上述操作后，再进行写操作：  机器码： 101000010000001100000000 对应的汇编指令： MOV AX, [3] 含义： 传送 3 号单元的内容至 AX</p></section><section><h2 id="185893544#1-8" data-toc="1-8#第一章-基础知识.md-1-8">1.8 地址总线</h2><p id="185893544#befe05_108">CPU 是通过地址总线来指定存储器单元的，并且地址总线可以传输的不同信息数量决定了 CPU 可以对多少个存储单元进行寻址。</p><p id="185893544#befe05_109">先假设，一个 CPU 有 10 根地址总线，一根导线能够传递的稳定状态有两种，高电平和低电平， 用二进制表示就是1或0，10 根导线可以传送 10 位二进制数据，而 10 位二进制数可以表示 2<span id="185893544#befe05_116"><sup>10</sup></span> (0-1023, 即1024)个不同的数据。</p><div class="container"><figure class="image-container"><img class="center image image-size" id="185893544#befe05_110" alt="Assembly3.png" title="Assembly3.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/Assembly3.png" width="340" height="339"><figcaption class="center-text">Assembly3.png</figcaption></figure></div><p id="185893544#befe05_111">上图展示了一个具有 10 根地址线的 CPU 向内存发出地址信息 11 时 10 根地址线上传送的二进制信息。</p><div class="detached code-block" id="185893544#befe05_112"><pre><code class="language-none">地址线0---------2^0-------  
地址线1---------2^1-------  
地址线2---------2^2-------  
地址线3---------2^3-------  
地址线4---------2^4-------  
地址线5---------2^5-------  
地址线6---------2^6-------  
地址线7---------2^7-------  
地址线8---------2^8-------  
地址线9---------2^9-------</code></pre></div><p id="185893544#befe05_113">对应地，当访问地址为 12 时的内存单元时，地址总线上传输的内容为：</p><div class="container"><figure class="image-container"><img class="center image image-size" id="185893544#befe05_114" alt="Assembly4.png" title="Assembly4.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/Assembly4.png" width="335" height="339"><figcaption class="center-text">Assembly4.png</figcaption></figure></div><p id="185893544#befe05_115">一个 CPU 有 N 根地址线，则可以说这个 CPU 的地址总线的宽度为 N，这样的 CPU 最多可以寻找 2 的 N 次方个内存单元。</p></section><section><h2 id="185893544#1-9" data-toc="1-9#第一章-基础知识.md-1-9">1.9 数据总线</h2><p id="185893544#befe05_117">CPU 与内存或其他芯片之间的数据传送是通过数据总线来进行的。数据总线的宽度决定了 CPU 和外界的数据传输速度。  8 根数据总线一次可以传送一个 8 位二进制数据(即 1 Byte)，16 根数据总线一次可传送 2 Byte，即 1 根数据总线一次可传送 1 bit。</p><p id="185893544#befe05_118">8088CPU 的数据总线宽度为 8， 8086CPU 的数据总线宽度为16，当向内存中写入数据 89D8H 时，数据传输过程如下：</p><div class="container"><figure class="image-container"><img class="center image image-size" id="185893544#befe05_119" alt="Assembly5.png" title="Assembly5.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/Assembly5.png" width="391" height="351"><figcaption class="center-text">Assembly5.png</figcaption></figure></div><div class="container"><figure class="image-container"><img class="center image image-size" id="185893544#befe05_120" alt="Assembly6.png" title="Assembly6.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/Assembly6.png" width="293" height="393"><figcaption class="center-text">Assembly6.png</figcaption></figure></div><p id="185893544#befe05_121">由上可知，8086 有 16 根数据线，可一次传输16位数据，所以可以一次传输数据 89D8H；而 8088 只有 8 根数据线， 一次只能传输 8 位数据，所以向内存写入数据 89D8H 时需要进行两次数据传输。</p><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="185893544#befe05_125">补充： 此处如何对传输的数据进行划分</p><ol class="list list-decimal" id="185893544#befe05_126" type="1" start="1"><li class="list-item" id="185893544#befe05_127"><p>对于偶数字节的划分，将其划分为高低位，前一半为高位，后一半为低位。</p></li><li class="list-item" id="185893544#befe05_128"><p>对于奇数字节的划分，将其均等化分为高中低位。</p></li><li class="list-item" id="185893544#befe05_129"><p>在数据传输的过程中，如果总线宽度不够一次传输所有数据，据需要分高低位多次传输。</p></li></ol></div>
</blockquote>
<div class="detached code-block" id="185893544#befe05_123"><pre><code class="language-cpp">/* 例如对一个2字节(16位)数据
   使用位运算来提取高低字节
*/
unsigned char data = 0x89D8;
unsigned char high_byte = (data &gt;&gt; 8) &amp; 0xFF;   // 取高字节 
unsigned char low_byte = data &amp; 0XFF;           // 取低字节</code></pre></div></section><section><h2 id="185893544#1-10" data-toc="1-10#第一章-基础知识.md-1-10">1.10 控制总线</h2><p id="185893544#befe05_130">CPU 对外部芯片的控制是通过控制总线来实现的。  此处控制总线是一些不同控制线的集合。有多少根控制总线，就意味着 CPU 提供了对多种外部芯片的多种控制， 所以控制总线决定了 CPU 对外部芯片的控制能力。</p><p id="185893544#befe05_131">内存的读或写命令是由几根控制线综合发出的，其中就有一根成为&ldquo;读信号输出&rdquo;的控制线负责由 CPU 向外传送读信号， CPU 向该控制线上输出低电平表示将要读取数据；有一根称为&ldquo;写信号输出&rdquo;的控制线则负责传送写信号。</p></section><section><h2 id="185893544#1-1-1-10" data-toc="1-1-1-10#第一章-基础知识.md-1-1-1-10">1.1 ~ 1.10 小结</h2><ol class="list list-decimal" id="185893544#befe05_133" type="1" start="1"><li class="list-item" id="185893544#befe05_134"><p>汇编指令是机器指令的助记符。</p></li><li class="list-item" id="185893544#befe05_135"><p>每一种 CPU 都有自己的汇编指令集。</p></li><li class="list-item" id="185893544#befe05_136"><p>CPU 可以直接使用的信息在存储器中存放。</p></li><li class="list-item" id="185893544#befe05_137"><p>在存储器中指令和数据没有任何区别，都是二进制信息。</p></li><li class="list-item" id="185893544#befe05_138"><p>存储单元从0开始按顺序编号。</p></li><li class="list-item" id="185893544#befe05_139"><p>一个存储单元可以存储8bit，即1Byte、8位二进制数。</p></li><li class="list-item" id="185893544#befe05_140"><p>1Byte=8bit 1KB=1024B 1MB=1024KB 1GB=1024MB。</p></li><li class="list-item" id="185893544#befe05_141"><p>每一个 CPU 芯片都有许多针脚，这些针脚和总线相连，或者说，这些针脚引出总线。一个 CPU 可以引出3种总线的宽度标志了这个 CPU 的不同方面的性能: </p><ul class="list" id="185893544#befe05_142" start="1"><li class="list-item" id="185893544#befe05_143"><p>地址总线的宽度决定了 CPU 的寻址能力；</p></li><li class="list-item" id="185893544#befe05_144"><p>数据总线的宽度决定了 CPU 与其他器件进行数据传送时的一次数据传送量；</p></li><li class="list-item" id="185893544#befe05_145"><p>控制总线的宽度决定了 CPU 对系统中其他芯片的控制能力。</p></li></ul></li></ol></section><section><h2 id="185893544#1-1_1" data-toc="1-1_1#第一章-基础知识.md-1-1_1">小测 1.1</h2><ol class="list list-decimal" id="185893544#befe05_146" type="1" start="1"><li class="list-item" id="185893544#befe05_157"><p>一个 CPU 的寻址能力为 8KB，那么它的地址总线的宽度为 13。</p></li></ol><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="185893544#befe05_158">寻址能力为 8KB，即2<span id="185893544#befe05_159"><sup>13</sup></span> 字节，所以地址总线宽度为13位。</p></div>
</blockquote>
<ol class="list list-decimal" id="185893544#befe05_148" type="1" start="2"><li class="list-item" id="185893544#befe05_160"><p>1KB 的存储器由 1024 个存储单元组成，存储单元的编号从 0 到 1023。</p></li></ol><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="185893544#befe05_161">1KB = 1024字节(Byte)，每个存储单元存储1字节(Byte)，因此有1024个存储单元。</p></div>
</blockquote>
<ol class="list list-decimal" id="185893544#befe05_150" type="1" start="3"><li class="list-item" id="185893544#befe05_162"><p>1KB的存储器可以存储8192bit，1024个Byte。</p></li><li class="list-item" id="185893544#befe05_163"><p>1GB、1MB、1KB分别是1024<span class="emphasis" id="185893544#befe05_165">1024</span>1024、1024*1024、1024个Byte</p></li><li class="list-item" id="185893544#befe05_164"><p>8080、8088、80286、80386的地址总线宽度分别为16根、20根、24根、32根，则它们的寻址能力分别为： 64KB、 1MB、 16MB、 4GB。</p></li></ol><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="185893544#befe05_166">寻址能力为2<span id="185893544#befe05_168"><sup>地址总线宽度</sup></span> 字节：</p><ul class="list" id="185893544#befe05_167" start="1"><li class="list-item" id="185893544#befe05_169"><p>8080: 2<span id="185893544#befe05_173"><sup>16</sup></span> = 64KB</p></li><li class="list-item" id="185893544#befe05_170"><p>8088: 2<span id="185893544#befe05_174"><sup>20</sup></span> = 1MB</p></li><li class="list-item" id="185893544#befe05_171"><p>80286: 2<span id="185893544#befe05_175"><sup>24</sup></span> = 16MB</p></li><li class="list-item" id="185893544#befe05_172"><p>80386: 2^32 = 4GB</p></li></ul></div>
</blockquote>
<ol class="list list-decimal" id="185893544#befe05_152" type="1" start="6"><li class="list-item" id="185893544#befe05_176"><p>8080、8088、8086、80826、80386的数据总线宽度分别为8根、8根、16根、16根、32根，则他们一次可以传送的数据为: 1B、 1B、 2B、 2B、 4B。</p></li></ol><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="185893544#befe05_177">数据总线宽度决定一次可以传送的数据位数，每 8 位为 1 字节</p></div>
</blockquote>
<ol class="list list-decimal" id="185893544#befe05_154" type="1" start="7"><li class="list-item" id="185893544#befe05_178"><p>从内存中读取 1024 字节的数据，8086至少要读 512 次， 80386至少要读 256 次。</p></li></ol><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="185893544#befe05_179">8086的数据总线宽度为 16 位(2 字节) 80386的数据总线宽度为 32 位(4 字节)</p></div>
</blockquote>
<ol class="list list-decimal" id="185893544#befe05_156" type="1" start="8"><li class="list-item" id="185893544#befe05_180"><p>在存储器中，数据和程序以 二进制 形式存放。</p></li></ol></section><section><h2 id="185893544#1-11" data-toc="1-11#第一章-基础知识.md-1-11">1.11 主板</h2><p id="185893544#befe05_181">在 PC 机中， 主板上集成了一些核心器件和主要器件，这些器件通过总线(地址总线、数据总线、控制总线)相连。  这些器件包括但不限于 CPU、 存储器、 外围芯片组、 扩展插槽等。</p></section><section><h2 id="185893544#1-12" data-toc="1-12#第一章-基础知识.md-1-12">1.12 接口卡</h2><p id="185893544#befe05_183">在计算机系统中，CPU 控制所有可用程序控制其工作的设备。CPU 不能对外部设备直接进行控制， 直接控制这些设备进行工作的是插在扩展插槽上的接口卡，扩展插槽通过总线和 CPU 相连， 所以接口卡也通过总线同 CPU 相连，CPU 可以直接控制这些接口卡，从而实现 CPU 对外部设备的间接控制。</p></section><section><h2 id="185893544#1-13" data-toc="1-13#第一章-基础知识.md-1-13">1.13 各类存储器芯片</h2><p id="185893544#befe05_184">根据存储器的读写属性可以将其分为两类：</p><ul class="list" id="185893544#befe05_185" start="1"><li class="list-item" id="185893544#befe05_195"><p>随机存储器(RAM)：随机存储器可读可写，但必须带电存储，关机后存储内容丢失</p></li><li class="list-item" id="185893544#befe05_196"><p>只读存储器(ROM)：只读存储器只能读取不能写入，关机后其中的内容不丢失。</p></li></ul><p id="185893544#befe05_186">根据存储器的功能和连接方式上可以分为以下几类：</p><ul class="list" id="185893544#befe05_187" start="1"><li class="list-item" id="185893544#befe05_197"><p>随机存储器</p></li></ul><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="185893544#befe05_198">用于存放供 CPU 使用的绝大部分程序和数据， 主随机存储器一般由两个位置上的 RAM组成 ，装在主板上的 RAM 和插在扩展插槽上的 RAM。</p></div>
</blockquote>
<ul class="list" id="185893544#befe05_189" start="1"><li class="list-item" id="185893544#befe05_199"><p>装有 BIOS (Basic Input/Output System，基本输入/输出系统)的ROM</p></li></ul><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="185893544#befe05_200">BIOS 是由主板和各类接口卡厂商提供的软件系统，可以通过它利用该硬件设备进行最基本的输入输出。</p></div>
</blockquote>
<ul class="list" id="185893544#befe05_191" start="1"><li class="list-item" id="185893544#befe05_201"><p>接口卡上的 RAM</p></li></ul><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="185893544#befe05_202">某些接口卡需要大批量输入、输出数据进行暂时存储，在其上装有 RAM。 最典型的是显卡上的RAM，一般称之为显存，显卡随时将显存中的数据向显示器上输出。</p></div>
</blockquote>
<p id="185893544#befe05_193">PC 系统中各类存储器的逻辑连接情况如下所示：</p><div class="container"><figure class="image-container"><img class="center image image-size" id="185893544#befe05_194" alt="Assembly_8.png" title="Assembly_8.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/Assembly_8.png" width="515" height="434"><figcaption class="center-text">Assembly_8.png</figcaption></figure></div></section><section><h2 id="185893544#1-14" data-toc="1-14#第一章-基础知识.md-1-14">1.14 内存地址空间</h2><p id="185893544#befe05_203">内存地址空间(Memory Address Space)指的是计算机系统中内存单元的一个空逻辑排列， 用于表示可以被处理器访问的所有存储位置。  举个例子，一个 CPU 的地址总线宽度为 10， 那么可以寻址 1024 个内存单元， 这 1024 个可寻到的内存单元就构成这个 CPU 的内存地址空间。</p><p id="185893544#befe05_204">前面提及的存储器，都有以下两个共同点：</p><ul class="list" id="185893544#befe05_205" start="1"><li class="list-item" id="185893544#befe05_221"><p>都和 CPU 的总线相连</p></li><li class="list-item" id="185893544#befe05_222"><p>CPU 对它们进行读或写的时候通过控制线发出内存读写命令</p></li></ul><p id="185893544#befe05_206">CPU 在控制这些存储器时，把它们当作内存来对待，把它们看作一个由若干存储单元组成的逻辑存储器， 这个逻辑存储器就是内存地址空间。</p><p id="185893544#befe05_207">CPU 将系统中各类存储器看作一个逻辑存储器的情况如下图所示：</p><div class="container"><figure class="image-container"><img class="center image image-size" id="185893544#befe05_208" alt="Assmebly_8.png" title="Assmebly_8.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/Assmebly_8.png" width="611" height="548"><figcaption class="center-text">Assmebly_8.png</figcaption></figure></div><p id="185893544#befe05_209">在上图中，所有的物理存储器被看作一个由若干个存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一段地址空间。  CPU 在这段地址空间中读写数据，实际就是在相对应的物理存储器中读写数据。  假设上图中的内存地址空间的地址段分配如下:</p><ul class="list" id="185893544#befe05_210" start="1"><li class="list-item" id="185893544#befe05_225"><p>地址 0 ~ 7FFFH 的 32KB 空间为主随机存储器的地址空间</p></li><li class="list-item" id="185893544#befe05_226"><p>地址 8000H ~ 9FFFH 的 8KB 空间为显存的地址空间</p></li><li class="list-item" id="185893544#befe05_227"><p>地址 A000H ~ FFFFH 的 24KB 空间为各个 ROM 的地址空间</p></li></ul><p id="185893544#befe05_211">这样， CPU 可以根据不同的地址段对不同的存储器进行操作：</p><ul class="list" id="185893544#befe05_212" start="1"><li class="list-item" id="185893544#befe05_228"><p>CPU 向内存地址为 1000H 的内存单元中写入数据，这个数据就被写入主随机存储器中</p></li><li class="list-item" id="185893544#befe05_229"><p>CPU 向内存地址为 8000H 的内存单元中写入数据，这个数据就被写入显存中，然后会被显卡输出到显示器上</p></li><li class="list-item" id="185893544#befe05_230"><p>CPU 向内存地址为 C000H 的内存单元中写入数据的操作没有结果，C000H单元中的内容不会被改变，C000H单元实际上就是 ROM存储器(只读存储器) 中的一个单元</p></li></ul><p id="185893544#befe05_213">内存地址空间的大小受 CPU 地址总线宽度的限制。 8086CPU的地址总线宽度为20， 可以传送 2<span id="185893544#befe05_231"><sup>20</sup></span> (从 0 至 2<span id="185893544#befe05_232"><sup>20</sup></span> - 1) 个不同的地址信息。 即可以定位 2<span id="185893544#befe05_233"><sup>20</sup></span> 个内存单元，则8086CPU 的内存地址空间大小为 1MB(1024 * 1024Byte)，同理80386CPU的地址总线宽度为 32， 则内存地址空间最大为4GB(1024 * 1024 * 1024 * 4Byte)。</p><p id="185893544#befe05_214">在基于一个计算机硬件系统编程时，必须知道这个系统中的内存地址分配情况。因为当对某类存储器进行读写操作时，必须知道它的第一个和最后一个单元的地址， 才能保证读写操作是在预期的存储器中进行的。</p><p id="185893544#befe05_215">不同的计算机系统的内存地址空间的分配情况是不同的，下图展示的是 8086PC 机内的地址空间分配的情况：</p><div class="container"><figure class="image-container"><img class="center image image-size" id="185893544#befe05_216" alt="Assembly_9.png" title="Assembly_9.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/Assembly_9.png" width="248" height="348"><figcaption class="center-text">Assembly_9.png</figcaption></figure></div><p id="185893544#befe05_217">从上图中可以看出：</p><ul class="list" id="185893544#befe05_218" start="1"><li class="list-item" id="185893544#befe05_234"><p>从地址0 ~ 9FFFF的内存单元中读取数据，实际上就是在读取主随机存储器中的数据</p></li><li class="list-item" id="185893544#befe05_235"><p>向地址A0000 ~ BFFF的内存单元中写入数据，就是向显存中写入数据，这些数据会被显卡输出到显示器上</p></li><li class="list-item" id="185893544#befe05_236"><p>向地址C000 ~ FFFF的内存单元中写入数据的操作是无效的，因为这个地址段对应的是ROM存储器(只读存储器)，但是可以向这个地址段进行数据读取的操作</p></li></ul><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="185893544#befe05_237"><span class="control" id="185893544#befe05_238">内存地址空间</span> 因为程序最终是运行在 CPU 上的，所以当在使用汇编语言进行编程时，必须要从 CPU 的角度考虑问题。  对 CPU 而言，系统中所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受 CPU 的寻址能力(地址总线宽度)的限制。  这个逻辑存储器就是内存地址空间。</p></div>
</blockquote>
</section></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="-2081311865">第二章 寄存器</h1><p id="-2081311865#d8g8ra_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="-1670513275">第三章 寄存器(内存访问)</h1><p id="-1670513275#z62zd0o_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="-262646426">现代操作系统</h1><p id="-262646426#q602zr_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="789304755">操作系统</h1><p id="789304755#-cjhjk6_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="1534051343">Functional Programming_</h1><section><h2 id="1534051343#haskell" data-toc="haskell#Functional-Programming.md-haskell">第一章 Haskell简介</h2><ol class="list list-decimal" id="1534051343#-8qn40y_5" type="1" start="1"><li class="list-item" id="1534051343#-8qn40y_6"><p id="1534051343#-8qn40y_12"><span class="control" id="1534051343#-8qn40y_14">Haskell简介</span></p><ul class="list" id="1534051343#-8qn40y_13" start="1"><li class="list-item" id="1534051343#-8qn40y_15"><p>提供了Haskell起源的历史概述，追溯到Lambda演算和Lisp、ISWIM、Scheme、ML等语言的出现。</p></li><li class="list-item" id="1534051343#-8qn40y_16"><p>讨论了在1987年的函数式编程与计算机体系结构会议上创建Haskell的动机，以解决函数式编程语言的泛滥问题。</p></li><li class="list-item" id="1534051343#-8qn40y_17"><p>强调了Haskell开发的重要性，将各种函数式编程语言的精髓融入统一的框架中。</p></li></ul></li><li class="list-item" id="1534051343#-8qn40y_7"><p id="1534051343#-8qn40y_18"><span class="control" id="1534051343#-8qn40y_20">安装与开发环境设置</span></p><ul class="list" id="1534051343#-8qn40y_19" start="1"><li class="list-item" id="1534051343#-8qn40y_21"><p>描述了GHC（格拉斯哥 Haskell 编译器）的安装过程，并推荐使用Haskell平台作为综合开发环境。</p></li><li class="list-item" id="1534051343#-8qn40y_22"><p>介绍了使用GHCi进行Haskell程序的交互式测试和调试。</p></li><li class="list-item" id="1534051343#-8qn40y_23"><p>建议使用Notepad++、Sublime、Emacs、Vim等编辑器编写Haskell代码，并特别注意保持正确的缩进和对齐。</p></li></ul></li><li class="list-item" id="1534051343#-8qn40y_8"><p id="1534051343#-8qn40y_24"><span class="control" id="1534051343#-8qn40y_26">使用GHCi</span></p><ul class="list" id="1534051343#-8qn40y_25" start="1"><li class="list-item" id="1534051343#-8qn40y_27"><p>解释了各种GHCi命令，用于导入文件、重新加载模块、更改当前目录、执行系统命令、退出GHCi以及访问帮助文档。</p></li><li class="list-item" id="1534051343#-8qn40y_28"><p>演示了如何在GHCi中调用函数，展示了算术运算、逻辑运算符、数学函数和基本列表操作。</p></li></ul></li><li class="list-item" id="1534051343#-8qn40y_9"><p id="1534051343#-8qn40y_29"><span class="control" id="1534051343#-8qn40y_31">.hs和.lhs文件、注释和库函数</span></p><ul class="list" id="1534051343#-8qn40y_30" start="1"><li class="list-item" id="1534051343#-8qn40y_32"><p>区分了.hs和.lhs文件，.lhs文件主要用于文学化的Haskell编程，用于生成格式化的文档。</p></li><li class="list-item" id="1534051343#-8qn40y_33"><p>讨论了Haskell文件中的注释约定和编译器指令。</p></li><li class="list-item" id="1534051343#-8qn40y_34"><p>强调了Prelude中丰富的Haskell函数库，并鼓励探索各种任务的库函数。</p></li></ul></li><li class="list-item" id="1534051343#-8qn40y_10"><p id="1534051343#-8qn40y_35"><span class="control" id="1534051343#-8qn40y_37">创建第一个Haskell程序 - HelloWorld</span></p><ul class="list" id="1534051343#-8qn40y_36" start="1"><li class="list-item" id="1534051343#-8qn40y_38"><p>指导如何在Haskell中创建一个简单的HelloWorld程序，强调了main函数作为入口点的作用。</p></li><li class="list-item" id="1534051343#-8qn40y_39"><p>提供了使用GHC和runghc命令编译和执行Haskell程序的说明。</p></li><li class="list-item" id="1534051343#-8qn40y_40"><p>注意了Haskell和C等语言之间文件大小的差异，将其归因于Haskell对内存和磁盘空间的利用效率。</p></li></ul></li><li class="list-item" id="1534051343#-8qn40y_11"><p id="1534051343#-8qn40y_41"><span class="control" id="1534051343#-8qn40y_43">结论</span></p><ul class="list" id="1534051343#-8qn40y_42" start="1"><li class="list-item" id="1534051343#-8qn40y_44"><p>总结了本章的内容，并鼓励读者熟悉GHCi并进一步探索Haskell的能力。</p></li><li class="list-item" id="1534051343#-8qn40y_45"><p>预见了Haskell等函数式编程语言的光明未来，这是由它们简洁、健壮和安全的代码库驱动的。</p></li></ul></li></ol></section><section><h2 id="1534051343#-8qn40y_4" data-toc="-8qn40y_4#Functional-Programming.md--8qn40y_4">第二章 类型系统和函数</h2><ol class="list list-decimal" id="1534051343#-8qn40y_46" type="1" start="1"><li class="list-item" id="1534051343#-8qn40y_47"><p id="1534051343#-8qn40y_49">Haskell常用数据类型 1.1 布尔类型：Bool 布尔类型是一个只有 True 与 False 两个值的数据类型。布尔值的运算符号和其他 语言相似，&amp;&amp; 表示&ldquo;逻辑与&rdquo;运算，|| 表示&ldquo;逻辑或&rdquo;运算，not 表示&ldquo;逻辑非&rdquo;运 算。  1.2 字符型：Char 由单引号包裹的单个字符都是 Char 类型的，与其他语言一致。  1.3 有符号整数：Int Int 几乎是所有的编程语言里都有的数据类型。它的范围与操作系统和 GHC 位数有关。 若使用的是 32 位的 GHC，那么整数的范围是 &minus;2<span id="1534051343#-8qn40y_56"><sup>31</sup></span> ~ 2<span id="1534051343#-8qn40y_57"><sup>31</sup></span> - 1。对于 64 位 GHC 来说 Int 的范围则是 &minus;2<span id="1534051343#-8qn40y_58"><sup>63</sup></span> ~ 2<span id="1534051343#-8qn40y_59"><sup>63</sup></span> - 1，Haskell 里还有另外一个整数 类型&mdash;&mdash;任意精度整数，如果不指明类型，Haskell 会将 2<span id="1534051343#-8qn40y_60"><sup>32</sup></span> 默认为任意精度整数处理。  1.4 无符号整数：Word Word 类型是无符号的整数，它的范围也是系统相关的。在 32 位系统中它的范围是 0 &sim; 2 32 &minus; 1 而 64 位系统则为 0 &sim; 2 64 &minus; 1。Haskell 中的 Word 相当于 C 语言里 的 unsigned int 类型。使用 Word 类型需要导入 Data.Word 库，在 GHCi 中可以使 用:module（简写为:m）来控制模块的加载。  1.5 任意精度整数：Integer 与 Int 不同，Integer 类型可以表示任意大小的整数，限制它的大小范围的唯一因素就 是计算机的内存。  1.6 小数与有理数类型：Float、Double、Rational Haskell 中的单精度浮点数 Float、双精度浮点数 Double 与其他语言没有很大的区别。 Haskell 还有有理数类型 Rational，即用两个任意精度的整数来表示一个小数，这在做高精度数学运算时有很多好。</p></li><li class="list-item" id="1534051343#-8qn40y_48"><p id="1534051343#-8qn40y_67">sd</p><ol class="list list-decimal" id="1534051343#-8qn40y_68" type="1" start="1"><li class="list-item" id="1534051343#-8qn40y_69"><ol class="list list-decimal" id="1534051343#-8qn40y_72" type="1" start="1"><li class="list-item" id="1534051343#-8qn40y_73"><p>23</p></li></ol></li><li class="list-item" id="1534051343#-8qn40y_70"><p>速度</p></li><li class="list-item" id="1534051343#-8qn40y_71"><ol class="list list-decimal" id="1534051343#-8qn40y_74" type="1" start="1"><li class="list-item" id="1534051343#-8qn40y_75"><p>读书</p></li></ol></li></ol></li></ol></section></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="1004310786">编译原理</h1><p id="1004310786#bevd3f_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="1573558248">内存池(Memory Pool)</h1><p id="1573558248#-r4z5pn_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="-956561027">Effective C++</h1></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="1162768069">第一章 让自己习惯 C++</h1><section><h2 id="1162768069#1-c" data-toc="1-c#第一章-让自己习惯C.md-1-c">条款1：视C++为一个语言联邦</h2><p id="1162768069#-fik7fc_7">关于C++的四种次语言(<span class="emphasis" id="1162768069#-fik7fc_10">sub-language</span>):</p><ol class="list list-decimal" id="1162768069#-fik7fc_8" type="1" start="1"><li class="list-item" id="1162768069#-fik7fc_11"><p id="1162768069#-fik7fc_15"><span class="emphasis" id="1162768069#-fik7fc_16">C</span>， <span class="emphasis" id="1162768069#-fik7fc_17">C++<span class="emphasis" id="1162768069#-fik7fc_18">以</span>C</span>为基础的。</p></li><li class="list-item" id="1162768069#-fik7fc_12"><p id="1162768069#-fik7fc_19"><span class="emphasis" id="1162768069#-fik7fc_20">Object-Oriented C++</span> ，体现了<span class="inline-code" id="1162768069#-fik7fc_21">C++</span>面向对象的特性。  对于内置类型而言<span class="inline-code" id="1162768069#-fik7fc_23">pass-by-value</span>相比较于<span class="inline-code" id="1162768069#-fik7fc_24">pass-by-reference</span>会更高效。  但对于面对对象的<span class="inline-code" id="1162768069#-fik7fc_26">C++</span>而言， <span class="inline-code" id="1162768069#-fik7fc_27">pass-value-by-reference-to-const</span>往往更好。</p></li><li class="list-item" id="1162768069#-fik7fc_13"><p id="1162768069#-fik7fc_28"><span class="emphasis" id="1162768069#-fik7fc_29">Template C++</span> ，泛型编程(<span class="emphasis" id="1162768069#-fik7fc_30">generic programming</span> )是C++重要的一部分。</p></li><li class="list-item" id="1162768069#-fik7fc_14"><p id="1162768069#-fik7fc_31"><span class="emphasis" id="1162768069#-fik7fc_32">STL</span> ，C++中的标准模板库。  但在Template，STL中迭代器(iterator)和函数对象都是在C的指针上进行构建的。</p></li></ol><p id="1162768069#-fik7fc_9">总结：在C++中对于不同部分的实现根据其特性采用不同的方法。</p></section><section><h2 id="1162768069#2-const-enum-inline-define" data-toc="2-const-enum-inline-define#第一章-让自己习惯C.md-2-const-enum-inline-define">条款2：尽量以 const, enum, inline 替换 #define</h2><p id="1162768069#-fik7fc_35">在声明常量时尽量使用 <span class="inline-code" id="1162768069#-fik7fc_52">const, enum</span>, 声明函数时尽量使用 <span class="inline-code" id="1162768069#-fik7fc_53">inline</span>, 而不是<span class="inline-code" id="1162768069#-fik7fc_54">define</span> (在头文件中)。  对于 <span class="inline-code" id="1162768069#-fik7fc_56">define</span> 而言，在定义常量时，该及其名称会被覆盖，所以当 <span class="emphasis" id="1162768069#-fik7fc_57">debug</span> 时，不易发现这些关于这些常量的错误。  简而言之，在定义常量时：  将<span class="inline-code" id="1162768069#-fik7fc_60">define _TIME 30</span> 替换成<span class="inline-code" id="1162768069#-fik7fc_62">const int _Time = 30;</span>以避免上述情况。  此外，在这种情况下，使用 define 也会对性能产生一定影响(可以忽略不计)。  在声明常量时替换#define的两种情况：</p><ol class="list list-decimal" id="1162768069#-fik7fc_36" type="1" start="1"><li class="list-item" id="1162768069#-fik7fc_65"><p>常量指针(<span class="emphasis" id="1162768069#-fik7fc_67">constant pointers</span>) </p><p> 定义一个常量的 <span class="emphasis" id="1162768069#-fik7fc_69">char*-based</span> 字符串： <span class="inline-code" id="1162768069#-fik7fc_70">const char* const Name = &quot;You Wenfei&quot;</span></p></li><li class="list-item" id="1162768069#-fik7fc_66"><p>类(class)的成员变量(<span class="emphasis" id="1162768069#-fik7fc_71">member</span>) </p><p> 定义一个唯一的成员变量</p></li></ol><div class="detached code-block" id="1162768069#-fik7fc_37"><pre><code class="language-cpp">class GamePlayer{
private:
    static const int NumTurns = 5;  // 常量声明式(赋值)
    static const int _NumTurns;     // 常量定义式(未赋值)
    int scores[NumTurns];           // 使用该常量，此处声明的是一个静态数组
    /* static const 类型的变量必须在声明时就被赋值 */ 
};
const int GamePlayer NumTurns;      // 此处NumTurns已被赋值
const int GamePlayer::_NumTurns = 4;// 此方法也可行</code></pre></div><p id="1162768069#-fik7fc_38">By the way， <span class="inline-code" id="1162768069#-fik7fc_73">#define</span>不能用来定义<span class="inline-code" id="1162768069#-fik7fc_74">class</span>成员常量，也不具备封装性，例如： <span class="inline-code" id="1162768069#-fik7fc_75">private #define</span> 是不可行的。</p><p id="1162768069#-fik7fc_39">现在，谈谈<span class="inline-code" id="1162768069#-fik7fc_76">enum</span> ，对于<span class="inline-code" id="1162768069#-fik7fc_77">int scores[NumTurns]</span>利用<span class="inline-code" id="1162768069#-fik7fc_78">enum</span>来替代<span class="inline-code" id="1162768069#-fik7fc_79">static const</span>来获得同样的效果。</p><div class="detached code-block" id="1162768069#-fik7fc_40"><pre><code class="language-cpp">class GamePlayer{
private:
    enum { NumTurns = 5 };           // enum hack
    int scores[NumTurns];            // 与上面的效果相同 
};</code></pre></div><p id="1162768069#-fik7fc_41"><span class="emphasis" id="1162768069#-fik7fc_80">enum hack</span>的特点更像<span class="inline-code" id="1162768069#-fik7fc_81">#define</span>而不是<span class="inline-code" id="1162768069#-fik7fc_82">const</span>， <span class="emphasis" id="1162768069#-fik7fc_83">enum hack</span>中的变量并没有地址，因此无法对 这些变量进行取指针和取引用的操作，这是<span class="inline-code" id="1162768069#-fik7fc_84">const</span>无法实现的， <span class="inline-code" id="1162768069#-fik7fc_85">enum</span>和<span class="inline-code" id="1162768069#-fik7fc_86">#define</span>也不会导致额外的内存分配(一般而言，编译器不会为内置类型的<span class="inline-code" id="1162768069#-fik7fc_87">const</span> 对象设定额外的存储空间，除非有一个<span class="emphasis" id="1162768069#-fik7fc_88">pointer</span>或<span class="emphasis" id="1162768069#-fik7fc_89">reference</span>指向该对象)。</p><p id="1162768069#-fik7fc_42">关于#define的其他误用情况：  利用#define实现宏(macro)，宏看起来像函数，但在使用时不会产生函数调用(function call)的开销，例：</p><div class="detached code-block" id="1162768069#-fik7fc_43"><pre><code class="language-cpp">/* #define a macro with parameters that call function f() */
#define CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b))
void f(int a) { std::cout &lt;&lt; a &lt;&lt; '\n'; }
/* disadvantages list 
 * 1. 无法保证传入的参数a，b相同
 * 2. 传入的a，b可能是表达式，增加了不确定性
 * 3. namespace(命名空间)污染
 * 4. 可读性差，debug麻烦 
 */</code></pre></div><p id="1162768069#-fik7fc_44">关于#define实现macro的奇怪事情：</p><div class="detached code-block" id="1162768069#-fik7fc_45"><pre><code class="language-cpp">int a = 5, b = 0;   // define 核算=_=
CALL_WITH_MAX(++a, b);  // 输出： a：7 b：0 -&gt; 累加两次
std::cout &lt;&lt; &quot;&lt;-max a: &quot; &lt;&lt; a &lt;&lt; &quot;, b: &quot; &lt;&lt; b &lt;&lt; '\n';
CALL_WITH_MAX(++a, b + 10); // 输出： a：8 b：10 -&gt; 累加一次
std::cout &lt;&lt; &quot;&lt;-max a: &quot; &lt;&lt; a &lt;&lt; &quot;, b: &quot; &lt;&lt; b &lt;&lt; '\n';</code></pre></div><p id="1162768069#-fik7fc_46">为了避免这种情况发生，可以用<span class="emphasis" id="1162768069#-fik7fc_91">template <span class="control" id="1162768069#-fik7fc_92">inline</span></span>函数进行替代：</p><div class="detached code-block" id="1162768069#-fik7fc_47"><pre><code class="language-cpp">template&lt;typename T&gt;    // 对任意类型作用
inline void max(const T&amp; a, const T&amp; b) { f(a &gt; b ? a : b); }
void f(int a) { std::cout &lt;&lt; a &lt;&lt; '\n'; }</code></pre></div><p id="1162768069#-fik7fc_48">总结：</p><ol class="list list-decimal" id="1162768069#-fik7fc_49" type="1" start="1"><li class="list-item" id="1162768069#-fik7fc_93"><p>对于单<span class="control" id="1162768069#-fik7fc_95">纯常量</span> ，用<span class="inline-code" id="1162768069#-fik7fc_96">const</span>和enum替换<span class="inline-code" id="1162768069#-fik7fc_97">#define</span></p></li><li class="list-item" id="1162768069#-fik7fc_94"><p>对于<span class="control" id="1162768069#-fik7fc_98">类似函数形式的宏</span> ，用<span class="inline-code" id="1162768069#-fik7fc_99">inline</span>函数替换<span class="inline-code" id="1162768069#-fik7fc_100">#define</span></p></li></ol></section><section><h2 id="1162768069#3-const" data-toc="3-const#第一章-让自己习惯C.md-3-const">条款3：尽可能使用 const</h2><p id="1162768069#-fik7fc_101">常见const与变量组合：</p><div class="detached code-block" id="1162768069#-fik7fc_102"><pre><code class="language-cpp">char greeting[] = &quot;hello&quot;;
char* p = &quot;world&quot;;               // non-const pointer, non-const data
const char* p = &quot;greeting&quot;;      // non-const pointer, const data
char* const p  = &quot;greeting&quot;;     // const pointer, non-const data
const char* const p = &quot;greeting&quot;;// const pointer, const data</code></pre></div><p id="1162768069#-fik7fc_103">const的声明位置决定了它的作用：</p><ol class="list list-decimal" id="1162768069#-fik7fc_104" type="1" start="1"><li class="list-item" id="1162768069#-fik7fc_145"><p><span class="inline-code" id="1162768069#-fik7fc_147">const</span>声明在<span class="inline-code" id="1162768069#-fik7fc_148">*</span>之<span class="control" id="1162768069#-fik7fc_149">前</span> ，用来修饰<span class="control" id="1162768069#-fik7fc_150">值(data)</span>。</p></li><li class="list-item" id="1162768069#-fik7fc_146"><p><span class="inline-code" id="1162768069#-fik7fc_151">const</span>声明在<span class="inline-code" id="1162768069#-fik7fc_152">*</span>之<span class="control" id="1162768069#-fik7fc_153">后</span> ，用来修饰<span class="control" id="1162768069#-fik7fc_154">指针(pointer)</span>。</p></li></ol><p id="1162768069#-fik7fc_105">关于STL和const 声明<span class="inline-code" id="1162768069#-fik7fc_155">iterator</span>为<span class="inline-code" id="1162768069#-fik7fc_156">const</span>等价于声明<span class="inline-code" id="1162768069#-fik7fc_157">pointer</span>为<span class="inline-code" id="1162768069#-fik7fc_158">const</span> ，使<span class="inline-code" id="1162768069#-fik7fc_159">iterator</span>指向一个固定的对象。  如果想让迭代器指向一个固定的对象，则需要的是<span class="inline-code" id="1162768069#-fik7fc_161">const_iterator</span>：</p><div class="detached code-block" id="1162768069#-fik7fc_106"><pre><code class="language-cpp">std::vector&lt;int&gt; vec;
/* iter的作用：T* const */
const std::vector&lt;int&gt;::iterator iter = vec.begin();
*iter = 10; // 修改iter所指向的对象的值，可行
++iter;     // 修改iter所指向的对象，不可行
/* cIter的作用：const T* */
std::vector&lt;int&gt;::const_iterator cIter = vec.begin();
*cIter = 10;// 修改cIter所指的对象的值，不可行
++cIter;    // 修改cIter所指的对象，可行</code></pre></div><p id="1162768069#-fik7fc_107">关于函数的返回值和<span class="inline-code" id="1162768069#-fik7fc_162">const</span></p><div class="detached code-block" id="1162768069#-fik7fc_108"><pre><code class="language-cpp">class Rational { ... };
const Rational operator* (const Rational&amp; lhs, const Rational&amp; rhs);</code></pre></div><p id="1162768069#-fik7fc_109">将一个函数的返回值声明为<span class="inline-code" id="1162768069#-fik7fc_163">const</span> ，可以避免如下的情况发生：</p><div class="detached code-block" id="1162768069#-fik7fc_110"><pre><code class="language-cpp">Rational a, b, c;
if(a * b = c);
/* 除非此处重载了操作符 operator=
 * Rational operator(const Rational&amp; a, const Rational&amp; b) 
 */</code></pre></div><p id="1162768069#-fik7fc_111">让<span class="inline-code" id="1162768069#-fik7fc_164">a*b</span>的返回值为<span class="inline-code" id="1162768069#-fik7fc_165">const</span> ，一个<span class="emphasis" id="1162768069#-fik7fc_166">non-const</span>类型的变量无法赋值给<span class="emphasis" id="1162768069#-fik7fc_167">const</span>类型的变量， 使<span class="inline-code" id="1162768069#-fik7fc_168">a*b = c</span>这个表达式无法执行。</p><p id="1162768069#-fik7fc_112"><span class="inline-code" id="1162768069#-fik7fc_169">const</span>型成员变量</p><div class="detached code-block" id="1162768069#-fik7fc_113"><pre><code class="language-cpp">class TextBlock{
public: 
    const char&amp; operator[] (std::size_t position) const {
        return text[position];  // operator for const 对象
    }
    char&amp; operator[] (std::size_t position){
        return text[position];  // operator for non-const 对象
    }
private:
    std::string text;
};</code></pre></div><p id="1162768069#-fik7fc_114">示例1： <span class="inline-code" id="1162768069#-fik7fc_170">TextBlock</span>类中针对<span class="inline-code" id="1162768069#-fik7fc_171">const</span>和<span class="inline-code" id="1162768069#-fik7fc_172">non-const</span>类型的对象进行了<span class="inline-code" id="1162768069#-fik7fc_173">[]</span>操作的重载。</p><div class="detached code-block" id="1162768069#-fik7fc_115"><pre><code class="language-cpp">TextBlock tb(&quot;Hello&quot;);
std::cout &lt;&lt; tb[0]; // 调用 non-const TextBlock::operator[]
const TextBlock ctb(&quot;World&quot;); // 调用 function const TextBlock::operator[]
std::cout &lt;&lt; tb[0];</code></pre></div><p id="1162768069#-fik7fc_116">示例2：</p><div class="detached code-block" id="1162768069#-fik7fc_117"><pre><code class="language-cpp">// 调用 const TextBlock::operator[]
void print(const TextBlock&amp; ctb){ std::cout &lt;&lt; ctb[0]; }</code></pre></div><p id="1162768069#-fik7fc_118">上述代码中对<span class="inline-code" id="1162768069#-fik7fc_174">operator[]</span>进行了重载，因此它可<span class="inline-code" id="1162768069#-fik7fc_175">const</span>和<span class="inline-code" id="1162768069#-fik7fc_176">non-const</span>的<span class="inline-code" id="1162768069#-fik7fc_177">TextBlock</span>进行不同的处理：</p><div class="detached code-block" id="1162768069#-fik7fc_119"><pre><code class="language-cpp">std::cout &lt;&lt; tb[0]; // 可行，读一个non-const TextBlock
tb[0] = 'x';        // 可行，写一个non-const TextBlock
std::cout &lt;&lt; cbt[0];// 可行，读一个const TextBlock
ctb[0] = 'x';       // 不可行，写一个const TextBlock

/* 因为ctb实例是const类型，调用[]操作时，返回的是一个const char&amp;类型
 * 因此对一个const类型的TextBlock实例进行赋值
 * ctb[0] = 'x'; 这个操作不可行
 */</code></pre></div><p id="1162768069#-fik7fc_120">注❗❗❗：</p><div class="detached code-block" id="1162768069#-fik7fc_121"><pre><code class="language-cpp">/* 上面的operator[]的返回类型是reference to char */
tb[0] = 'x'; // 这个语句才成立
/* tb[0]本身是存储的一个地址，故返回一个引用值(地址)是合理的 */</code></pre></div><p id="1162768069#-fik7fc_122">对比一下返回值为<span class="emphasis" id="1162768069#-fik7fc_178">reference to char</span>和<span class="emphasis" id="1162768069#-fik7fc_179">pointer to char</span>的区别</p><ol class="list list-decimal" id="1162768069#-fik7fc_123" type="1" start="1"><li class="list-item" id="1162768069#-fik7fc_180"><p>返回值为<span class="emphasis" id="1162768069#-fik7fc_181">reference to char</span></p></li></ol><div class="detached code-block" id="1162768069#-fik7fc_124"><pre><code class="language-cpp">class TextBlock {
public:
	TextBlock(const std::string&amp; s) :text(s) {}
	const char&amp; operator[] (std::size_t position) const {
		return text[position + 1];  // operator for const 对象
	}
	char&amp; operator[] (std::size_t position) {
		return text[position];  // operator for non-const 对象
	}
private:
	std::string text;
};

    TextBlock t1(&quot;abcdef&quot;);
	const TextBlock t2(&quot;abcdef&quot;);
	std::cout &lt;&lt; t1[1] &lt;&lt; '\n';
	std::cout &lt;&lt; t2[1] &lt;&lt; '\n';

    输出：
    b
    c</code></pre></div><ol class="list list-decimal" id="1162768069#-fik7fc_125" type="1" start="2"><li class="list-item" id="1162768069#-fik7fc_182"><p>返回值为<span class="emphasis" id="1162768069#-fik7fc_183">pointer to char</span></p></li></ol><div class="detached code-block" id="1162768069#-fik7fc_126"><pre><code class="language-cpp">class TextBlock {
public:
	TextBlock(const std::string&amp; s) :text(s) {}
	const char* operator[] (std::size_t position) const {
		return &amp;text[position + 1];  // operator for const 对象
	}
	char* operator[] (std::size_t position) {
		return &amp;text[position];  // operator for non-const 对象
	}
private:
	std::string text;
};

	TextBlock t1(&quot;abcdef&quot;);
	const TextBlock t2(&quot;abcdef&quot;);
	std::cout &lt;&lt; t1[1] &lt;&lt; '\n';
	std::cout &lt;&lt; t2[1] &lt;&lt; '\n';
	
	输出：
	bcdef
	cdef</code></pre></div><p id="1162768069#-fik7fc_127">综上可知，返回值为<span class="emphasis" id="1162768069#-fik7fc_184">reference to char</span>时，返回的是字符串<span class="inline-code" id="1162768069#-fik7fc_185">text</span>中的一个字符， 即<span class="emphasis" id="1162768069#-fik7fc_186">reference</span>仅指向<span class="inline-code" id="1162768069#-fik7fc_187">text</span>中的单一成员；返回值为<span class="emphasis" id="1162768069#-fik7fc_188">pointer to char</span>时，返回的 是<span class="inline-code" id="1162768069#-fik7fc_189">text</span>中的一个子串，即以该指针为首的子串。</p><p id="1162768069#-fik7fc_128">再看如下示例：</p><div class="detached code-block" id="1162768069#-fik7fc_129"><pre><code class="language-cpp">class CTextBlock{
public:
    char&amp; operator[](std::size_t position) const{
        return pText[position];
    }
private:
    char* pText;
};

    const CTextBlock cctb(&quot;Hello&quot;);
    char* pc = &amp;cctb[0];            // 指针pc指向pText字符串的第一个字符
    *pc = 'J';                      // 对pText字符串的第一个字符进行修改
    /* pText = &quot;Jello&quot; */</code></pre></div><p id="1162768069#-fik7fc_130">此处， <span class="inline-code" id="1162768069#-fik7fc_190">operator[]</span>并不修改成员的值，但是<span class="inline-code" id="1162768069#-fik7fc_191">*pc = 'J'</span> ;间接的修改了成员变量。 故此处对<span class="inline-code" id="1162768069#-fik7fc_192">operator[]</span>声明的<span class="inline-code" id="1162768069#-fik7fc_193">const</span>没有意义。在实际编写代码的过程中也是不现实的。</p><p id="1162768069#-fik7fc_131"><span class="inline-code" id="1162768069#-fik7fc_194">mutable</span> 与 <span class="inline-code" id="1162768069#-fik7fc_195">const</span> 无<span class="inline-code" id="1162768069#-fik7fc_197">mutable</span></p><div class="detached code-block" id="1162768069#-fik7fc_132"><pre><code class="language-cpp">class CTextBlock
{
public:
    std::size_t length() const;
private:
    char* pText;
    std::size_t textLength;
    bool lengthIsValid;
};

std::size_t CTextBlock::length() const      // const 限定
{
    if(!lengthIsValid)
    {
        textLength = std::strlen(pText);    // 不可行
        lengthIsValid = true;               // 不可行
    }
    return textLength;
}</code></pre></div><p id="1162768069#-fik7fc_133">被<span class="inline-code" id="1162768069#-fik7fc_198">const</span>限定的函数，无法对成员变量进行修改。</p><p id="1162768069#-fik7fc_134">有<span class="inline-code" id="1162768069#-fik7fc_199">mutable</span></p><div class="detached code-block" id="1162768069#-fik7fc_135"><pre><code class="language-cpp">class CTextBlock
{
public:
	std::size_t length() const;
private:
	char* pText;
	mutable std::size_t textLength;
	mutable bool lengthIsValid;
};

std::size_t CTextBlock::length() const      // const 限定
{
	if(!lengthIsValid)
	{
		textLength = std::strlen(pText);    // 可行
		lengthIsValid = true;               // 可行
	}
	return textLength;
}</code></pre></div><p id="1162768069#-fik7fc_136">被<span class="inline-code" id="1162768069#-fik7fc_200">mutable</span>修饰的成员变量，即使在被<span class="inline-code" id="1162768069#-fik7fc_201">const</span>限定的函数内也可被修改。</p><p id="1162768069#-fik7fc_137">常量性转除(<span class="emphasis" id="1162768069#-fik7fc_202">casting away constness</span>)  在某些情况下可能需要对一些被<span class="inline-code" id="1162768069#-fik7fc_204">const</span>限定的(成员)变量进行修改，此时就需要对这些变量 进行<span class="control" id="1162768069#-fik7fc_205">常量性转除</span>操作。 示例1：</p><div class="detached code-block" id="1162768069#-fik7fc_138"><pre><code class="language-cpp">const int i_ = 23;
const int * pi_ = &amp;i_;

int* non_pi_ = const_cast&lt;int*&gt;(pi_);   // 常量性转除
*non_pi_ = 233;</code></pre></div><p id="1162768069#-fik7fc_139">示例2：</p><div class="detached code-block" id="1162768069#-fik7fc_140"><pre><code class="language-cpp">class TextBlock
{
public:
    const char&amp; operator[] (std::size_t position) const
    {
        return Text[position];
    }

	char&amp; operator[] (std::size_t position)
	{
		return const_cast&lt;char&amp;&gt;        // 要被常量性转除的变量类型为char&amp; 
		(static_cast&lt;const TextBlock&amp;&gt;  // 将返回类型强制转换为const TextBlock&amp;  
		(*this)[position]);             // 以调用 const operator[]
		/* 输出：
		       c
		       b
         */
		
		/* 关于此处常量性转除的另一种写法 
		 * return const_cast&lt;char&amp;&gt;
		 * (static_cast&lt;const TextBlock&amp;&gt;
		 * (*this).Text[position]);     // 错误写法
		 * 直接返回Text中索引为1处的字符
		 * 输出：
		 *     b
		 *     b
		 */
		 
		/* 错误写法 
		 * return const_cast&lt;char&amp;&gt;
		 * (static_cast&lt;const TextBlock&amp;&gt;
		 *  Text[position]);            // 另一种错误写法
		 */
	}
private:
    std::string Text;
};</code></pre></div><p id="1162768069#-fik7fc_141">在上面代码中，添加了一个<span class="inline-code" id="1162768069#-fik7fc_206">static_cast</span>的操作，作用是将<span class="inline-code" id="1162768069#-fik7fc_207">operator[]</span>转成<span class="inline-code" id="1162768069#-fik7fc_208">const operator[]</span>， 这样可以在执行到此处时调用<span class="inline-code" id="1162768069#-fik7fc_209">const operator[]</span>而不是<span class="inline-code" id="1162768069#-fik7fc_210">operator[]</span> ，即它自身，因为这样会导致 它自己调用自己而产生<span class="control" id="1162768069#-fik7fc_211">无限递归</span>。</p><p id="1162768069#-fik7fc_142">所以，想要在<span class="inline-code" id="1162768069#-fik7fc_212">const</span>限定的成员函数内调用<span class="inline-code" id="1162768069#-fik7fc_213">non-const</span>成员函数对成员变量进行修改， 就需要用到常量性转除<span class="inline-code" id="1162768069#-fik7fc_214">const_cast</span>方法进行实现。在<span class="inline-code" id="1162768069#-fik7fc_215">non-const</span>成员函数内调用被<span class="inline-code" id="1162768069#-fik7fc_216">const</span>限定的成员函数是正确可行的。</p><p id="1162768069#-fik7fc_143">总结：</p><ol class="list list-decimal" id="1162768069#-fik7fc_144" type="1" start="1"><li class="list-item" id="1162768069#-fik7fc_217"><p>给变量添加<span class="emphasis" id="1162768069#-fik7fc_220">const</span>修饰符可以让编译器帮你找出错误。</p></li><li class="list-item" id="1162768069#-fik7fc_218"><p>编译器对于<span class="emphasis" id="1162768069#-fik7fc_221">const</span>使用很严格，所以在使用时也要注意。</p></li><li class="list-item" id="1162768069#-fik7fc_219"><p>当<span class="emphasis" id="1162768069#-fik7fc_222">const</span>和<span class="emphasis" id="1162768069#-fik7fc_223">non-const</span>成员函数实现的功能相同时，在<span class="emphasis" id="1162768069#-fik7fc_224">non-const</span>函数中调用<span class="emphasis" id="1162768069#-fik7fc_225">const</span>函数可以避免代码重复。</p></li></ol></section><section><h2 id="1162768069#4" data-toc="4#第一章-让自己习惯C.md-4">条款4：确定对象被使用前已先被初始化</h2><p id="1162768069#-fik7fc_226">在C++中，变量如果只被声明而未被赋初值，可能会带来很多不必要的麻烦。 即使这些未被赋初值的变量可能会被默认赋值，但不一定在所有的情况下都是这样。</p><div class="detached code-block" id="1162768069#-fik7fc_227"><pre><code class="language-cpp">double x; x = 3.3f;
double x = 3.3f;
double x; std::cin &gt;&gt; x;
/* and so on... */</code></pre></div><p id="1162768069#-fik7fc_228">当然，这些都只是都内置类型的初始化，对自定义的类中的变量也需要进行初始化， 就是类中常有的构造函数。</p><p id="1162768069#-fik7fc_229">关于类成员的初始化的构造函数主要有如下两种：</p><ol class="list list-decimal" id="1162768069#-fik7fc_230" type="1" start="1"><li class="list-item" id="1162768069#-fik7fc_256"><p>在构造函数的实现部分进行<span class="control" id="1162768069#-fik7fc_258">赋值</span></p></li><li class="list-item" id="1162768069#-fik7fc_257"><p>利用成员初值列进行<span class="control" id="1162768069#-fik7fc_259">初始化</span></p></li></ol><p id="1162768069#-fik7fc_231">赋值：在构造函数内部进行赋值，这种操作不是初始化</p><div class="detached code-block" id="1162768069#-fik7fc_232"><pre><code class="language-cpp">class PhoneNumber { ... };
class ABEntry{
public: 
    ABEntry(const std::string&amp; name, 
            const std::string&amp; address, 
            const std::list&lt;PhoneNumber&gt;&amp; phones);
private:
    std::string theName;
    std::string theAddress;
    std::list&lt;PhoneNumber&gt; thePhones;
    int numTimesConsulted;
};

ABEntry::ABEntry(const std::string&amp; name, 
                 const std::string&amp; address, 
                 const std::list&lt;PhoneNumber&gt;&amp; phones){
    theName = name;
    theAddress = address;                 
    thePhones = phone;
    numTimesConsulted = 0;
}</code></pre></div><p id="1162768069#-fik7fc_233">初始化：利用成员初值列对成员变量进行初始化</p><div class="detached code-block" id="1162768069#-fik7fc_234"><pre><code class="language-cpp">ABEntry::ABEntry(const std::string&amp; name, 
                 const std::string&amp; address, 
                 const std::list&lt;PhoneNumber&gt;&amp; phones):
                 theName(name),         // 拷贝构造
                 theAddress(address),   // 拷贝构造
                 thePhones(phones),     // 拷贝构造
                 numTimeConsulted(0){}</code></pre></div><p id="1162768069#-fik7fc_235">利用成员初值列对成员变量进行初始化的效率较高，此种方法调用的是default(默认)构造函数。  然而利用赋值的方法对成员变量进行赋值也会调用default构造函数，但这时的default构造函数没有发挥任何作用。</p><p id="1162768069#-fik7fc_236">无参构造：</p><div class="detached code-block" id="1162768069#-fik7fc_237"><pre><code class="language-cpp">ABEntry::ABEntry()
                 theName(),         // theName的默认构造
                 theAddress(),      // theAddress的默认构造
                 thePhones(),       // thePhones的默认构造
                 numTimeConsulted(0)// 显示声明numTimeConsulted的值为0
                 {}</code></pre></div><p id="1162768069#-fik7fc_238"><span class="control" id="1162768069#-fik7fc_261">注❗❗❗</span>： 在编写成员初值列时，总是列出所有的成员变量，以免给自己带来不必要的麻烦。 对于const或reference类型的变量，它们一定得出现在成员初值列中(初始化)，而不允许被赋值。</p><p id="1162768069#-fik7fc_239">例如：  这种赋值类型的构造就不可行</p><div class="detached code-block" id="1162768069#-fik7fc_240"><pre><code class="language-cpp">class test
{
public:
	test(const int m, const int* n);
private:
	const int t1;
	const int*  b;
};

test::test(const int m, const int* n)
{
	t1 = m;
	b = n;
}</code></pre></div><p id="1162768069#-fik7fc_241">只能用成员初值列的构造方式对成员变量进行赋值</p><div class="detached code-block" id="1162768069#-fik7fc_242"><pre><code class="language-cpp">class test
{
public:
	test(const int m, const int* n) :t1(m), b(n) {}
private:
	const int t1;
	const int* b;
};</code></pre></div><p id="1162768069#-fik7fc_243">static对象：</p><ol class="list list-decimal" id="1162768069#-fik7fc_244" type="1" start="1"><li class="list-item" id="1162768069#-fik7fc_263"><p>global对象</p></li><li class="list-item" id="1162768069#-fik7fc_264"><p>定义与namespace作用域内的对象</p></li><li class="list-item" id="1162768069#-fik7fc_265"><p>在class内</p></li><li class="list-item" id="1162768069#-fik7fc_266"><p>在函数内</p></li><li class="list-item" id="1162768069#-fik7fc_267"><p>在file作用域内被声明为static类型的对象</p></li></ol><p id="1162768069#-fik7fc_245">这些对象通过调用自身的析构函数来自动销毁。</p><p id="1162768069#-fik7fc_246">例如对于一个在线文件管理系统：</p><div class="detached code-block" id="1162768069#-fik7fc_247"><pre><code class="language-cpp">class FileSystem{
public:
    std::size_t numDisks() const;
};
extern FileSystem tfs;  // declare a global instance

/* 在另一个文件定义的对象 */
class Directory{
public:
    Directory ( parameter... );
};
Directory::Directory( parameter... ){
    std::size_t disks = tfs.numDisks(); // 使用tfs对象
}

/* 在另一个文件内的对象 */
/* Directory对象的实例化 */
Directory tempDir( parameters... );     // 使用tfs对象</code></pre></div><p id="1162768069#-fik7fc_248">为确保上述功能执行顺利，就要在<span class="inline-code" id="1162768069#-fik7fc_268">tfs</span>被调用之前将<span class="inline-code" id="1162768069#-fik7fc_269">tfs</span>初始化，否则会给自己带来很多不必要的麻烦。</p><p id="1162768069#-fik7fc_249">解决该方法的另一种思路，将别的文件内的对象复制到需要调用该函数的地方，并声明为<span class="inline-code" id="1162768069#-fik7fc_270">static</span>， 该函数返回一个指向该对象的一个<span class="emphasis" id="1162768069#-fik7fc_271">reference</span> ，然后调用这个函数，这样保证了所使用的对象是被初始化了的。 例如：</p><div class="detached code-block" id="1162768069#-fik7fc_250"><pre><code class="language-cpp">class FileSystem ( ... );
FileSystem&amp; tfs(){          // 这个函数用来替换 tfs 对象，
    static FileSystem fs;   // 定义并初始化一个local static 对象
    return fs;              // 返回一个 reference 指向上述对象
}
class Directory ( ... );
Directory::Directory ( parameters ){
    std::size_t disks = tfs().numDisks();   // 将原来的 reference to tfs 对象
}                                           // 替换为现在的 tfs()
Directory&amp; tempDir(){       // 这个函数用来替换 tempDir 对象
    static Directory td;    // 定义并初始化一个local static 对象
    return td;              // 返回一个 reference 指向上述对象
}</code></pre></div><p id="1162768069#-fik7fc_251">这种处理方式中的函数简单易用，但也有不足的地方： 在多线程环境下，这种操作会带来不确定性，解决方法之一就是在单线程启动阶段(<span class="emphasis" id="1162768069#-fik7fc_272">single-threaded startup portion</span>) 手动调用所有<span class="emphasis" id="1162768069#-fik7fc_273">reference-returning</span>函数，这种做法可以避免与初始化相关的线程竞争(<span class="emphasis" id="1162768069#-fik7fc_274">race conditions</span> )的情况。</p><p id="1162768069#-fik7fc_252">但最重要的一点是，在使用<span class="emphasis" id="1162768069#-fik7fc_275">local static</span>这种解决方法的过程中，应该有一个合理的对象初始化次序，简而言之：</p><ol class="list list-decimal" id="1162768069#-fik7fc_253" type="1" start="1"><li class="list-item" id="1162768069#-fik7fc_276"><p>手动初始化内置类型对象</p></li><li class="list-item" id="1162768069#-fik7fc_277"><p>使用成员初值列对各个成员变量进行初始化</p></li><li class="list-item" id="1162768069#-fik7fc_278"><p>仔细考虑对象初始化的先后顺序</p></li></ol><p id="1162768069#-fik7fc_254">总结：</p><ol class="list list-decimal" id="1162768069#-fik7fc_255" type="1" start="1"><li class="list-item" id="1162768069#-fik7fc_279"><p>为内置类型对象手动初始化。</p></li><li class="list-item" id="1162768069#-fik7fc_280"><p>使用成员初值列对各个内置类型成员变量进行初始化而不要函数内对各个成员变量进行赋值。</p></li><li class="list-item" id="1162768069#-fik7fc_281"><p>若想跨文件进行初始化，使用<span class="emphasis" id="1162768069#-fik7fc_282">local static</span>替换<span class="emphasis" id="1162768069#-fik7fc_283">non-local static</span>对象这种做法最为妥当。</p></li></ol></section></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="1706899533">第二章 构造/析构/赋值运算</h1><section><h2 id="1706899533#5-c" data-toc="5-c#第二章-构造-析构-赋值运算.md-5-c">条款5：了解 C++ 默默编写并调用那些函数</h2><p id="1706899533#z343d28_11">当定义了一个没有构造函数（constructor)、析构函数(destructor)和拷贝构造函数(copy assignment)的类， 在编译期间， 编译器会为这个类生成默认(default)的构造函数、析构函数和拷贝构造函数，且是public和inline。</p><p id="1706899533#z343d28_12">例如：  定义了一个空类</p><div class="detached code-block" id="1706899533#z343d28_13"><pre><code class="language-cpp">class Empty { };</code></pre></div><p id="1706899533#z343d28_14">在编译后就成了如下的类：</p><div class="detached code-block" id="1706899533#z343d28_15"><pre><code class="language-cpp">class Empty(){
public:
    Empty() { ... }                     // default 构造函数
    Empty (const Empty&amp; rhs) { ... }    // default 拷贝构造函数
    ~Empty() { ... }                    // default 析构(non-virtual)函数

    Empty&amp; operator=(const Empty&amp; rhs) { ... }  // 重载拷贝赋值操 作符
};</code></pre></div><p id="1706899533#z343d28_16">只有当这些函数被被调用时它们才被编译器实现：</p><div class="detached code-block" id="1706899533#z343d28_17"><pre><code class="language-cpp">Empty e1;       // default 构造函数
Empty e2(e1);   // 拷贝构造函数
e2 = e1;        // 拷贝赋值函数
                // 析构函数</code></pre></div><p id="1706899533#z343d28_18">对于拷贝构造和赋值运算而言，编译器为此所实现的功能仅仅是将源对象的每一个non-static成员复制到目标对象。</p><div class="detached code-block" id="1706899533#z343d28_19"><pre><code class="language-cpp">template&lt;typename T&gt;
class Test{
public:
    Test(const char* val_, const T&amp; val_t){}
    Test(const std::string&amp; val_, const T&amp; val_t){}
private:
    std::string val;
    T val_T;
};</code></pre></div><p id="1706899533#z343d28_20">上面的Test类中已经声明了一个或多个构造函数，因此编译器将不再为它生成default构造函数。  然后Test类中只声明了构造函数，还有copy构造没有实现和copy assignment没有重载及析构函数没有实现，因此编译器会自动实现这些函数。</p><div class="detached code-block" id="1706899533#z343d28_21"><pre><code class="language-cpp">Test&lt;int&gt; t(&quot;ppqwqqq&quot;, 12);
Test&lt;int&gt; t_(t);    // 调用拷贝构造</code></pre></div><p id="1706899533#z343d28_22">在Test类的对象<span class="inline-code" id="1706899533#z343d28_33">t(Test&lt;int&gt;)</span>中成员变量有std::string类型的val和int类型的val_T,在将t复制给t_时，具体赋值流程如下：</p><ul class="list" id="1706899533#z343d28_23" start="1"><li class="list-item" id="1706899533#z343d28_34"><p>对于val(std::string类型)，调用std::string类中的copy构造，来对t_进行赋值</p></li><li class="list-item" id="1706899533#z343d28_35"><p>对于val_t(T-&gt;int，int为内置类型)，对t中val_T的值的每一个bit进行复制，并赋值给t_的val_T</p></li></ul><p id="1706899533#z343d28_24">编译器自己生成的copy assignment重载函数必须合法才能使用</p><div class="detached code-block" id="1706899533#z343d28_25"><pre><code class="language-cpp">template&lt;typename T&gt;
class T1{
public:
    // 此处的构造函数接受一个reference to non-const std::string类型的参数
    // 和const T&amp;类型的参数
    T1(std::string&amp; str_, const T&amp; val_): str(str_), val(val_){}
private:
    std::string&amp; str;
    const T val;
};

    std::string text_1{&quot;Text1&quot; };
    std::string text_2{&quot;Text2&quot; };
    T1&lt;int&gt; t1(text_1, 123);
    T1&lt;int&gt; t2(text_2, 456);
    t1 = t2;</code></pre></div><p id="1706899533#z343d28_26">关于t1=t2，进行如下讨论：</p><ul class="list" id="1706899533#z343d28_27" start="1"><li class="list-item" id="1706899533#z343d28_36"><p>对t1赋值之前，t1.str和t2.str都指向各自的string对象</p></li><li class="list-item" id="1706899533#z343d28_37"><p>然后对于操作t1.str = t2.str而言，它不是合法的，因为str的类型为reference to string，而引用绑定一个对象后，无法再改指向其他对象。</p></li></ul><p id="1706899533#z343d28_28">因此编译器不会为t1=t2，这种含有reference的成员生成copy assignment重载函数，因此要实现t1 = t2就得需要自己实现copy assignment重载函数。 不仅是对于reference类型的成员变量如此，const类型的成员变量也一样。 对于这种情况需要自己对copy assignment重载函数进行实现：</p><div class="detached code-block" id="1706899533#z343d28_29"><pre><code class="language-cpp">T1&amp; operator=(const T1&amp; other){
    if(this != &amp;other){
        str = other.str;
        /* illgegal
         * val = other.val;
         * val is const
         */
        .....
    }
    return *this;
}</code></pre></div><p id="1706899533#z343d28_30">关于基类和子类：如果在基类中copy assignment被声明为private，那么编译器将不会为其子类生成copy assignment，因为在子类中生成的copy assignment 可以处理关于基类的成员，但是又无法访问基类中的copy assignment。</p></section><section><h2 id="1706899533#6" data-toc="6#第二章-构造-析构-赋值运算.md-6">条款6：若不想使用编译器自己生成的函数，就该明确拒绝</h2><p id="1706899533#z343d28_38">有时候，可能不想让下面这种情况发生</p><div class="detached code-block" id="1706899533#z343d28_39"><pre><code class="language-cpp">class_ c1;
class_ c2;
class_ c3(c1);
c1 = c2;</code></pre></div><p id="1706899533#z343d28_40">对于这种拷贝构造、拷贝复制等操作没有实现，且不想让它们被编译器生成，即目标是要阻止copying这种操作被调用。  首先要知道的一点是，编译器生成的函数的性质为public，若要实现上述目标可以将其声明为private，来阻止它们被调用， 但这么做并不是绝对安全的，因为friend属性的成员函数依旧可以调用private函数。 为了解决这个问题，可以将其声明为private属性的函数并不去实现它。</p><div class="detached code-block" id="1706899533#z343d28_41"><pre><code class="language-cpp">class class_{
private:
    class_ (const class_&amp;);
    class_&amp; operator=(const class_&amp;);
};</code></pre></div><p id="1706899533#z343d28_42">一般要对阻止一个类的拷贝构造和拷贝复制函数被调用时，可以让这个类继承一个base class， 在这个base class可以进行如下操作：</p><div class="detached code-block" id="1706899533#z343d28_43"><pre><code class="language-cpp">class uncopyable{
protected:
    uncopyable() {}     // 允许继承此类的对象进行构造和析构
    ~uncopyable() {}
private:
    uncopyable (const uncopyable&amp;);              // 阻止拷贝构造
    uncopyable&amp; operator=(const uncopyable&amp;);    // 阻止拷贝赋值
};

class derived_: private uncopyable{             // 此类不需要再声明拷贝构造函数和拷贝赋值函数
};</code></pre></div><p id="1706899533#z343d28_44">在进行上述声明后，如果进行下面的操作会被拒绝：</p><div class="detached code-block" id="1706899533#z343d28_45"><pre><code class="language-cpp">derived d1;
derived d2;
derived d3(d1);     // error
d2 = d1;            // error</code></pre></div><p id="1706899533#z343d28_46">总结：  不想让编译器自己生成的函数被调用，可以对此函数进行private声明并不予实现。</p></section><section><h2 id="1706899533#7-virtual" data-toc="7-virtual#第二章-构造-析构-赋值运算.md-7-virtual">条款7：为多态基类声明 virtual 析构函数</h2><p id="1706899533#z343d28_49">在使用C++的过程中，有时可能会实现如下的操作</p><div class="detached code-block" id="1706899533#z343d28_50"><pre><code class="language-cpp">class Person{ }; // 普通人
class Student:public Person{ }; // 学生
class Teacher:public Person{ }; // 教师
class Headmaster:public Person{ }; // 校长</code></pre></div><p id="1706899533#z343d28_51">现在想要实现一个函数通过基类指针获取派生类的实例，来调用派生类实例的方法，来实现其多态性</p><div class="detached code-block" id="1706899533#z343d28_52"><pre><code class="language-cpp">Person* getPerson();    // 返回一个指针，指向派生类 
                        // Person类动态分配对象</code></pre></div><p id="1706899533#z343d28_53">在C/C++中经由 malloc/new 实例化的类往往都被存放在堆上，这些实例的生命周期具有可控制性， 以至于在使用完这些实例后需要手动将其 free/delete 以避免内存泄漏：</p><div class="detached code-block" id="1706899533#z343d28_54"><pre><code class="language-cpp">Person* prs = getPerson();  // 从Person的继承体系中获取一个动态分配的对象
...
delete prs;                 // 释放prs，避免内存泄露</code></pre></div><p id="1706899533#z343d28_55">而在这其中有一个问题，其中getPerson()返回的指针指向一个继承的类对象， 然而此对象经由一个基类对象指针调用析构函数(non-virtual)而被删除。 在实际执行时会出现这样的结果：基类对象的成员被删除，而继承的类对象的自身特有部分没有被删除， 同时继承的类对象里的析构函数也未能执行起来，导致会有多余的成分没有被析构掉从而形成了内存泄露的结果。  解决这种问题的一种方法：给基类(base class)定义一个virtual析构函数，这样在调用基类的析构函数时， 同时也会调用派生类的析构函数，这样就可以删除整个对象(及所有继承及基类的成员)。</p><div class="detached code-block" id="1706899533#z343d28_56"><pre><code class="language-cpp">class Person{
public:
    Person() = defualt;
    virtual ~Person() = default;
};

class Student: public Person{
    Student() = defualt;
    virtual ~Student() = default;
};

Person* getPerson(){
    return new Student();
}

Person prs = getPerson();
delete prs;</code></pre></div><p id="1706899533#z343d28_57">一个基类(base class)将其函数定义为virtual，是为了能让其继承类(derived class)能够对此函数进行不同的实现。 任何带有virtual类型函数的类其中也对应存在一个virtual析构函数。  如果一个类中没有一个virtual函数，那么说明这个类不将会被作为一个基类。  换言之，如果不想让一个类成为基类，在其中声明virtual函数是不适当的。  此外，对于有虚函数的类，编译器会为该类创建一个虚函数表(virtual table)，每个对象会存储一个指向虚函数表的指针(virtual pointer)，  虚函数表存储了该类的虚函数的地址，因此，对内存的开销也会产生额外的负担：</p><ul class="list" id="1706899533#z343d28_58" start="1"><li class="list-item" id="1706899533#z343d28_69"><p>vptr指针的内存开销：每个对象存储一个指向虚函数表的指针：4字节(x86), 8字节(x64)</p></li><li class="list-item" id="1706899533#z343d28_70"><p>虚函数表的内存开销： </p><ul class="list" id="1706899533#z343d28_71" start="1"><li class="list-item" id="1706899533#z343d28_72"><p>虚函数的数量</p></li><li class="list-item" id="1706899533#z343d28_73"><p>类的层次结构： </p><ul class="list" id="1706899533#z343d28_75" start="1"><li class="list-item" id="1706899533#z343d28_76"><p>继承关系</p></li><li class="list-item" id="1706899533#z343d28_77"><p>虚函数重载</p></li></ul></li><li class="list-item" id="1706899533#z343d28_74"><p>多重继承</p></li></ul></li></ul><p id="1706899533#z343d28_59">总而言之，但类中有一个及以上数量的虚函数时，才为此类声明virtual类型的析构函数。</p><p id="1706899533#z343d28_60">如果想定义一个抽象基类，但是没有合适的成员函数选择，此时，可以声明一个纯虚析构函数</p><div class="detached code-block" id="1706899533#z343d28_61"><pre><code class="language-cpp">class abst_class{
public:
    virtual ~abst_class() = 0;
};</code></pre></div><p id="1706899533#z343d28_62">为基类定义一个virtual析构函数主要用于多态性质的基类， 声明一个基类的对象以调用其派生类，即通过此基类接口来处理派生类对象。 但并非所有的这样的基类(定义了virtual虚构函数的类)都是用来间接处理派生对象的， 而是纯粹作为一个抽象基类来使用，例如：STL。</p><p id="1706899533#z343d28_63">总结： 具有多态性质的基类内应该有一个virtual析构函数，在类内部具有virtual属性的成员函数的类内部也应该有virtual属性的析构函数。 如果一个类的设计初衷不是为了作为一个基类或者多态性质的基类使用，那么就不要在其中声明virtual属性的析构函数。</p></section><section><h2 id="1706899533#8" data-toc="8#第二章-构造-析构-赋值运算.md-8">条款8：别让异常逃离析构函数</h2><p id="1706899533#z343d28_78">在C++中，在析构函数中抛出异常不是一个明智之举。</p><div class="detached code-block" id="1706899533#z343d28_79"><pre><code class="language-cpp">class Widget{
  ...
  ~Widget() { ... }  /* 此处可能抛出一个异常 */
};

void func(){
  std::vector&lt;Widget&gt; v;
}                   /* v 在此处被销毁 */</code></pre></div><p id="1706899533#z343d28_80">此处vector v中的Widget将被释放，若当v[0]释放时有异常抛出，在v[1]释放时又有异常抛出， 在这种两个异常同时存在的情况下，将会导致程序调用 std::terminate 从而导致程序崩溃， 即使使用其他标准库中的容器也会导致同样的情况，这种情况在C++中是非常糟糕的。</p><p id="1706899533#z343d28_81">使用场景之一：建立数据库连接和断开数据库连接</p><div class="detached code-block" id="1706899533#z343d28_82"><pre><code class="language-cpp">class DBConnection{
public:
  ...
  static DBConncetion create();
  /* 建立数据库连接，此方法返回一个DBConnection对象 */
  
  void close();
  /* 此处断开数据库连接，断开失败则抛出异常 */
};</code></pre></div><p id="1706899533#z343d28_83">为了避免用户忘记在DBConnection对象上调用close()方法，我们可以手动实现一个DBConnection的析构函数， 在DBConnection对象的生命周期结束时，其析构函数调用close()方法。</p><div class="detached code-block" id="1706899533#z343d28_84"><pre><code class="language-cpp">/* 手动实现一个class来对DBConnection对象进行管理 */
class DBConn{
public:
  ...
  ~DBConn(){
    db.close();
  }     /* 保证在DBConnection对象的生命周期结束后
           数据库的连接总是会断开
        */
private:
  DBConnection db;
};
{
  DBConn dbc(DBConnection::create()); 
  /* 建立DBConnection对象
     通过DBConn进行管理
     通过DBConne的接口
     使用DBConnection对象
     在DBConnection对象生命周期结束时
     DBConn为DBConnection调用close()
   */
}</code></pre></div><p id="1706899533#z343d28_85">此处若close()被成功调用，那么程序仍可顺利进行，如果其抛出异常， 那么会导致一个棘手的问题，DBConnection对象中的其他成员或许无法被正常释放， 导致资源泄露，对此问题的解决办法：</p><ul class="list" id="1706899533#z343d28_86" start="1"><li class="list-item" id="1706899533#z343d28_96"><p>如果close抛出异常就结束程序，可以通过 abort 完成</p></li></ul><div class="detached code-block" id="1706899533#z343d28_87"><pre><code class="language-cpp">DBConn::~DBConn() {
  try{ db.close(); }
  catch( ... ) {
    /* 将close()抛出异常的记录写入日志文件 */
    std::abort();
  }
}</code></pre></div><p id="1706899533#z343d28_88">当close抛出异常后，为了阻止这种异常在栈展开的过程中传播出去之前就先结束程序运行。</p><ul class="list" id="1706899533#z343d28_89" start="1"><li class="list-item" id="1706899533#z343d28_97"><p>忽视因调用close而引发的异常</p></li></ul><div class="detached code-block" id="1706899533#z343d28_90"><pre><code class="language-cpp">DBConn::~DBConn(){
  trY { db.close(); }
  catch(...) {
    /* 生成日志文件，记录调用close抛出异常的记录 */
    /* 此处不对异常进行反馈，程序依然向后运行 */
  }
}</code></pre></div><p id="1706899533#z343d28_91">以上提到的两种方法属于下策，对于这种情况另有更好的解决办法：  对DBConn的设计进行调整</p><div class="detached code-block" id="1706899533#z343d28_92"><pre><code class="language-cpp">class DBConn{
public:
  ...
  void close(){
    db.close();
    closed = true;  /* 记录用户是否手动关闭了数据库连接 */
  }
  ~DBConn(){
    if (!closed){   /* 如果用户没有手动关闭数据库的连接 */
      try{ db.close(); }
      catch(...){
        /* 记录下调用close时的异常信息 */
        /* std::abort(); */
        /* 此处可忽略close抛出的异常
           或者直接结束程序
        */
      }
    }
  }
private:
  DBConnection db;
  bool closed;
};</code></pre></div><p id="1706899533#z343d28_93">此处用户可以手动选择是否关闭数据库连接，如果没有手动关闭，在DBConnection对象的生命周期结束时，其会调用自身的析构函数来断开与数据库的连接。</p><p id="1706899533#z343d28_94">总结：</p><ul class="list" id="1706899533#z343d28_95" start="1"><li class="list-item" id="1706899533#z343d28_99"><p>析构函数绝对不要抛出异常，如果在析构函数中调用了一个函数而导致了异常，此析构函数应该捕捉异常，并阻止它们的在栈的展开的过程中继续传播或直接结束程序。</p></li><li class="list-item" id="1706899533#z343d28_100"><p>如果用户要对某个函数进行操作的过程中抛出异常做出回应，那么就要在拥有该成员函数的类中提供一个函数来执行该操作。</p></li></ul></section><section><h2 id="1706899533#9-virtual" data-toc="9-virtual#第二章-构造-析构-赋值运算.md-9-virtual">条款9：决不在构造和析构过程中调用 virtual 函数</h2><p id="1706899533#z343d28_101">引入事例：利用class的继承体系来模仿各个行业的交易操作</p><div class="detached code-block" id="1706899533#z343d28_102"><pre><code class="language-cpp">class Transaction{ /* base class */
public:
  Transaction( );
  virtual void logTransaction() const = 0;
};

Transaction::Transaction(){
  ...
  logTransaction();
}

class BuyTransaction: public Transaction{ /* derived class */
public:
  virtual void logTransaction() const;
}</code></pre></div><p id="1706899533#z343d28_103">现在将 BuyTransaction 实例化，其顺序为：</p><ol class="list list-decimal" id="1706899533#z343d28_104" type="1" start="1"><li class="list-item" id="1706899533#z343d28_112"><p>先构造基类 Transaction</p></li><li class="list-item" id="1706899533#z343d28_113"><p>调用基类内的 logTransaction()</p></li><li class="list-item" id="1706899533#z343d28_114"><p>构造继承类 BuyTransaction</p></li></ol><p id="1706899533#z343d28_105">由此可见，所调用的 logTransaction 是属于基类 Transaction 的， 而不是 BuyTransaction 中的 logTransaction。毕竟， 继承类中的 logTransaction 很大概率上会涉及到基类中的成员变量， 所以在基类被构造完成之前调用被实现基类的虚函数是一个危险的操作。</p><p id="1706899533#z343d28_106">换句话说，在继承类(derived class)构造其基类(base class)的过程中， 此继承类(derived class)实际为基类(base class)，即当前继承类的仅具有基类的属性。  对于上述例子而言， 即使是下面这种实现方式也会有一定的潜在问题：  在构造继承类时调用的仍是基类中的logTransaction()</p><div class="detached code-block" id="1706899533#z343d28_107"><pre><code class="language-cpp">class Transaction{
public:
  Transcation( ) { init(); }
  virtual void logTransaction() const = 0;
  void logTransaction() { }
  ...
private:
  void init(){
    ...
    logTransaction();
  }
};</code></pre></div><p id="1706899533#z343d28_108">解决这种的问题的方法：</p><ul class="list" id="1706899533#z343d28_109" start="1"><li class="list-item" id="1706899533#z343d28_117"><p id="1706899533#z343d28_118">在 Transaction 类中将 logTransaction() 改为 non-virtual，然后用成员初值列的初始化方式对基类中的成员变量进行初始化， 然后继承类的构造函数就可以正常地调用 non-virtual logTransaction。</p><div class="detached code-block" id="1706899533#z343d28_119"><pre><code class="language-cpp">class Transaction{
public:
  explicit Transaction(const std::string&amp; logInfo);
  void logTransaction(const std::string&amp; logInfo) const;
  /* 此时 logTransaction() 是一个non-virtual函数 */
};
Transaction::Transaction(const std::string&amp; logInfo){
  ...
  logTransaction(logInfo);
}
class buyTransaction: public Transaction{
public:
  buyTransaction( params): 
  Transaction(createLogString( params )){
    ... /* 将log信息传给基类构造函数 */
  }
private:
  static std::string createLogString( params );
};</code></pre></div><p id="1706899533#z343d28_120">简而言之，此处虚函数无法从基类中被调用至继承的类中，但是可以将继承类中需要初始化的变量向基类方向传递至基类构造函数来达到自己想要的目的。</p><ul class="list" id="1706899533#z343d28_121" start="1"><li class="list-item" id="1706899533#z343d28_122"><p id="1706899533#z343d28_123">避免在构造函数中调用虚函数及其解决方法：</p><ul class="list" id="1706899533#z343d28_124" start="1"><li class="list-item" id="1706899533#z343d28_130"><p>使用非虚函数替代虚函数</p></li></ul><div class="detached code-block" id="1706899533#z343d28_125"><pre><code class="language-cpp">class Transaction{
public:
  explicit Transaction(const std::string&amp; logInfo){
  /* 在构造函数中调用一个非虚函数 */
    logTransaction(logInfo);
  }
  void logTransaction(const std::string&amp; logInfo) const{
    /* Other components */
  }
};

class BuyTransaction: public Transaction{
public:
  BuyTransaction(const std::string&amp; params):
  Transaction(createLogString(params)){
    /* 此处利用基类的构造函数对需要初始化的信息进行初始化 */
    /* 以此为例，其继承类的部分构造过程如下:
    * 1. 调用static createLogString对需要初始化的参数进行传递
    * 2. 继承类在构造函数中调用基类的构造函数
    * 3. 基类在进行构造时调用自身的logTransaction函数
    */
}
private:
  static std::string createLogString(const std::string&amp; params){
    return &quot;Log info for BuyTransaction&quot; + params;
  }
};</code></pre></div><ul class="list" id="1706899533#z343d28_126" start="1"><li class="list-item" id="1706899533#z343d28_131"><p>在构造函数之后进行初始化操作</p></li></ul><div class="detached code-block" id="1706899533#z343d28_127"><pre><code class="language-cpp">class Transaction{
public:
    Transaction(){}


    virtual void logTransaction() const = 0;
    /* 等待在继承类中进行实现 */

    void init(const std::string&amp; logInfo){
        logTransaction(logInfo);
    }
};

class BuyTransaction: public Transaction{
public:
    BuyTransaction(const std::string&amp; params): Transaction(){
        init(createLogString(params));
    }

    void logTransaction(const std::string&amp; logInfo) const override{
        /* Other components */
    }

private:
    static std::string createLogString(const std::string&amp; params){
        return &quot;Log info for BuyTransaction&quot; + params;
    }
};</code></pre></div><ul class="list" id="1706899533#z343d28_128" start="1"><li class="list-item" id="1706899533#z343d28_132"><p>使用两个阶段的构造模式</p></li></ul><div class="detached code-block" id="1706899533#z343d28_129"><pre><code class="language-cpp">class Transaction {
public:
  Transaction() {
  // 基本初始化
  }

  virtual void logTransaction() const = 0;
  /* 等待在后面的继承类中实现 */

 void completeConstruction(const std::string&amp; logInfo) {
    logTransaction(logInfo);
  }
};

class BuyTransaction : public Transaction {
public:
  BuyTransaction(const std::string&amp; params) :
  Transaction() {
    completeConstruction(createLogString(params));
  }

  void logTransaction(const std::string&amp; logInfo) const override {
        // 记录 BuyTransaction 的日志
  }

private:
  static std::string createLogString(const std::string&amp; params) {
    // 创建日志字符串
    return &quot;Log info for BuyTransaction: &quot; + params;
  }
};</code></pre></div></li></ul></li></ul><p id="1706899533#z343d28_110">总结：</p><ul class="list" id="1706899533#z343d28_111" start="1"><li class="list-item" id="1706899533#z343d28_133"><p>在构造和析构过程中不要调用virtual函数，因为在继承类(derived class)中无法调用基类的virtual函数（关于相对继承而言）。</p></li></ul></section><section><h2 id="1706899533#10-operator-reference-to-this" data-toc="10-operator-reference-to-this#第二章-构造-析构-赋值运算.md-10-operator-reference-to-this">条款10：令 operator= 返回一个 reference to *this</h2><p id="1706899533#z343d28_134">关于赋值操作符=</p><div class="detached code-block" id="1706899533#z343d28_135"><pre><code class="language-cpp">int x, y, z;
/* 关于赋值操作符=，可以写为连锁赋值的形式 */
x = y = z = 15;
/* 增强赋值操作的可读性，如下： */
x = (y = (z = 15))</code></pre></div><p id="1706899533#z343d28_136">实现连锁赋值的操作的前提是赋值操作符必须返回一个指向=左边实参的引用。  对于一个自定义类而言，在对其赋值操作符=进行重载时，其返回值类型应该如下：</p><div class="detached code-block" id="1706899533#z343d28_137"><pre><code class="language-cpp">class MyWidget{
public:
  ...
  MyWidget&amp; operator=(const MyWidget&amp; rhs){
    ...
    return * this;
  }
  /* 对于其他类型的函数参数也适用 */
  MyWidget&amp; operator=(int rhs){
    ...
    return * this;
  }
  /* 对于其他类型的赋值操作符也适用 */
  MyWidget&amp; operator+=(const MyWidget&amp; rhs){
    ...
    return * this;
  }
};</code></pre></div><p id="1706899533#z343d28_138">对于这样的赋值操作符重载操作在标准库中的一些容器(例如：vector, string, complex等)中也存在。</p><p id="1706899533#z343d28_139">总结：</p><ul class="list" id="1706899533#z343d28_140" start="1"><li class="list-item" id="1706899533#z343d28_142"><p>让赋值(assignment)操作符返回一个 reference to *this。</p></li></ul></section><section><h2 id="1706899533#11-operator" data-toc="11-operator#第二章-构造-析构-赋值运算.md-11-operator">条款11：在 operator= 中处理&ldquo;自我赋值&rdquo;</h2><p id="1706899533#z343d28_143">在代码实现的过程中，可能会出现以下这种情况&mdash;&mdash;&ldquo;自我赋值&rdquo;:</p><div class="detached code-block" id="1706899533#z343d28_144"><pre><code class="language-cpp">class MyWidget{ };
MyWidget w;
...
w = w; /* 自己对自己进行赋值 */

/* 一种容易忽视的自我赋值情况 */
a[i] = a[j] /* 当 i == j 时，
             * a[i] = a[j]
             * 这就成了自我赋值 */

/* 另一种容易忽视的自我赋值情况 */
* px = * py;</code></pre></div><p id="1706899533#z343d28_145">对于 * px = * py 这种赋值情况而言，当px 与 py恰好指向同一个实例时，这也就成为了自我赋值。  上述情况，都是基于&ldquo;别名(aliasing)&rdquo;所产生的结果，因为有一个及以上的方法(pointer or reference)指向同一个对象。  对于继承体系而言，只要派生的对象都继承于同一个基类，就会自然的产生自我赋值的这种情况，因此这一般是一个不可避免的问题：</p><div class="detached code-block" id="1706899533#z343d28_146"><pre><code class="language-cpp">class Base{ ... };
class Derived: public Base { ... };
void action(const Base&amp; rb, Derived* pd);
/* 此处的 rb 和 pd 可能是同一个对象 */</code></pre></div><p id="1706899533#z343d28_147">当要自行实现资源管理时，很容易掉入&ldquo;停止使用资源之前提前对此资源进行了释放&rdquo;这种陷阱。例如， 创建一个Widget类保存一个指向动态分配的位图(Bitmap)的指针：</p><div class="detached code-block" id="1706899533#z343d28_148"><pre><code class="language-cpp">class Bitmap { ... };
class Widget { 
  ...
private:
  Bitmap* pb; /* * pb 一个指向从 heap 分配得到的对象 */
};</code></pre></div><p id="1706899533#z343d28_149">对于Widget类的中=赋值的重载实现：</p><div class="detached code-block" id="1706899533#z343d28_150"><pre><code class="language-cpp">Widegt&amp; Widget::operator=(const Widget&amp; rhs){
  delete pb;                // 删除当前的 pb 指针
  pb = new Bitmap(*rhs.pb); // 使用 rhs 的 Bitmap
  return *this;
}
/* 这种情况并不安全 */</code></pre></div><p id="1706899533#z343d28_151">这里自我赋值的情况在于，如果 operator= 重载函数中的 *this(被赋值的对象) 和 rhs 是一个对象， 那么 delete pb 不只是删除当前对象的bitmap, 也会删除rhs中的bitmap，待到执行结束，*this 会指向一个已经被删除的对象，这种情况是很危险的。</p><p id="1706899533#z343d28_152">解决这种问题的方法还是在operator=中添加一个&quot;证同条件&quot;，达到自我赋值检验的目的：</p><div class="detached code-block" id="1706899533#z343d28_153"><pre><code class="language-cpp">Widget&amp; Widget::operator(const Widget&amp; rhs){
  if(this == &amp;rhs) return * this; // 证同条件
  /* *this 和 &amp;rhs 指向的不是同一个对象 */ 
  delete pb;
  pd = new Bitmap(*rhs.pb);
  return *this;
}</code></pre></div><p id="1706899533#z343d28_154">前一个 operator= 不仅不具备&ldquo;自我赋值的安全性&rdquo;，也不具备&ldquo;异常安全性&rdquo;。  添加了证同条件的 operator= 也存在着一些问题，如果是在&quot;new Bitmap&quot;导致异常(不论是因为分配时内存不足或因为Bitmap的copy构造函数抛出异常)， Widget 的 pb 指针最终会指向一个被删除的Bitmap，这种情况也很危险，对于这种情况，更加需要重视的是如何处理异常安全性，以此再改善之前的的&ldquo;自我赋值&rdquo;：</p><div class="detached code-block" id="1706899533#z343d28_155"><pre><code class="language-cpp">/* 确保在对pb赋值时，pb所指的对象没有被删除 */
Widget&amp; Widget::operator=(const Widget&amp; rhs){
  Bitmap* pOrig = pb;       // 存下原来的 pb
  pb = new Bitmap(*rhs.pb); // 可能 throw exception
  delete pOrig;             // 删除原来的 pb
  return *this;
}</code></pre></div><p id="1706899533#z343d28_156">如果&quot;new Bitmap&quot;抛出异常，pb及其Widget保持原状，在没有证同条件的情况下，依旧能处理自我赋值， 因为存在一份事先存下来的 Orig 可以帮助恢复至 pb 被赋值前的状态。</p><p id="1706899533#z343d28_157">如果想要提高运行效率，可以在operator=前加一个证同条件。但是也要知道自我赋值这种情况发生的概率大小， 毕竟这个修改给函数增加了一个新的判断分支，因此同时也会影响执行速度，prefetching(预取)、caching(缓存)和pipelining(流水线)等指令的效率都会因此降低。</p><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="1706899533#z343d28_170"><span class="control" id="1706899533#z343d28_171">补充</span><span class="control" id="1706899533#z343d28_173">prefetching</span>: 处理器进行预取时会根据指令流进行预测。如果插入额外的条件判断，可能会改变指令流的顺序，从而影响预取结果，导致预取的数据不是立即需要的，降低预取的效率。 <span class="control" id="1706899533#z343d28_175">caching</span>: 额外的判断分支可能导致不同的代码路径访问不同的数据，增加缓存失效(cache miss)的可能性。当缓存失效时，处理器需要从较慢的缓存中加载数据，导致性能下降。 <span class="control" id="1706899533#z343d28_176">pipelining</span>: 条件判断会引入分支，如果处理器预测错误的分治，会导致流水线停顿(pipeline stall)，清空错误路径上的指令，重新加载正确的指令。这种停顿会严重影响处理器的指令吞吐量。</p></div>
</blockquote>
<p id="1706899533#z343d28_159">要确保operator=的&ldquo;异常安全&ldquo;和&rdquo;自我赋值安全&ldquo;的第一个替代方案是，使用 copy and swap 技术来实现：</p><div class="detached code-block" id="1706899533#z343d28_160"><pre><code class="language-cpp">class Widget{
  ...
  void swap(Widget&amp; rhs); // 交换 *this 和 rhs 的数据
  ...
};
Widget&amp; Widget::operator=(const Widget&amp; rhs){
  Widget temp(ths);   // 对 rhs 进行备份为 temp 
  swap(temp);         // 将 *this 数据与备份数据 temp 进行交换
  return *this;
}</code></pre></div><p id="1706899533#z343d28_161">operator=另一种更高效的(但是降低了代码的可读性)写法如下：</p><div class="detached code-block" id="1706899533#z343d28_162"><pre><code class="language-cpp">Widget&amp; Widget::operator=(Wdiget rhs){  // rhs 是被传递对象的一个备份
  swap(rhs);                            // 此处利用 pass by value
  return *this;                         // 将 *this 的数据与备份的数据进行互换
}</code></pre></div><p id="1706899533#z343d28_163">参考依据：</p><ol class="list list-decimal" id="1706899533#z343d28_164" type="1" start="1"><li class="list-item" id="1706899533#z343d28_177"><p>一个类的 copy assignment 操作符可能被声明为&quot;按值传递(pass by value)的方式接受实参&quot;。</p></li><li class="list-item" id="1706899533#z343d28_178"><p>通过按值传递(pass by value)的方式处理会多出一份rhs的备份数据。</p></li></ol><p id="1706899533#z343d28_165">总结：</p><ul class="list" id="1706899533#z343d28_166" start="1"><li class="list-item" id="1706899533#z343d28_179"><p>确保当前对象在进行自我赋值时operator=有着正确处理行为，例如： </p><ul class="list" id="1706899533#z343d28_181" start="1"><li class="list-item" id="1706899533#z343d28_182"><p>比较&quot;来源对象&quot;和&quot;目标对象&quot;的地址</p></li><li class="list-item" id="1706899533#z343d28_183"><p>copy and swap 技术</p></li><li class="list-item" id="1706899533#z343d28_184"><p>正确且具有可读性的语句</p></li></ul></li><li class="list-item" id="1706899533#z343d28_180"><p>确保一个函数在操作多个对象时，对于相同的对象的处理仍然正确。</p></li></ul></section><section><h2 id="1706899533#12" data-toc="12#第二章-构造-析构-赋值运算.md-12">条款12：复制对象时勿忘其每一个成分</h2><p id="1706899533#z343d28_185">良好的面向对象系统会将对象的内部封装起来，只留两个函数负责对象拷贝，即copy构造函数和copy assignment操作符。  对于以上两种函数，如果自己不主动实现，编译器会自动生成。对于自己实现的版本，当这些函数出错时，编译器不会给出任何提示信息，因此会增加debug难度。</p><p id="1706899533#z343d28_186">示例：实现一个 顾客类 (Customer Class)，手动实现其中的copying函数，同时实现一个 logCall 记录函数的调用</p><div class="detached code-block" id="1706899533#z343d28_187"><pre><code class="language-cpp">void logCall(const std::string&amp; funcName);
class Customer{
public:
  ...
  Customer(const Customer&amp; rhs);
  Customer&amp; operator=(const Customer&amp; rhs);
  ...
private:
  std::string name;
};

/* 拷贝构造 */
Customer::Customer(const Customer&amp; rhs): name(rhs.name) /* 复制rhs的数据 */ {
  logCall(&quot;Customer copy constructor&quot;);
}

/* =赋值运算符重载 */
Customer&amp; Customer::operator=(const Customer&amp; rhs){
  logCall(&quot;Customer copy assignment operator&quot;);
  name = rhs.name;  // 复制rhs的数据
  return *this;     
}</code></pre></div><p id="1706899533#z343d28_188">以上是对类的copy构造和copy assignment运算符的一般实现。  但是对于以下情况就会有所不同：</p><div class="detached code-block" id="1706899533#z343d28_189"><pre><code class="language-cpp">class Date { ... };
class Customer {
public:
  /* 同前 */
private:
  std::string name;
  Date lastTransaction;
};</code></pre></div><p id="1706899533#z343d28_190">此处若还是使用之前的copying函数，那么执行的就是局部拷贝或部分拷贝(partial copy)，因为它们只复制了顾客的name， 但没有复制新添加的 lastTransaction，编译器也不会对此做出任何提示或者警告，因为这是手动实现的copying函数，为了实现对所有成员变量的copy， 也必须手动修改对应copying函数。  倘若这样的问题出现在一个继承体系中：</p><div class="detached code-block" id="1706899533#z343d28_191"><pre><code class="language-cpp">class PriorityCustomer: public Customer{
public:
  ...
  PriorityCustomer(const PriorityCustomer&amp; rhs);
  PriorityCustomer&amp; operator=(const PriorityCustomer&amp; rhs);
  ...
private:
  int priority;
};

PriorityCustomer::PriorityCustomer(const PriorityCustomer&amp; rhs):
        priority(rhs.priority){
  logCall(&quot;PriorityCustomer copy constructor&quot;);        
}

PriorityCustomer&amp; PriorityCustomer::
operator=(const PriorityCustomer&amp; rhs){
  logCall(&quot;PriorityCustomer copy assignment operator&quot;);
  priority = rhs.priority;
  return *this;
}</code></pre></div><p id="1706899533#z343d28_192">上面的继承类 PriorityCustomer 的copying函数只复制了当前PriorityCustomer中的成员变量，但因为这个PriorityCustomer是继承自Customer的， 即其父类(Customer)中的成员变量没有被复制，因此也导致了一个局部复制(partial copy)，而此时因为没有对父类中的成员变量进行赋值， 导致父类会调用其default构造函数(无参构造函数)，default构造函数将针对name和lastTransaction执行缺省的初始化操作。</p><p id="1706899533#z343d28_193">任何时候，为继承类实现copying函数，必须也要复制其父类的所有成员变量，父类中的成员变量往往是private属性的，所以继承类copying函数需要调用父类的相应copying函数对父类中的成员变量进行赋值：</p><div class="detached code-block" id="1706899533#z343d28_194"><pre><code class="language-cpp">PriorityCustomer::PriorityCustomer(const PriorityCustomer&amp; rhs):
  Customer(rhs),  // 调用父类的构造函数，对父类成员进行赋值
  priority(rhs.priority){
  logCall(&quot;PriorityCustomer copy constructor&quot;);
}

Priority&amp; Priority::operator=(const PriorityCustomer&amp; rhs){
  logCall(&quot;PriorityCustomer copy assignment operator&quot;);
  Customer::operator=(rhs); // 调用父类的的赋值函数，对父类成员进行赋值
  priority = rhs.priority;
  return *this;
}</code></pre></div><p id="1706899533#z343d28_195">综上可总结出的经验：</p><ol class="list list-decimal" id="1706899533#z343d28_196" type="1" start="1"><li class="list-item" id="1706899533#z343d28_205"><p>复制所有local成员变量</p></li><li class="list-item" id="1706899533#z343d28_206"><p>调用所有 base classes 内合适的copying函数</p></li></ol><p id="1706899533#z343d28_197">切记，是调用对应的copying函数，不要让 copy assignment 操作符重载函数去调用 copy 构造函数，因为构造一个已经存在的对象这样的操作是没有意义的， 同样，也不要让 copy 构造函数去调用 copy assignment 操作符重载函数。因为构造函数是用来创建新的实例的，而 assignment 操作符只适用于已经创建好的实例上，对于一个没有初始化的对象使用 assignment 操作符是一个没有意义的操作。</p><p id="1706899533#z343d28_198">如果在 copy 构造函数和 copy assignment 操作符中有相同的部分，建立一个新的成员函数给两者调用。这样的函数一般是private属性且名为init，这个操作可以安全消除copy 构造函数和 copy assignment 操作符之间的代码重复。</p><div class="detached code-block" id="1706899533#z343d28_199"><pre><code class="language-cpp">class PriorityCustomer: public Customer{
public:
  PriorityCustomer(const PriorityCustomer&amp; rhs){
    init(rhs);
    logCall(&quot;PriorityCustomer copy constructor&quot;);
  }

  PriorityCustomer&amp; operator=(const PriorityCustomer&amp; rhs){
    if(this != rhs){
      Customer::operator(rhs);
      init(rhs);
    }
    logCall(&quot;PriorityCustomer copy assignment operator&quot;);
    return *this;
  }
  
private:
  int priority;
  void init(const PriorityCustomer&amp; rhs){
    priority = rhs.priority;
  }
};</code></pre></div><p id="1706899533#z343d28_200">总结：</p><ul class="list" id="1706899533#z343d28_201" start="1"><li class="list-item" id="1706899533#z343d28_207"><p>copying函数应该确保复制&ldquo;对象内的所有成员变量&rdquo;及&ldquo;所有父类(base class)成分&quot;。</p></li><li class="list-item" id="1706899533#z343d28_208"><p>在继承类中的copying函数应该调用父类中对应的copying函数。</p></li><li class="list-item" id="1706899533#z343d28_209"><p>将copy构造函数和copy assignment操作符中的具有相同部分功能的代码写入到一个单独的函数中，供这两者调用。</p></li></ul></section></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="-12458821">第三章 资源管理</h1><p id="-12458821#nyq9bm_3">使用计算机资源，最重要的一个原则就是有借有还。  C++中最常用的资源就是动态分配内存，如果使用了内存后，不将其返还，那么就会导致资源泄露。  内存在计算机中是必须管理的众多资源之一，其他常见的资源还包括文件描述器(file descriptor)、互斥锁(mutex locks)、图形界面中的字型和笔刷、数据库连接以及网络sockets。</p><section><h2 id="-12458821#13" data-toc="13#第三章-资源管理.md-13">条款13：以对象管理资源</h2><p id="-12458821#nyq9bm_11">先引出示例：实现一个关于投资行为的程序库，其中各种投资类型继承自一个root class Investment。</p><div class="detached code-block" id="-12458821#nyq9bm_12"><pre><code class="language-cpp">class Investment { ... };   // 继承体系中的一个父类</code></pre></div><p id="-12458821#nyq9bm_13">这个程序库通过一个工厂函数来使用特定的Investment对象：</p><div class="detached code-block" id="-12458821#nyq9bm_14"><pre><code class="language-cpp">Investment* createInvestment(); // 返回指针，指向Investment继承体系内的动态分配对象
                                // 使用完后，有必要对其进行删除</code></pre></div><p id="-12458821#nyq9bm_15">现使用一个函数来实现上述指针资源的回收(删除):</p><div class="detached code-block" id="-12458821#nyq9bm_16"><pre><code class="language-cpp">void f(){
    Investment* pInv = createInvestment();  // 调用 factory 函数
    ...
    delete pInv;                            // 释放pInv所指的对象
}</code></pre></div><p id="-12458821#nyq9bm_17">如果这个函数提早结束了，使之不能到达delete pInv这一句，pInv就无法被正常删除，以此导致的内存泄露是非常危险的。  同样的情况在循环语句中或许因为continue和goto导致控制流无法执行到delete ...语句，导致资源无法被正常释放。</p><p id="-12458821#nyq9bm_18">为确保资源能够被正常释放，可以将资源放进对象中，当控制流离开函数(函数执行完)，该对象的析构函数会自动释放那些资源。</p><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="-12458821#nyq9bm_37">补充：计算中内存的分配和组成</p><ol class="list list-decimal" id="-12458821#nyq9bm_38" type="1" start="1"><li class="list-item" id="-12458821#nyq9bm_53"><p>栈(stack)</p></li></ol><div class="detached code-block" id="-12458821#nyq9bm_39"><pre><code class="language-cpp">void f(){
  int localVariable = 42; // 分配在栈上
}</code></pre></div><p id="-12458821#nyq9bm_40">内存布局：栈是由一个后进先出(LIFO)结构，栈顶指针随着函数调用和局部变量的创建而增长，随着函数返回和局部变量的销毁而减少。  用途：用于存储局部变量、函数参数和函数调用的返回地址 特点：</p><ul class="list" id="-12458821#nyq9bm_41" start="1"><li class="list-item" id="-12458821#nyq9bm_56"><p>栈内存是由编译器自动管理的。</p></li><li class="list-item" id="-12458821#nyq9bm_57"><p>内存分配速度快，但是大小有限(通常由操作系统限制)。</p></li><li class="list-item" id="-12458821#nyq9bm_58"><p>变量的生命周期是由其作用域决定的，当离开作用域时，内存自动释放。</p></li></ul><ol class="list list-decimal" id="-12458821#nyq9bm_42" type="1" start="2"><li class="list-item" id="-12458821#nyq9bm_59"><p>堆(heap)</p></li></ol><div class="detached code-block" id="-12458821#nyq9bm_43"><pre><code class="language-cpp">int* p = new int(42); // 分配在堆上
delete p;             // 手动释放内存</code></pre></div><p id="-12458821#nyq9bm_44">内存布局：堆是一个更复杂的区域，由操作系统或运行时库管理，允许自由分配和释放内存。 用途：用于动态内存分配，例如通过&quot;new&quot;和&quot;malloc&quot;分配的内存 特点:</p><ul class="list" id="-12458821#nyq9bm_45" start="1"><li class="list-item" id="-12458821#nyq9bm_60"><p>需要手动管理内存(分配和释放)。</p></li><li class="list-item" id="-12458821#nyq9bm_61"><p>可以分配比栈更大的内存块，但速度较慢且容易导致内存泄漏。</p></li><li class="list-item" id="-12458821#nyq9bm_62"><p>生命周期由程序员控制，直到显式释放内存(通过&quot;delete&quot;或&quot;free&quot;)。</p></li></ul><ol class="list list-decimal" id="-12458821#nyq9bm_46" type="1" start="3"><li class="list-item" id="-12458821#nyq9bm_63"><p>全局/静态内存区域(Global/Static Memory Area)</p></li></ol><div class="detached code-block" id="-12458821#nyq9bm_47"><pre><code class="language-cpp">int globalVariable = 42;          // 全局变量
void f(){
  static int staticVariable = 42; // 静态变量
}</code></pre></div><p id="-12458821#nyq9bm_48">内存布局：这部分内存通常在程序的最底层，由操作系统分配和管理 用途：用于存储全局变量和静态变量，这些变量在程序的整个生命周期内都存在。 特点：</p><ul class="list" id="-12458821#nyq9bm_49" start="1"><li class="list-item" id="-12458821#nyq9bm_64"><p>这些变量在程序启动时分配内存，在程序结束时释放。</p></li><li class="list-item" id="-12458821#nyq9bm_65"><p>生命周期贯穿整个程序运行期。</p></li></ul><ol class="list list-decimal" id="-12458821#nyq9bm_50" type="1" start="4"><li class="list-item" id="-12458821#nyq9bm_66"><p>代码段(code segment) 内存布局：代码段包含程序运行的机器指令，是内存中固定的一部分。 用途：存储程序可执行代码。 特点： </p><ul class="list" id="-12458821#nyq9bm_67" start="1"><li class="list-item" id="-12458821#nyq9bm_68"><p>通常是只读的，以防止意外修改程序代码。</p></li><li class="list-item" id="-12458821#nyq9bm_69"><p>在程序加载到内存时由操作系统分配。</p></li></ul></li></ol><p id="-12458821#nyq9bm_51">整体内存布局</p><div class="detached code-block" id="-12458821#nyq9bm_52"><pre><code class="language-none">高地址
+----------------------+
|          栈          |
+----------------------+
|          堆          |
+----------------------+
|          BSS         |
+----------------------+
|          数据段       |
+----------------------+
|          代码段       |
+----------------------+
低地址</code></pre></div></div>
</blockquote>
<p id="-12458821#nyq9bm_20">许多资源被动态分配在heap内，之后被用于单一区块或函数内，它们在控制流离开了所在区块或函数时被释放。  为了上面这种清醒，智能指针(auto_ptr)就应运而生了,auto_ptr是一个&quot;类指针(pointer-like)对象&quot;，其析构函数自动对其所指对象调用delete以释放资源：</p><div class="detached code-block" id="-12458821#nyq9bm_21"><pre><code class="language-cpp">void f(){
    std::auto_ptr&lt;Investment&gt; pInv(createInvestment());
        /* 调用 工厂函数(factory function)
    ...  * 经由auto_ptr的析构函数自动删除pInv
        */
}</code></pre></div><p id="-12458821#nyq9bm_22">上面这个例子可以体现&quot;以对象管理资源&ldquo;的两个关键点：</p><ol class="list list-decimal" id="-12458821#nyq9bm_23" type="1" start="1"><li class="list-item" id="-12458821#nyq9bm_71"><p>获得资源后立刻放进管理对象(managing object)内，以上代码中createInvestment返回的资源被当作其管理者 auto_ptr 的初值。使用对象管理资源的观念常被称作RAII(Resource Acquisition Is Initialization)，即在获取资源时就进行初始化，因此所有资源在获得的同时应该被立即放入管理对象中。</p></li><li class="list-item" id="-12458821#nyq9bm_72"><p>管理对象(managing object)运用析构函数确保资源被释放，只要控制流离开了函数，其中的对象离开了作用域，其析构函数就会被自动调用，使其资源被释放。</p></li></ol><p id="-12458821#nyq9bm_24">因为当 auto_ptr 被释放时，auto_ptr 指针所指向的对象也被会释放，所以要注意不要让多个 auto_ptr 指向同一个对象，否则会导致一个对象被释放多次，使其产生未定义行为。  针对此种情况，设计者为auto_ptr添加了一个特性，就是当使用copying函数(copy 构造函数和copy assignment 操作符)对其进行复制时，复制出来的auto_ptr会变成null，这一点就很好地保证了复制所得指针所取得的资源的唯一性。</p><div class="detached code-block" id="-12458821#nyq9bm_25"><pre><code class="language-cpp">std::auto_ptr&lt;Investment&gt; pInv1(createInvestment());    
    // pInv1指向createInvestment创建的对象
std::auto_ptr&lt;Investment&gt; pInv2(pInv1);
    // pInv2指向pInv1所指的对象，pInv1现被设置为null
    // 转移所有权
pInv1 = pInv2;
    // 现pInv1指向pInv2所指的对象，pInv2被设置为null
    // 转移所有权</code></pre></div><p id="-12458821#nyq9bm_26">上面这一过程体现出auto_ptr对资源管理的局限性，即auto_ptr指向资源的唯一性。</p><p id="-12458821#nyq9bm_27">解决这种问题的一种方案是使用&quot;引用计数智能指针(reference-counting smart pointer-RCSP)&quot;。RCSP也是一种智能指针， 其可持续追踪共有多少对象指向某笔资源，并在无指针指向某资源时，自动释放该资源，但是对于环状引用(即两个指针指向彼此，导致其仍然处在被使用的状态)，RCSP无法解决。</p><div class="detached code-block" id="-12458821#nyq9bm_28"><pre><code class="language-cpp">void f(){
    ...
    std::shared_ptr&lt;Investment&gt; pInv(createInvestment());
    ...
}</code></pre></div><p id="-12458821#nyq9bm_29">使用shared_ptr的复制操作相对于auto_ptr要正常得多：</p><div class="detached code-block" id="-12458821#nyq9bm_30"><pre><code class="language-cpp">void f(){
    ...
    std::shared_ptr&lt;Investment&gt; pInv1(createInvestment()); 
    // pInv1指向createInvestment()返回的对象
    std::shared_ptr&lt;Investment&gt; pInv2(pInv1);
    // pInv1和pInv2指向同一个对象
    pInv1 = pInv2;
    // 同上，不发生改变
    ...
    // pInv1和pInv2被释放，那么它们所指的对象也会被释放
}</code></pre></div><p id="-12458821#nyq9bm_31">auto_ptr和shared_ptr两者都在其析构函数执行delete而不是delete[]，这就意味着不应该在动态分配的array上使用auto_ptr和shared_ptr，如下：</p><div class="detached code-block" id="-12458821#nyq9bm_32"><pre><code class="language-cpp">std::auto_ptr&lt;std::string&gt; aps(new std::string[10]);
std::shared_ptr&lt;int&gt; spi(new int[1024]);</code></pre></div><p id="-12458821#nyq9bm_33">在C++一般使用vector或string这样边长array来替代动态分配的数组，所以针对动态分配的数组并没有特定指针。</p><p id="-12458821#nyq9bm_34">总结：</p><ul class="list" id="-12458821#nyq9bm_35" start="1"><li class="list-item" id="-12458821#nyq9bm_74"><p>使用RAII对象来防止资源泄露，它们在构造函数中获取资源并在析构函数中释放资源。</p></li><li class="list-item" id="-12458821#nyq9bm_75"><p>常使用的两个RAII对象分别为shared_ptr和auto_ptr，其中shared_ptr为更好的选择，因为其copy行为较为直观，auto_ptr的复制行为会使其指向null。</p></li></ul></section><section><h2 id="-12458821#14-copying" data-toc="14-copying#第三章-资源管理.md-14-copying">条款14：在资源类管理中小心copying行为</h2><p id="-12458821#nyq9bm_76">有时候为了更好地管理资源，还是需要自己实现资源管理类。</p><p id="-12458821#nyq9bm_77">示例：使用C API函数处理类型为Mutex的互斥器对象(mutex object)，共有lock和unlock两种函数可用：</p><div class="detached code-block" id="-12458821#nyq9bm_78"><pre><code class="language-cpp">void lick(Mutex* pm);   // 锁定pm所指的互斥器
void unlock(Mutex* pm); // 将互斥器解除锁定</code></pre></div><p id="-12458821#nyq9bm_79">为了保证每一个被锁住的互斥器Mutex解锁，可能就需要建立一个类来管理机锁。要设计这样的管理类的管理原则也可以参考RAII对象的设计，即&ldquo;在获取资源的同时进行初始化，在析构期间释放&quot;：</p><ul class="list" id="-12458821#nyq9bm_80" start="1"><li class="list-item" id="-12458821#nyq9bm_93"><p>定义一个RAII对象管理mutexPtr</p></li></ul><div class="detached code-block" id="-12458821#nyq9bm_81"><pre><code class="language-cpp">class Lock{
public:
    explicit Lock(Mutex* pm): 
    mutexPtr(pm){ lock(mutexPtr); } // 获取资源
    ~Lock() { unlock(mutexPtr); }   // 释放资源
private:
    Mutex* mutexPtr;    // raw pointer
};</code></pre></div><ul class="list" id="-12458821#nyq9bm_82" start="1"><li class="list-item" id="-12458821#nyq9bm_94"><p>使用该对象</p></li></ul><div class="detached code-block" id="-12458821#nyq9bm_83"><pre><code class="language-cpp">Mutex m;            // 定义互斥器
...
{                   // 定义一个 critical section
    Lock ml(&amp;m);    // 锁定互斥器
    ...
}                   // 自动解除互斥器锁定</code></pre></div><ul class="list" id="-12458821#nyq9bm_84" start="1"><li class="list-item" id="-12458821#nyq9bm_95"><p>尝试复制Lock对象</p></li></ul><div class="detached code-block" id="-12458821#nyq9bm_85"><pre><code class="language-cpp">Lock ml1(&amp;m);       // 锁定 m
Lock ml2(ml1);      // 尝试将ml1复制到ml2上</code></pre></div><p id="-12458821#nyq9bm_86">此时多个RAII对象拥有着同一个互斥器m，这导致在RAII对象释放时，会使互斥器多次释放，导致未定义行为。  此时解决此问题的方案：</p><ul class="list" id="-12458821#nyq9bm_87" start="1"><li class="list-item" id="-12458821#nyq9bm_97"><p>禁止复制：明确声明禁止对RAII对象的复制，可以将copying操作声明为private，或者删除copying操作： </p><ul class="list" id="-12458821#nyq9bm_99" start="1"><li class="list-item" id="-12458821#nyq9bm_100"><p id="-12458821#nyq9bm_102">将copying操作声明为private：</p><div class="detached code-block" id="-12458821#nyq9bm_103"><pre><code class="language-cpp">class Uncopyable{
public:
    ...
protected:
    Uncopyable();
    ~Uncopyable();
private:
    Uncopyable (const Uncopyable&amp;);
    Uncopyable&amp; operator(const Uncopyable&amp;);
};
class Lock: private Uncopyable{
};</code></pre></div></li><li class="list-item" id="-12458821#nyq9bm_101"><p id="-12458821#nyq9bm_104">删除copying操作：</p><div class="detached code-block" id="-12458821#nyq9bm_105"><pre><code class="language-cpp">class Lock{
public:
  ...  

  // 删除copy构造函数和copy assignment操作符
  Lock(const Lock&amp;) = delete;
  Lock&amp; operator=(const Lock&amp;) = delete; 

  ...
};</code></pre></div></li></ul></li><li class="list-item" id="-12458821#nyq9bm_98"><p>对底层资源使用&quot;引用计数法(reference-count)&quot;，即当一个资源没有再被使用时将其释放。这种情况下复制RAII对象，该资源的&quot;被引用数&quot;增加。</p></li></ul><p id="-12458821#nyq9bm_88">因为在Lock中的析构函数作用是unlock(解锁)，而不是delete(释放资源)，使用shared_ptr的缺省行为是删除当前引用次数为0的对象， 然而shared_ptr的deleter(删除器，释放器)是一个函数或函数对象，当引用次数为0时便被调用(这种机制在auto_ptr中不存在)，因此可以修改传给shared_ptr的参数：</p><div class="detached code-block" id="-12458821#nyq9bm_89"><pre><code class="language-cpp">class Lock{
public:
    explicit Lock(Mutex* pm): mutexPtr(pm, unlock){
        // 指定 unlock 为shared_ptr的删除器
        lock(mutexPtr.get());
    }
    /* 此处的析构函数调用非static成员变量的析构函数
     * 即shared_ptr的删除器
     */
    
private:
    std::shared_ptr&lt;Mutex&gt; mutexPtr;    
    // 使用 shared_ptr 替代 raw pointer 
};</code></pre></div><ul class="list" id="-12458821#nyq9bm_90" start="1"><li class="list-item" id="-12458821#nyq9bm_106"><p>复制底部资源，当复制资源管理对象时，进行的是&quot;深度拷贝&quot;，即在复制管理资源对象时，也要对其包含的资源进行复制。有些字符串(一般为可变长)类型由&quot;指向heap内存&ldquo;的指针构成， 这种字符串对象内包含一个指针指向一块heap内存，当这样的一个字符串对象被复制时，指针和其所指的内存段都会被复制，这就体现了字符串的深度拷贝行为。</p></li><li class="list-item" id="-12458821#nyq9bm_107"><p>转移底部资源的拥有权，某些情况下可能希望永远只有一个RAII对象指向一个未加工资源(raw resource)，即使RAII对象被复制依然如此，此时资源的拥有权会从被复制物转移到目标物，这是auto_ptr奉行的复制意义，使其在被复制时资源的拥有权在新的RAII手中，以使资源只被一个RAII对象进行管理，避免后续多个对象尝试释放同一资源的问题。</p></li></ul><p id="-12458821#nyq9bm_91">总结：</p><ul class="list" id="-12458821#nyq9bm_92" start="1"><li class="list-item" id="-12458821#nyq9bm_108"><p>复制RAII对象必须一并复制它们所管理的资源，所以资源的copying行为决定RAII对象的copying行为。</p></li><li class="list-item" id="-12458821#nyq9bm_109"><p>普遍而常见RAII class copying行为是：阻止copying、使用引用计数法等。</p></li></ul></section><section><h2 id="-12458821#15" data-toc="15#第三章-资源管理.md-15">条款15：在资源管理类中提供对原始资源的访问</h2><p id="-12458821#nyq9bm_110">有些时候，需要实现多个资源管理类对象的不同资源之间的访问，此时就要在资源管理类中提供对原始资源的访问。  示例：使用智能指针 auto_ptr 或 shared_ptr 保存 factory 函数如 createInvestment的调用结果：</p><div class="detached code-block" id="-12458821#nyq9bm_111"><pre><code class="language-cpp">shared_ptr&lt;Investment&gt; pInv(createInvestment());</code></pre></div><p id="-12458821#nyq9bm_112">假如需要使用某个函数对Investment对象进行处理：</p><div class="detached code-block" id="-12458821#nyq9bm_113"><pre><code class="language-cpp">int daysHeld(const Investment* pi);</code></pre></div><p id="-12458821#nyq9bm_114">如果上面这个函数被这么调用：</p><div class="detached code-block" id="-12458821#nyq9bm_115"><pre><code class="language-cpp">int days = daysHeld(pInv);</code></pre></div><p id="-12458821#nyq9bm_116">很明显会导致错误，因为daysHeld接受的是一个Investment* 参数，而pInv的类型为<span class="inline-code" id="-12458821#nyq9bm_134">shared_ptr&lt;Investment&gt;</span>。  此时就需要一个函数可将RAII class对象(此处为shared_ptr)转换为它所包含的原始资源(此处为Investment*)。  实现这一目的的方式有两种：显式转换和隐式转换。</p><ul class="list" id="-12458821#nyq9bm_117" start="1"><li class="list-item" id="-12458821#nyq9bm_137"><p id="-12458821#nyq9bm_138">显式转换：在shared_ptr和auto_ptr中都提供了一个get成员函数，它会返回智能指针内部的原始指针：</p><div class="detached code-block" id="-12458821#nyq9bm_139"><pre><code class="language-cpp">int days = daysHeld(pInv.get());  // 将pInv内的原始指针传给daysHeld</code></pre></div><ul class="list" id="-12458821#nyq9bm_140" start="1"><li class="list-item" id="-12458821#nyq9bm_141"><p id="-12458821#nyq9bm_142">隐式转换：在shared_ptr和auto_ptr中也重载了指针解引用(pointer dereferencing)操作符(operator-&gt;和operator*)，它们允许隐士转换至底部原始指针：</p><div class="detached code-block" id="-12458821#nyq9bm_143"><pre><code class="language-cpp">class Investment{ // investment 继承体系中的一个父类
public:
  bool isTaxFree() const;
  ...
};
{
  Investement* createInvestment();                    // 工厂函数
  std::shared_ptr&lt;Investment&gt; pi1(createInvestment());// 让shared_ptr管理资源
  bool taxable1 = !(pi1-&gt;isTaxFree());                // 通过operator-&gt;访问资源
  ...
  std::auto_ptr&lt;Investment&gt; pi2(createInvestment());  // 让auto_ptr管理资源
  bool taxable2 = ~((*pi2).isTaxFree());              // 通过operator*访问资源
}</code></pre></div></li></ul></li></ul><p id="-12458821#nyq9bm_118">如果需要取得RAII对象内的原始资源，就需要提供一个隐式转换函数，示例如下：</p><div class="detached code-block" id="-12458821#nyq9bm_119"><pre><code class="language-cpp">FontHandle getFont(); // 一个无参 C API

void releaseFont(FontHandle fh);  // 与上面一个来自同一个 C API

class Font{ // RAII class
public:
  explicit Font(FontHandle fh)  // 获取资源
  : f(fh)                       // 按值传递 pass by value 
  { }                           
  ~Font() { releaseFont(f); }   // 释放资源
private:
  FontHandle f;
};</code></pre></div><p id="-12458821#nyq9bm_120">如果有大量与Font相关的C API，它们处理的是FontHandle，那么就需要频繁地将Font对象转换为FontHandle。Font class可以为此提供一个显式转换函数，如：</p><div class="detached code-block" id="-12458821#nyq9bm_121"><pre><code class="language-cpp">class Font{
public:
  ...
  FontHandle get() const { return f; }  // 显式转换函数
  ...
};</code></pre></div><p id="-12458821#nyq9bm_122">这使得每次调用API时都需要使用get():</p><div class="detached code-block" id="-12458821#nyq9bm_123"><pre><code class="language-cpp">void changeFontSize(FontHandle f, int newSize); // C API
Font f(getFont());
int newFontSize();
...
changeFontSize(f.get(), newFontSize); // 显式地将Font转换为FontHandle</code></pre></div><p id="-12458821#nyq9bm_124">频繁地要求显式转换，会增加泄露字体风险的可能性，而Font class设计的初衷就是为了防止资源泄露。  另一种办法就是令Font提供隐式转换函数，转型为FontHandle：</p><div class="detached code-block" id="-12458821#nyq9bm_125"><pre><code class="language-cpp">class Font{
public:
  ...
  operator FontHandle() const // 隐式转换函数
  { return f; }
  ...
};

void f(FontHandle fh){
  ... /* 若接受一个Font类型的参数，其将会被隐式转换为FontHandle */
}</code></pre></div><p id="-12458821#nyq9bm_126">经过这样处理过，使得调用 C API 会比较方便：</p><div class="detached code-block" id="-12458821#nyq9bm_127"><pre><code class="language-cpp">Font f(getFont());
int newFontSize;
...
changeFontSize(f, newFontSize); // 隐式地将Font转换为FontHandle</code></pre></div><p id="-12458821#nyq9bm_128">但是这个隐式转换会增加错误出现的概率：</p><div class="detached code-block" id="-12458821#nyq9bm_129"><pre><code class="language-cpp">Font f1(getFont());
...
FontHandle f2 = f1; // 要将Font类型的f1拷贝给f2，却将f1的类型隐式转换成了FontHandle</code></pre></div><p id="-12458821#nyq9bm_130">因为FontHandle由Font对象f1管理，但是通过隐式转换，FontHandle也可以通过f2来访问，然而，如果f1被销毁，那么f2会变成一个悬空的对象，因为f2依赖于f1的资源管理。  是否提供一个显式转换或隐式转换函数将RAII class转换为其底部资源取决于RAII class被设计于执行在一个什么样的工作场景中。</p><p id="-12458821#nyq9bm_131">总结：</p><ul class="list" id="-12458821#nyq9bm_132" start="1"><li class="list-item" id="-12458821#nyq9bm_146"><p>API往往要求访问原始资源(raw resources)，所以每一个RAII class应该提供一个&quot;取得其所管理的资源&quot;的办法。</p></li><li class="list-item" id="-12458821#nyq9bm_147"><p>对原始资源的访问可能经由显示转换或隐式转换，其中显式转换可能会比较麻烦但是较安全，隐式转换较方便但是不太安全。</p></li></ul></section><section><h2 id="-12458821#16-new-delete" data-toc="16-new-delete#第三章-资源管理.md-16-new-delete">条款16：成对使用new和delete时要采取相同形式</h2><p id="-12458821#nyq9bm_148">思考下面这段代码有什么问题：</p><div class="detached code-block" id="-12458821#nyq9bm_149"><pre><code class="language-cpp">std::string* stringArray = new std::string[100];
...
delete stringArray;</code></pre></div><p id="-12458821#nyq9bm_150">这段代码虽然成对使用了new和delete，但其仍产生了未定义行为，stringArray中包含的100个string对象中的99个string无法被正常处理，因为它们的析构函数很可能没有被调用。  仔细分析一下，当使用new和delete时分别会发生什么事情：</p><ul class="list" id="-12458821#nyq9bm_151" start="1"><li class="list-item" id="-12458821#nyq9bm_163"><p>当使用new动态生成对象时，会发生两件事： </p><ul class="list" id="-12458821#nyq9bm_165" start="1"><li class="list-item" id="-12458821#nyq9bm_166"><p>第一，内存通过一个名为operator new的函数被分配出来。</p></li><li class="list-item" id="-12458821#nyq9bm_167"><p>第二，针对此内存段会有一个或多个构造函数被调用。</p></li></ul></li><li class="list-item" id="-12458821#nyq9bm_164"><p>当使用delete删除对象时，会发生两件事： </p><ul class="list" id="-12458821#nyq9bm_168" start="1"><li class="list-item" id="-12458821#nyq9bm_169"><p>第一，针对此内存段会有一个或多个析构函数被调用。</p></li><li class="list-item" id="-12458821#nyq9bm_170"><p>第二，此内存段通过一个名为operator delete的函数被释放。</p></li></ul></li></ul><p id="-12458821#nyq9bm_152">这个问题在于即将被删除的内存段中有多少个对象，这决定了最终需要调用多少个析构函数。  首先要考虑的问题：即将被删除的指针所指的是单一对象或对象数组，因为单一对象的内存布局一般而言不同于对象数组的内存布局，更确切的说， 数组所用的内存通常还包括&ldquo;数组大小&rdquo;的记录，以便delete知道需要调用多少次析构函数，而单一对象的内存则不需要记录这点，关于单一对象和对象数组的布局可以抽象如下：</p><div class="detached code-block" id="-12458821#nyq9bm_153"><pre><code class="language-none">|
|        __________
单一对象 | Object  |
|        __________
|        ____________________________________________
对象数组 | n | Object0 | Object1 | ... | Object(n-1) |
|        ____________________________________________
|</code></pre></div><p id="-12458821#nyq9bm_154">对一个对象数组使用delete，能够准确让delete知道要删除的数组大小的方法就是直接告诉它：</p><div class="detached code-block" id="-12458821#nyq9bm_155"><pre><code class="language-cpp">std::string* stringPtr1 = new std::string;
std::string* stringPtr2 = new std::string[100];
...
delete stringPtr1;    // 删除一个对象
delete [] stringPtr2; // 删除一个对象数组</code></pre></div><p id="-12458821#nyq9bm_156">对一个对象数组使用delete[]进行销毁和对单个对象使用delete进行销毁是正确的操作。  如果对单个对象使用delete[]进行销毁，会让delete认为这单个对象是一个对象数组，会使其多次调用析构函数，产生一些未定义行为，所以这是不可取的。  当然，如开头所说，对一个对象数组使用delete进行销毁，导致对象数组没有被完全销毁，进而产生未定义行为，对于一些内置类型例如int创建的数组没有使用delete[]那将会产生更糟的结果。  显而易见，当使用new动态创建对象时，使用了[]那么在使用delete进行销毁使也要对应使用[]，否则，就不要使用。  当一个有着指向动态分配内存的指针的class时，并实现了多个构造函数时，切记在所有构造函数中使用相同的new方式动态创建对象，否则，析构函数无法知道使用什么形式的delete与其对应。</p><p id="-12458821#nyq9bm_157">在使用typedef时也要注意上面这点：</p><div class="detached code-block" id="-12458821#nyq9bm_158"><pre><code class="language-cpp">typedef std::string AddressLines[4];
/* 相当于 std::string* AddressLines = new std::string[4]; */
std::string* pal = new AddressLines;

delete pal;   // 对对象数组使用delete，产生未定义行为
delete[] pal;</code></pre></div><p id="-12458821#nyq9bm_159">提示：在实际使用的时候，为避免因为使用typedef导致的问题，可以使用string, vector等templates进行替代，降低出错风险的概率，</p><p id="-12458821#nyq9bm_160">总结：</p><ul class="list" id="-12458821#nyq9bm_161" start="1"><li class="list-item" id="-12458821#nyq9bm_176"><p>使用new动态创建对象时，如果创建的是单个对象，那么就应该使用delete对其进行销毁，如果创建的是多个对象，那么就应该使用delete[]对其进行销毁。</p></li></ul></section><section><h2 id="-12458821#17-newed" data-toc="17-newed#第三章-资源管理.md-17-newed">条款17：以独立语句将newed对象置入智能指针</h2><p id="-12458821#nyq9bm_177">假设存在一个函数用来体现程序处理的优先权，另一个函数用来在某动态分配所得的Widget上进行某些带有优先权的处理：</p><div class="detached code-block" id="-12458821#nyq9bm_178"><pre><code class="language-cpp">int priority();
void processWidget(std::shared_ptr&lt;Widget&gt; pw, int priority);</code></pre></div><p id="-12458821#nyq9bm_179">现在调用processWidget，一种错误的写法:</p><div class="detached code-block" id="-12458821#nyq9bm_180"><pre><code class="language-cpp">processWidget(new Widget, priority());</code></pre></div><p id="-12458821#nyq9bm_181">此处的shared_ptr构造函数需要一个裸指针(raw pointer)，但构造函数是一个explicit构造函数，无法进行隐式转换，现将new Widget的裸指针转换为processWidget所需要的shared_ptr：</p><div class="detached code-block" id="-12458821#nyq9bm_182"><pre><code class="language-cpp">processWidget(
          std::shared_ptr&lt;Widget&gt;(new Widget), 
          priority()
          );</code></pre></div><p id="-12458821#nyq9bm_183">这种使用方法仍然不是安全的，对于第一个实参<span class="inline-code" id="-12458821#nyq9bm_194">std::shared_ptr&lt;Widget&gt;(new Widget)</span>分析，其由两部分组成：</p><ul class="list" id="-12458821#nyq9bm_184" start="1"><li class="list-item" id="-12458821#nyq9bm_195"><p>执行 new Widget 表达式</p></li><li class="list-item" id="-12458821#nyq9bm_196"><p>调用 shared_ptr 构造函数</p></li></ul><p id="-12458821#nyq9bm_185">在调用processWidget之前，编译器需创建代码，其会做以下三件事：</p><ul class="list" id="-12458821#nyq9bm_186" start="1"><li class="list-item" id="-12458821#nyq9bm_197"><p>调用 priority</p></li><li class="list-item" id="-12458821#nyq9bm_198"><p>执行 new Widget</p></li><li class="list-item" id="-12458821#nyq9bm_199"><p>调用 shared_ptr 构造函数</p></li></ul><p id="-12458821#nyq9bm_187">分析一下此处编译器执行的顺序，可以确定的是 new Widget 会在 shared_prt 构造函数调用之前执行，因为这个表达式的结果还要作为一个实参传给shared_ptr的构造函数，一个可能的执行顺序如下：</p><ol class="list list-decimal" id="-12458821#nyq9bm_188" type="1" start="1"><li class="list-item" id="-12458821#nyq9bm_200"><p>执行 new Widget</p></li><li class="list-item" id="-12458821#nyq9bm_201"><p>调用 priority</p></li><li class="list-item" id="-12458821#nyq9bm_202"><p>调用 shared_ptr构造函数</p></li></ol><p id="-12458821#nyq9bm_189">此时，如果priority()的调用出现了异常，那么 new Widget 返回的指针就会丢失。  由于在资源被创建和资源被转换为资源管理对象这个两个过程之间难免会出现异常的干扰，为了避免这样的问题，可以使用分离语句：</p><ol class="list list-decimal" id="-12458821#nyq9bm_190" type="1" start="1"><li class="list-item" id="-12458821#nyq9bm_204"><p>创建Widget</p></li><li class="list-item" id="-12458821#nyq9bm_205"><p>将它置入一个智能指针内</p></li><li class="list-item" id="-12458821#nyq9bm_206"><p>将智能指针传给processWidget：</p></li></ol><div class="detached code-block" id="-12458821#nyq9bm_191"><pre><code class="language-cpp">/* 智能指针存储newed所得的对象 */
std::shared_ptr&lt;Widget&gt; pw(new Widget);
processWidget(pw, priority());
/* 这样就可以规定编译器的执行的顺序 */</code></pre></div><p id="-12458821#nyq9bm_192">总结：</p><ul class="list" id="-12458821#nyq9bm_193" start="1"><li class="list-item" id="-12458821#nyq9bm_207"><p>以独立语句将newed对象存储入智能指针内，否则，一旦异常抛出，很可能出现难以察觉的资源泄露。</p></li></ul></section></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="539570669">第四章 设计与声明</h1><p id="539570669#d8fn4_3">Start typing here...</p></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="-298164730">STL源码分析</h1><section><h2 id="-298164730#stl" data-toc="stl#STL源码分析.md-stl">第一章 STL概述</h2><section><h3 id="-298164730#c" data-toc="c#STL源码分析.md-c">可能令你困惑的C++语法</h3><ol class="list list-decimal" id="-298164730#-vni64p_6" type="1" start="1"><li class="list-item" id="-298164730#-vni64p_79"><p>类里面的static成员</p></li></ol><p id="-298164730#-vni64p_7">当使用模板类初始化多个实例时，这些实例共享这个模板（同类型）类的static成员。</p><div class="detached code-block" id="-298164730#-vni64p_8"><pre><code class="language-cpp">#include &lt;iostream&gt;

template&lt;typename T&gt;
class myClass
{
public:
	static int i1_;
	static float f1_;
};

// int type template
int myClass&lt;int&gt;::i1_ = 1;
float myClass&lt;int&gt;::f1_ = 1.1f;

// float type template
int myClass&lt;float&gt;::i1_ = 2;
float myClass&lt;float&gt;::f1_ = 2.2f;

int main()
{
	myClass&lt;int&gt; ic1_, ic2_;
	myClass&lt;float&gt; fc1_, fc2_;

	std::cout 
	    &lt;&lt; ic1_.i1_ &lt;&lt; ' '
		&lt;&lt; ic1_.f1_ &lt;&lt; ' '
		&lt;&lt; ic2_.i1_ &lt;&lt; ' '
		&lt;&lt; ic2_.f1_ &lt;&lt; ' '
		&lt;&lt; fc1_.i1_ &lt;&lt; ' '
		&lt;&lt; fc1_.f1_ &lt;&lt; ' '
		&lt;&lt; fc2_.i1_ &lt;&lt; ' '
		&lt;&lt; fc2_.f1_ &lt;&lt; ' ';
	return 0;
}</code></pre></div><p id="-298164730#-vni64p_9">综上可知，当对ic1_实例的i1_成员进行操作时，i2_对应的成员也会发生变化， 因为它们使用的是同一个模板类<span class="inline-code" id="-298164730#-vni64p_80">myClass&lt;int&gt;</span> ，同理，fc1_和fc2_也如此。</p><ol class="list list-decimal" id="-298164730#-vni64p_10" type="1" start="2"><li class="list-item" id="-298164730#-vni64p_81"><p>模板类的特殊设计</p></li></ol><p id="-298164730#-vni64p_11">初始化实例时，编译器会根据提供的指针的类型进行匹配。</p><div class="detached code-block" id="-298164730#-vni64p_12"><pre><code class="language-cpp">#include &lt;iostream&gt;

// generalized
template&lt;class T, class O&gt;
struct tc
{
	tc() { std::cout &lt;&lt; &quot;I, O&quot; &lt;&lt; '\n'; }
};

// specialized 
template&lt;class T&gt;
struct tc&lt;T*, T*&gt;
{
	tc() { std::cout &lt;&lt; &quot;T*, T*&quot; &lt;&lt; '\n'; }
};

// specialized
template&lt;class T&gt;
struct tc&lt;const T*, T*&gt;
{
	tc() { std::cout &lt;&lt; &quot;const T*, T*&quot; &lt;&lt; '\n'; }
};

int main()
{
	tc&lt;int, char&gt; obj1;
	tc&lt;int*, int*&gt; obj2;
	tc&lt;const int*, int*&gt; obj3;
	tc&lt;const int*, const int*&gt; obj4;
	tc&lt;int*, const int*&gt; obj5;
	return 0;
}</code></pre></div><p id="-298164730#-vni64p_13">输出结果：</p><div class="container"><figure class="image-container"><img class="center image image-size" id="-298164730#-vni64p_14" alt="image_10.png" title="image_10.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/image_10.png" width="147" height="112"><figcaption class="center-text">image_10.png</figcaption></figure></div><p id="-298164730#-vni64p_15">若匹配不到，则会自动选择默认模板类。</p><ol class="list list-decimal" id="-298164730#-vni64p_16" type="1" start="3"><li class="list-item" id="-298164730#-vni64p_82"><p>模板类中可再存在模板成员</p></li></ol><div class="detached code-block" id="-298164730#-vni64p_17"><pre><code class="language-cpp">#include &lt;iostream&gt;

class alloc{};

template&lt;class T, class Alloc = alloc&gt;
class vector{                       // template class
public:
    typedef T value_type;           // T -&gt; value_type
    typedef value_type* iterator;   // value_type* -&gt; iterator
    
    template&lt;class I&gt;               // template member function
    void insert(iterator position, I first, I last){ std:: cout &lt;&lt; &quot;insert()&quot; &lt;&lt; '\n'; }
};

int main(){
    int ia[5] = {0, 1, 2, 3, 4};
    
    vector&lt;int&gt; x;
    vector&lt;int&gt;::iterator ite = nullptr;
    x.insert(ite, ia, ia + 5);

    return 0;
}</code></pre></div><ol class="list list-decimal" id="-298164730#-vni64p_18" type="1" start="4"><li class="list-item" id="-298164730#-vni64p_83"><p>template 参数可以根据前一个 template 参数而设定默认值</p></li></ol><div class="detached code-block" id="-298164730#-vni64p_19"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstddef&gt;

class alloc {};

template&lt;class T, class Alloc = alloc, size_t BufSiz = 0&gt;
class deque{
public:
    deque() { std::cout &lt;&lt; &quot;deque()&quot; &lt;&lt; '\n'; }
};

// 根据前一个参数值T， 设定下一个参数Sequence的默认值为deque&lt;T&gt;
template&lt;class T, class Sequence = deque&lt;T&gt;&gt;
class stack {
public: stack() { std::cout &lt;&lt; &quot;stack()&quot; &lt;&lt; '\n'; }
private: Sequence c;
};

int main() {
    stack&lt;int&gt; x;
    return 0;
}</code></pre></div><p id="-298164730#-vni64p_20">输出结果：</p><div class="container"><figure class="image-container"><img class="center image image-size" id="-298164730#-vni64p_21" alt="image_11.png" title="image_11.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/image_11.png" width="68" height="41"><figcaption class="center-text">image_11.png</figcaption></figure></div><p id="-298164730#-vni64p_22">由输出结果可以看出，在初始化stack实例时，stack内的Sequence会先根据模板内的参数初始化一个deque实例，再实例化stack。</p><p id="-298164730#-vni64p_23">综上可知，当初始化一个模板类时，模板类中的模板中若有其他模板类，会优先初始其他化模板类对应的实例。</p><p id="-298164730#-vni64p_24">示例1，如下所示：</p><div class="detached code-block" id="-298164730#-vni64p_25"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstddef&gt;

class alloc {};

template&lt;class T, class Alloc = alloc, size_t BufSiz = 0&gt;
class deque{
public:
    deque() { std::cout &lt;&lt; &quot;deque()&quot; &lt;&lt; '\n'; }
};

// 先初始化deque的实例
template&lt;class T, class Sequence = deque&lt;T&gt;&gt;
class stack {
public: stack() { std::cout &lt;&lt; &quot;stack()&quot; &lt;&lt; '\n'; }
private: Sequence c;
};

// 先初始化stack的实例
template&lt;class T, class Test = stack&lt;T&gt;&gt;
class test
{
public:
    test() { std::cout &lt;&lt; &quot;test()&quot; &lt;&lt; '\n'; }
private:
    Test t;
};

int main() {
    test&lt;int&gt; t_;
    return 0;
}</code></pre></div><p id="-298164730#-vni64p_26">输出结果：</p><div class="container"><figure class="image-container"><img class="center image image-size" id="-298164730#-vni64p_27" alt="image_12.png" title="image_12.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/image_12.png" width="82" height="61"><figcaption class="center-text">image_12.png</figcaption></figure></div><p id="-298164730#-vni64p_28">示例2，如下所示</p><div class="detached code-block" id="-298164730#-vni64p_29"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstddef&gt;

class alloc {};

template&lt;class T, class Alloc = alloc, size_t BufSiz = 0&gt;
class deque{
public:
    deque() { std::cout &lt;&lt; &quot;deque()&quot; &lt;&lt; '\n'; }
};

template&lt;class T, class Test = deque&lt;T&gt;&gt;
class test
{
public:
    test() { std::cout &lt;&lt; &quot;test()&quot; &lt;&lt; '\n'; }
private:
    Test t;
};

template&lt;class T, class Sequence = deque&lt;T&gt;, class test_ = test&lt;T&gt;&gt;
class stack {
public: stack() { std::cout &lt;&lt; &quot;stack()&quot; &lt;&lt; '\n'; }
private: Sequence c; test_ _t;
};

int main() {
    stack&lt;int&gt; t_;
    return 0;
}</code></pre></div><p id="-298164730#-vni64p_30">结果如下：</p><div class="container"><figure class="image-container"><img class="center image image-size" id="-298164730#-vni64p_31" alt="image_13.png" title="image_13.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/image_13.png" width="69" height="75"><figcaption class="center-text">image_13.png</figcaption></figure></div><p id="-298164730#-vni64p_32">过程推导：</p><ul class="list" id="-298164730#-vni64p_33" start="1"><li class="list-item" id="-298164730#-vni64p_84"><p>实例化deque -&gt; deque()</p></li><li class="list-item" id="-298164730#-vni64p_85"><p>实例化test_, 但实例化test_前需实例化deque -&gt; deque()</p></li><li class="list-item" id="-298164730#-vni64p_86"><p>实例化test_完成 -&gt; test()</p></li><li class="list-item" id="-298164730#-vni64p_87"><p>实例化stack完成 -&gt; stack()</p></li></ul><ol class="list list-decimal" id="-298164730#-vni64p_34" type="1" start="5"><li class="list-item" id="-298164730#-vni64p_88"><p>模板类可拥有Non-type的模板参数</p></li></ol><div class="detached code-block" id="-298164730#-vni64p_35"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstddef&gt;

class alloc {};

inline size_t __deque_buf_size(size_t n, size_t sz) {
    return n != 0 ? n : (sz &lt; 512) ? size_t(512 / sz) : size_t(1);
}

template&lt;class T, class Ref, class Ptr, size_t BufSiz&gt;
struct __deque_iterator {
    typedef __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt; iterator;
    typedef __deque_iterator&lt;T, const T&amp;, const T*, BufSiz&gt; const_iterator;
    static size_t buffer_size() { return __deque_buf_size(BufSiz, sizeof(T)); }
};

template&lt;class T, class Alloc = alloc, size_t BufSiz = 0&gt;
class deque {
public: typedef __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt; iterator;
};

int main() {
    std::cout &lt;&lt; deque&lt;int&gt;::iterator::buffer_size() &lt;&lt; '\n';
    std::cout &lt;&lt; deque&lt;int, alloc, 64&gt;::iterator::buffer_size() &lt;&lt; '\n';
    return 0;
}</code></pre></div><p id="-298164730#-vni64p_36">在类<span class="inline-code" id="-298164730#-vni64p_89">deque</span>中的成员<span class="inline-code" id="-298164730#-vni64p_90">iterator</span>初始化时利用模板中的参数<span class="inline-code" id="-298164730#-vni64p_91">BufSiz</span>是一个<span class="inline-code" id="-298164730#-vni64p_92">value</span>而不是一个<span class="inline-code" id="-298164730#-vni64p_93">type</span>。</p><p id="-298164730#-vni64p_37">由此可知，模板接受非类型<span class="inline-code" id="-298164730#-vni64p_94">non-type</span>的参数。</p><ol class="list list-decimal" id="-298164730#-vni64p_38" type="1" start="6"><li class="list-item" id="-298164730#-vni64p_95"><p>Bound Friend Template</p></li></ol><p id="-298164730#-vni64p_39">类模板的某个具体实例(instantiation)与其友元函数模板的具体实例(instantiation)一一对应。</p><div class="detached code-block" id="-298164730#-vni64p_40"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstddef&gt;

class alloc {};

template&lt;class T, class Alloc = alloc, size_t  BufSiz = 0&gt;
class deque{
public: deque() { std::cout &lt;&lt; &quot;deque()&quot; &lt;&lt; '\n'; }
};

template&lt;class T, class Sequence&gt;
class stack;

template&lt;class T, class Sequence&gt;
bool operator==(const stack&lt;T, Sequence&gt;&amp; x, const stack&lt;T, Sequence&gt;&amp; y);

template&lt;class T, class Sequence&gt;
bool operator&lt;(const stack&lt;T, Sequence&gt;&amp; x, const stack&lt;T, Sequence&gt;&amp; y);

template&lt;class T, class Sequence = deque&lt;T&gt;&gt;
class stack{
    // style 1
    friend bool operator== &lt;T&gt; (const stack&lt;T&gt;&amp; , const stack&lt;T&gt;&amp; );
    friend bool operator&lt; &lt;T&gt; (const stack&lt;T&gt;&amp; , const stack&lt;T&gt;&amp; );
    // style 2
    friend bool operator== &lt;T&gt; (const stack&amp;, const stack&amp;);
    friend bool operator&lt; &lt;T&gt; (const stack&amp;, const stack&amp;);
    // style 3
    friend bool operator== &lt;&gt; (const stack&amp;, const stack&amp;);
    friend bool operator&lt; &lt;&gt; (const stack&amp;, const stack&amp;);
    // invalid style
    //friend bool operator== (const stack&amp;, const stack&amp;);
    //friend bool operator&lt; (const stack&amp;, const stack&amp;);
public: stack() { std::cout &lt;&lt; &quot;stack()&quot; &lt;&lt; '\n'; }
private: Sequence c;
};

template&lt;class T, class Sequence&gt;
bool operator==(const stack&lt;T, Sequence&gt;&amp; x, const stack&lt;T, Sequence&gt;&amp; y){
    std::cout &lt;&lt; &quot;operator==()&quot; &lt;&lt; '\t';
    return true;
}

template&lt;class T, class Sequence&gt;
bool operator&lt; (const stack&lt;T, Sequence&gt;&amp; x, const stack&lt;T, Sequence&gt;&amp; y){
    std::cout &lt;&lt; &quot;operator&lt;()&quot; &lt;&lt; '\t';
    return true;
}

int main(){
    stack&lt;int&gt; x;
    stack&lt;int&gt; y;
    
    std::cout &lt;&lt; (x == y) &lt;&lt; '\n';
    std::cout &lt;&lt; (x &lt; y) &lt;&lt; '\n';

    //stack&lt;int&gt; y_;
    // invalid
    // std::cout &lt;&lt; (x == y_) &lt; '\n';   // no match for this
    // std::cout &lt;&lt; (x &lt; y_) &lt;&lt; '\n';   // no match for this

    return 0;
}</code></pre></div><p id="-298164730#-vni64p_41">一般步骤：在模板类内用友元函数声明要重载的运算符，（必须）再对声明的重载友元函数进行实现。</p><p id="-298164730#-vni64p_42">输出结果：</p><div class="container"><figure class="image-container"><img class="center image image-size" id="-298164730#-vni64p_43" alt="image_14.png" title="image_14.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/image_14.png" width="170" height="113"><figcaption class="center-text">image_14.png</figcaption></figure></div><ol class="list list-decimal" id="-298164730#-vni64p_44" type="1" start="7"><li class="list-item" id="-298164730#-vni64p_96"><p>类模板显式声明</p></li></ol><div class="detached code-block" id="-298164730#-vni64p_45"><pre><code class="language-cpp">#include &lt;iostream&gt;

#define __STL_TEMPLATE_NULL template&lt;&gt;

template&lt;class Key&gt;
struct hash{
    void operator() () { std::cout &lt;&lt; &quot;hash&lt;T&gt;&quot; &lt;&lt; '\n'; }
};

// explicit specialization
__STL_TEMPLATE_NULL struct hash&lt;char&gt;{
    void operator() () { std::cout &lt;&lt; &quot;hash&lt;char&gt;&quot; &lt;&lt; '\n'; }
};

__STL_TEMPLATE_NULL struct hash&lt;unsigned char&gt;{
    void operator() () { std::cout &lt;&lt; &quot;hash&lt;unsigned char&gt;&quot; &lt;&lt; '\n'; }
};

int main(){
    hash&lt;long&gt; t1;
    hash&lt;char&gt; t2;
    hash&lt;unsigned char&gt; t3;
    
    t1();
    t2();
    t3();
    
    return 0;
}</code></pre></div><p id="-298164730#-vni64p_46">输出结果：</p><div class="container"><figure class="image-container"><img class="center image image-size" id="-298164730#-vni64p_47" alt="image_15.png" title="image_15.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/image_15.png" width="196" height="63"><figcaption class="center-text">image_15.png</figcaption></figure></div><div class="detached code-block" id="-298164730#-vni64p_48"><pre><code class="language-cpp">hash&lt;long&gt; -&gt; hash&lt;T&gt; ∵hash&lt;long&gt;并没有被显式声明，故调用默认模板

hash&lt;char&gt; -&gt; hash&lt;char&gt; ∵hash&lt;char&gt;已经被显式声明，故调用特定模板

hash&lt;unsigned char&gt; -&gt; hash&lt;unsigned char&gt; 原因同上</code></pre></div><p id="-298164730#-vni64p_49">通过这样的做法，可以自定义不同类型模板类的行为。</p><ol class="list list-decimal" id="-298164730#-vni64p_50" type="1" start="8"><li class="list-item" id="-298164730#-vni64p_97"><p>临时对象的产生与运用</p></li></ol><div class="detached code-block" id="-298164730#-vni64p_51"><pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

template&lt;typename T&gt;
class print{
public: void operator() (const T&amp; elem) { std::cout &lt;&lt; elem &lt;&lt; ' '; }
};

int main(){
    int ia[6] = {0, 1, 2, 3, 4, 5, 6};
    std::vector&lt;int&gt; iv(ia, ia + 5);
    // print&lt;int&gt; is an unnamed object but not a invoking operation
    std::for_each(iv.begin(), iv.end(), print&lt;int&gt;());

    return 0;
}</code></pre></div><p id="-298164730#-vni64p_52">临时对象即无名对象(unnamed objects)。 实现方法</p><p id="-298164730#-vni64p_53">对()符号进行重载： <span class="inline-code" id="-298164730#-vni64p_98">void operator() (const T&amp; elem) { std::cout &lt;&lt; elem &lt;&lt; ' '; }</span></p><p id="-298164730#-vni64p_54">不需声明指定对象名称，直接通过()进行调用<span class="inline-code" id="-298164730#-vni64p_99">std::for_each(iv.begin(), iv.end(), print&lt;int&gt;());</span></p><p id="-298164730#-vni64p_55">此临时对象的生命周期</p><div class="table-wrapper detached"><table id="-298164730#-vni64p_56"><tr class="header-row" id="-298164730#-vni64p_100"><th id="-298164730#-vni64p_103"><p>状态</p></th><th id="-298164730#-vni64p_104"><p>动作</p></th></tr><tr class="" id="-298164730#-vni64p_101"><td id="-298164730#-vni64p_105"><p>开始</p></td><td id="-298164730#-vni64p_106"><p><span class="inline-code" id="-298164730#-vni64p_107">for_each()(或其他函数)第一次调用print&lt;int&gt;()(临时对象)</span></p></td></tr><tr class="" id="-298164730#-vni64p_102"><td id="-298164730#-vni64p_108"><p>结束</p></td><td id="-298164730#-vni64p_109"><p><span class="inline-code" id="-298164730#-vni64p_110">for_each()结束时</span></p></td></tr></table></div><ol class="list list-decimal" id="-298164730#-vni64p_57" type="1" start="9"><li class="list-item" id="-298164730#-vni64p_111"><p>静态常量成员在class内部直接初始化</p></li></ol><div class="detached code-block" id="-298164730#-vni64p_58"><pre><code class="language-cpp">#include &lt;iostream&gt;

template&lt;typename T&gt;
class testClass{
    public: expedient
    static const int _datai = 5;
    static const long _datal = 3l;
    static const char _datac = 'c';
};

int main(){
    std::cout &lt;&lt; testClass&lt;int&gt;::_datai &lt;&lt; '\n';
    std::cout &lt;&lt; testClass&lt;long&gt;::_datal &lt;&lt; '\n';
    std::cout &lt;&lt; testClass&lt;char&gt;::_datac &lt;&lt; '\n;

    return 0;
}</code></pre></div><ol class="list list-decimal" id="-298164730#-vni64p_59" type="1" start="10"><li class="list-item" id="-298164730#-vni64p_112"><p>increment/decrement/dereference 操作符</p></li></ol><p id="-298164730#-vni64p_60">此类操作符可用于迭代器(iterator)的指针的移动或取值(dereference)。</p><p id="-298164730#-vni64p_61">移动操作可分为前置(prefix)和后置(postfix)。</p><div class="detached code-block" id="-298164730#-vni64p_62"><pre><code class="language-cpp">#include &lt;iostream&gt;

class INT{
    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const INT&amp; i);
public: INT(int i): m_i(i) {};
    
    // prefix: increment and then fetch
    INT&amp; operator++(){
        ++(this-&gt;m_i);
        return *this;
    }
    
    // postfix: fetch and then increment
    const INT operator++(int){
        INT temp = *this;
        ++(*this);
        return temp;
    }
    
    // prefix: minus and then fetch
    INT&amp; operator--(){
        --(this-&gt;m_i);
        return *this;
    }
    
    // postfix: fetch and then increment
    const INT operator--(int){
        INT temp = *this;
        --(*this);
        return temp;
    }
    
    // deference
    int&amp; operator*() const{
        std::cout &lt;&lt; &quot;dereference&quot; &lt;&lt; '\n';
        return (int&amp;)m_i;
    }
    
private: int m_i;
};

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const INT&amp; i){
    os &lt;&lt; '[' &lt;&lt; i.m_i &lt;&lt; ']';
    return os;
}

int main(){
    INT I(5);
    std::cout &lt;&lt; I++ &lt;&lt; '\n';
    std::cout &lt;&lt; ++I &lt;&lt; '\n';
    std::cout &lt;&lt; I-- &lt;&lt; '\n';
    std::cout &lt;&lt; --I &lt;&lt; '\n';
    std::cout &lt;&lt; *I &lt;&lt; '\n';
    return 0;
}</code></pre></div><p id="-298164730#-vni64p_63">输出结果：</p><div class="container"><figure class="image-container"><img class="center image image-size" id="-298164730#-vni64p_64" alt="image_16.png" title="image_16.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/image_16.png" width="39" height="105"><figcaption class="center-text">image_16.png</figcaption></figure></div><p id="-298164730#-vni64p_65">分析：</p><ul class="list" id="-298164730#-vni64p_66" start="1"><li class="list-item" id="-298164730#-vni64p_113"><p><span class="control" id="-298164730#-vni64p_114">prefix increment</span> ：即前置++，类似地像<span class="inline-code" id="-298164730#-vni64p_115">++i</span>这样的，优先对i进行操作后再使用。</p></li></ul><div class="detached code-block" id="-298164730#-vni64p_67"><pre><code class="language-cpp">// prefix: increment and then fetch
   INT&amp; operator++(){
       ++(this-&gt;m_i);
       return *this;
   }</code></pre></div><ul class="list" id="-298164730#-vni64p_68" start="1"><li class="list-item" id="-298164730#-vni64p_116"><p><span class="control" id="-298164730#-vni64p_117">postfix increment</span> ：即后置++，类似地像<span class="inline-code" id="-298164730#-vni64p_118">i++</span>这样的，优先使用i后，再对其进行操作。</p></li></ul><div class="detached code-block" id="-298164730#-vni64p_69"><pre><code class="language-cpp">// postfix: fetch and then increment
  const INT operator++(int){
      INT temp = *this;   // 声明一个临时对象temp用于存储要操作的目标对象，即还没被操作的目标对象
      ++(*this);
      return temp;        // 返回没有被操作的目标对象
  }</code></pre></div><ul class="list" id="-298164730#-vni64p_70" start="1"><li class="list-item" id="-298164730#-vni64p_119"><p><span class="control" id="-298164730#-vni64p_120">dereference</span> ：即解引用，返回目标对象的对应类型的地址。</p></li></ul><div class="detached code-block" id="-298164730#-vni64p_71"><pre><code class="language-cpp">// deference
int&amp; operator*() const{
    std::cout &lt;&lt; &quot;dereference&quot; &lt;&lt; '\n';
    return (int&amp;)m_i;
}</code></pre></div><ol class="list list-decimal" id="-298164730#-vni64p_72" type="1" start="11"><li class="list-item" id="-298164730#-vni64p_121"><p>前闭后开区间表示法 <span class="control" id="-298164730#-vni64p_122">[ )</span></p></li></ol><div class="detached code-block" id="-298164730#-vni64p_73"><pre><code class="language-cpp">template&lt;class Iterator, class T&gt;
InputIterator find(Iterator first, Iterator Last, const T&amp; value){
    while(first != last &amp; *first != value) ++first;
    return first;
}

template&lt;class InputIterator, class Function&gt;
Function for_each(InputIterator first, InputIterator last, Function f){
    for(; first != last; ++first) f(*first)
    return f;
}</code></pre></div><p id="-298164730#-vni64p_74">前闭后开即 <span class="control" id="-298164730#-vni64p_123">[first, last)</span>, 让指针从first开始 而达不到last(last的前一个位置 =&gt; last - 1)。</p><div class="container"><figure class="image-container"><img class="center image image-size" id="-298164730#-vni64p_75" alt="image_17.png" title="image_17.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/image_17.png" width="429" height="184"><figcaption class="center-text">image_17.png</figcaption></figure></div><ol class="list list-decimal" id="-298164730#-vni64p_76" type="1" start="12"><li class="list-item" id="-298164730#-vni64p_124"><p>function call操作符(operator())</p></li></ol><div class="detached code-block" id="-298164730#-vni64p_77"><pre><code class="language-cpp">#include &lt;iostream&gt;

template&lt;class T&gt;
struct plus{
    T operator() (const T&amp; x, const T&amp; y) const { return x + y; }
};

template&lt;class T&gt;
struct minus{
    T operator() (const T&amp; x, const T&amp; y) const { return x - y; }
};

int main(){
    plus&lt;int&gt; plusobj;      // functor object of plus
    minus&lt;int&gt; minusobj;    // functor object of minus
    
    // invoke the functor by the corresponding instances
    std::cout &lt;&lt; plusobj(5, 10) &lt;&lt; '\n';
    std::cout &lt;&lt; minusobj(10, 5) &lt;&lt; '\n';
    
    // create the temporary object as the functor
    std::cout &lt;&lt; plus&lt;int&gt;()(30, 20) &lt;&lt; '\n';
    std::cout &lt;&lt; minus&lt;int&gt;()(210, 10) &lt;&lt; '\n';
    
    return 0;
}</code></pre></div><p id="-298164730#-vni64p_78">此处对各模板类的 <span class="control" id="-298164730#-vni64p_125">()</span> 进行了重载，使之成为了一个仿函数(functor)</p></section></section><section><h2 id="-298164730#allocator" data-toc="allocator#STL源码分析.md-allocator">第二章 空间配置器(allocator)</h2><section><h3 id="-298164730#-vni64p_126" data-toc="-vni64p_126#STL源码分析.md--vni64p_126">空间配置器的标准接口</h3><p id="-298164730#-vni64p_147">一般接口(generalized)</p><p id="-298164730#-vni64p_148"><span class="inline-code" id="-298164730#-vni64p_156">allocator::value_type  </span><span class="inline-code" id="-298164730#-vni64p_158">allocator::pointer  </span><span class="inline-code" id="-298164730#-vni64p_160">allocator::const_pointer  </span><span class="inline-code" id="-298164730#-vni64p_162">allocator::reference  </span><span class="inline-code" id="-298164730#-vni64p_164">allocator::const_reference  </span><span class="inline-code" id="-298164730#-vni64p_166">allocator::size_type  </span><span class="inline-code" id="-298164730#-vni64p_168">allocator::difference_type  </span></p><p id="-298164730#-vni64p_149">特殊化接口(specified)</p><div class="table-wrapper detached"><table id="-298164730#-vni64p_150"><tr class="header-row" id="-298164730#-vni64p_169"><th id="-298164730#-vni64p_180"><p>接口</p></th><th id="-298164730#-vni64p_181"><p>作用</p></th></tr><tr class="" id="-298164730#-vni64p_170"><td id="-298164730#-vni64p_182"><p><span class="inline-code" id="-298164730#-vni64p_184">allocator::rebind</span></p></td><td id="-298164730#-vni64p_183"><p>旨在帮助allocator为<span class="control" id="-298164730#-vni64p_185">不同类型</span>的元素分配空间，即使allocator已被指定为一个对象分配空间。</p></td></tr><tr class="" id="-298164730#-vni64p_171"><td id="-298164730#-vni64p_186"><p><span class="inline-code" id="-298164730#-vni64p_188">allocator::allocator()</span></p></td><td id="-298164730#-vni64p_187"><p>默认构造函数</p></td></tr><tr class="" id="-298164730#-vni64p_172"><td id="-298164730#-vni64p_189"><p><span class="inline-code" id="-298164730#-vni64p_191">allocator::allocator(const allocator&amp;)</span></p></td><td id="-298164730#-vni64p_190"><p>拷贝函数</p></td></tr><tr class="" id="-298164730#-vni64p_173"><td id="-298164730#-vni64p_192"><p><span class="inline-code" id="-298164730#-vni64p_194">template&lt;class U&gt;allocator::allocator(const allocator&lt;U&gt;&amp;)</span></p></td><td id="-298164730#-vni64p_193"><p>泛型拷贝函数</p></td></tr><tr class="" id="-298164730#-vni64p_174"><td id="-298164730#-vni64p_195"><p><span class="inline-code" id="-298164730#-vni64p_197">allocator::~allocator()</span></p></td><td id="-298164730#-vni64p_196"><p>默认析构函数</p></td></tr><tr class="" id="-298164730#-vni64p_175"><td id="-298164730#-vni64p_198"><p><span class="inline-code" id="-298164730#-vni64p_200">pointer allocator::address(reference x) const</span></p></td><td id="-298164730#-vni64p_199"><p>返回指定对象的地址，例如：a.address(x) &lt;=&gt; &amp;x</p></td></tr><tr class="" id="-298164730#-vni64p_176"><td id="-298164730#-vni64p_201"><p><span class="inline-code" id="-298164730#-vni64p_203">pointer allocator::allocate(size_type n, const void* = 0)</span></p></td><td id="-298164730#-vni64p_202"><p>配置空间，用来存储n个类型为T的对象，第二个参数主要用于优化内存优化和管理</p></td></tr><tr class="" id="-298164730#-vni64p_177"><td id="-298164730#-vni64p_204"><p><span class="inline-code" id="-298164730#-vni64p_206">allocator::deallocate(pointer p, size_type n)</span></p></td><td id="-298164730#-vni64p_205"><p>释放之前所分配的内存</p></td></tr><tr class="" id="-298164730#-vni64p_178"><td id="-298164730#-vni64p_207"><p><span class="inline-code" id="-298164730#-vni64p_209">allocator::allocator::max_size() const</span></p></td><td id="-298164730#-vni64p_208"><p>返回所成功分配的最大内存大小的值</p></td></tr><tr class="" id="-298164730#-vni64p_179"><td id="-298164730#-vni64p_210"><p><span class="inline-code" id="-298164730#-vni64p_212">allocator::destroy(pointer p)</span></p></td><td id="-298164730#-vni64p_211"><p>等价于 p-&gt;T()</p></td></tr></table></div><p id="-298164730#-vni64p_151">用一个例子对<span class="inline-code" id="-298164730#-vni64p_213">allocator::rebind</span>进行补充：</p><div class="detached code-block" id="-298164730#-vni64p_152"><pre><code class="language-cpp">template&lt;class T&gt;
class alloc;

template&lt;typename T, typename Alloc = alloc&lt;T&gt;&gt;
class MyContainer{
public:
    template&lt;typename U&gt;
    struct rebind{
        typedef Alloc&lt;U&gt; other; // Allocator type for type U
        // other represents some other objects
    };
};</code></pre></div><ol class="list list-decimal" id="-298164730#-vni64p_153" type="1" start="2"><li class="list-item" id="-298164730#-vni64p_214"><p>设计一个简单的空间配置器(Compiler:G++)</p></li></ol><div class="detached code-block" id="-298164730#-vni64p_154"><pre><code class="language-cpp">#include &lt;new&gt;          // for placement new
#include &lt;cstddef&gt;      // for ptrdiff_t, size_t
#include &lt;cstdlib&gt;      // for exit()
#include &lt;climits&gt;      // for UINT_MAX
#include &lt;iostream&gt;     // for cerr
#include &lt;vector&gt;       // for test

namespace T_ {
    // allocate memory
    template&lt;class T&gt;
    inline T* _allocate(ptrdiff_t size, T*) {
        std::set_new_handler(0);    // invoke when out of memory
        T* tmp = (T*)(::operator new((size_t)(size * sizeof(T))));  // allocate memory 
        if (tmp == 0) {   // the allocated memory is 0, which means that allocating memory fails
            std::cerr &lt;&lt; &quot;out of memory&quot; &lt;&lt; '\n';
            exit(0);    // terminate processs
        }
        return tmp;     // return the pointer of the allocated memory block
    }

    // release memory
    template&lt;class T&gt;
    inline void _deallocate(T* buffer) {
        ::operator delete(buffer);  // release the allocated memory
    }

    // constructor
    template&lt;class T1, class T2&gt;
    inline void _construct(T1* p, const T2&amp; value) {
        new(p) T1(value);           // assign value at pointer p
    }

    // destructor
    template&lt;class T&gt;
    inline void _destroy(T* ptr) {
        ptr-&gt;~T();                  // invoke the destructor of type class
    }

    template&lt;class T&gt;
    class allocator {
    public:
        typedef T			value_type;
        typedef T* pointer;
        typedef const T* const_pointer;
        typedef T&amp; reference;
        typedef const T&amp; const_reference;
        typedef size_t		size_type;
        typedef ptrdiff_t	difference_type;

        /*-----implement part of the specific API-----*/

        // allocator::rebind-&gt;rebind allocator of type U
        template&lt;class U&gt;
        struct rebind {
            typedef allocator&lt;U&gt; other;
        };

        // pointer allocator::allocate-&gt;hint used for locality
        pointer allocate(size_type n, const void* hint = 0) {
            return _allocate((difference_type)n, (pointer)0);
        }

        // allocator::deallocate
        void deallocate(pointer p, size_type n) { _deallocate(p); }

        // allocator::construct
        void construct(pointer p, const T&amp; value) {
            _construct(p, value);
        }

        // allocator::destroy
        void destroy(pointer p) { _destroy(p); }

        // pointer allocator::address
        pointer address(reference x) { return (pointer)&amp;x; }

        // const_pointer allocator::const_address
        const_pointer const_address(const_reference x) {
            return (const_pointer)&amp;x;
        }

        // size_type allocator::max_size()
        size_type max_size() const {
            return size_type(UINT_MAX / sizeof(T));
        }
    };
}

int main() {
    int ia[5] = { 0, 1, 2, 3, 4 };
    unsigned int i;

    std::vector&lt;int, T_::allocator&lt;int&gt;&gt; iv(ia, ia + 5);
    for (i = 0; i &lt; iv.size(); i++) std::cout &lt;&lt; iv[i] &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';

    return 0;
}</code></pre></div><p id="-298164730#-vni64p_155">此处的STL设计只是一个简易的allocator。</p></section><section><h3 id="-298164730#sgi_2" data-toc="sgi_2#STL源码分析.md-sgi_2">SGI空间配置器</h3><p id="-298164730#-vni64p_215">SGI配置器与一般的allocator有所不同</p><div class="table-wrapper detached"><table id="-298164730#-vni64p_216"><tr class="header-row" id="-298164730#-vni64p_219"><th id="-298164730#-vni64p_222"></th><th id="-298164730#-vni64p_223"><p>名称</p></th><th id="-298164730#-vni64p_224"><p>语法</p></th><th id="-298164730#-vni64p_225"><p>是否接受参数</p></th><th id="-298164730#-vni64p_226"><p>编译器</p></th></tr><tr class="" id="-298164730#-vni64p_220"><td id="-298164730#-vni64p_227"><p>GENERAL</p></td><td id="-298164730#-vni64p_228"><p>allocator</p></td><td id="-298164730#-vni64p_229"><p><span class="inline-code" id="-298164730#-vni64p_232">vector&lt;int, std::allocator&lt;int&gt;&gt; iv</span></p></td><td id="-298164730#-vni64p_230"><p>是</p></td><td id="-298164730#-vni64p_231"><p>VC or VB</p></td></tr><tr class="" id="-298164730#-vni64p_221"><td id="-298164730#-vni64p_233"><p>SGI</p></td><td id="-298164730#-vni64p_234"><p>alloc</p></td><td id="-298164730#-vni64p_235"><p><span class="inline-code" id="-298164730#-vni64p_238">vector&lt;int, sd::alloc&gt; iv</span></p></td><td id="-298164730#-vni64p_236"><p>否</p></td><td id="-298164730#-vni64p_237"><p>GCC OR G++</p></td></tr></table></div><p id="-298164730#-vni64p_217">尽管SGI的alloc与标准的allocator有所不同，但是这并不影响使用，因为一般都是用缺省的方式对alloc进行声明。  SGI的每一个容器都使用缺省的空间配置器alloc，如下所示</p><div class="detached code-block" id="-298164730#-vni64p_218"><pre><code class="language-cpp">template&lt;class T, class Alloc = alloc&gt;  // 缺省使用alloc为配置器
class vector{ ... };</code></pre></div></section><section><h3 id="-298164730#sgi_1" data-toc="sgi_1#STL源码分析.md-sgi_1">SGI标准的空间配置器 std::allocator</h3><p id="-298164730#-vni64p_241">在SGI内部也有一个名为<span class="inline-code" id="-298164730#-vni64p_244">allocator</span>的配置器，但是相比较于标准的空间配置器，它的效率较低，两者差 异在于前者把<span class="inline-code" id="-298164730#-vni64p_245">C++</span>的 <span class="inline-code" id="-298164730#-vni64p_246">::operator new</span> 和 <span class="inline-code" id="-298164730#-vni64p_247">::operator delete</span> 进行了简单的包装。  以下是SGI_style的<span class="inline-code" id="-298164730#-vni64p_249">allocator</span>实现。  注：SGI_style的<span class="inline-code" id="-298164730#-vni64p_251">allocator</span>只接受<span class="inline-code" id="-298164730#-vni64p_252">void*</span>类型的参数。</p><div class="detached code-block" id="-298164730#-vni64p_242"><pre><code class="language-cpp">#include &lt;new&gt;
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;limits&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

/*-----generalized_style-----*/
template&lt;class T&gt;
inline T* allocate(ptrdiff_t size, T*)
{
    std::set_new_handler(0);
    T* tmp = (T*)(::operator new ((size_t)(size * sizeof(T))));
    if(tmp == 0)
    {
        std::cerr &lt;&lt; &quot;out of memory&quot; &lt;&lt; '\n';
        exit(1);
    }
    return tmp;
}

template&lt;class T&gt;
inline void deallocate(T* buffer)
{
    ::operator delete(buffer);
}

/*-----SGI_style-----*/
template&lt;class T&gt;
class allocator
{
public:
    typedef T			value_type;
    typedef T*			pointer;
    typedef const T*	const_pointer;
    typedef T&amp;			reference;
    typedef const T*	const_reference;
    typedef size_t		size_type;
    typedef ptrdiff_t	difference_type;

    pointer allocate(size_type n)
    {
        return ::allocate((difference_type)n, (pointer)0);
    }

    /*-----in the book-----*/
    /*void deallocate(pointer p) { ::deallocate(p); }
      this deallocate is not runnable */
    /*-----and the below &quot;deallocate&quot; is runnable --------------*/

    void deallocate(pointer p, size_type n) { ::deallocate(p); }
    pointer address(reference x) { return (pointer)&amp;x; }
    
    const_pointer const_address(const_reference x)
    {
        return (const_pointer)&amp;x;
    }
    
    size_type init_page_size()
    {
        return std::max(size_type(1), size_type(4096 / sizeof(T)));
    }
    
    size_type max_size() const
    {
        return std::max(size_type(1), size_type(UINT_MAX / sizeof(T)));
    }
};

int main() {
    int ia[5] = { 0, 1, 2, 3, 4 };
    unsigned int i;

    std::vector&lt;int, allocator&lt;int&gt;&gt; iv(ia, ia + 5);
    for (i = 0; i &lt; iv.size(); i++) std::cout &lt;&lt; iv[i] &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';

    return 0;
}</code></pre></div></section><section><h3 id="-298164730#sgi-std-alloc" data-toc="sgi-std-alloc#STL源码分析.md-sgi-std-alloc">SGI特殊的空间配置器 std::alloc</h3><p id="-298164730#-vni64p_254">SGI_style的<span class="inline-code" id="-298164730#-vni64p_267">std::alloc</span>相比较于SGI_style的std<span class="inline-code" id="-298164730#-vni64p_268">::allocator</span>而 言，前者对基层内存配置/释放(<span class="inline-code" id="-298164730#-vni64p_269">operator::new</span> &amp; <span class="inline-code" id="-298164730#-vni64p_270">operator::delete</span> )进行了效率优化。</p><p id="-298164730#-vni64p_255">一般在C++中关于对象对内存的配置和释放的操作</p><div class="detached code-block" id="-298164730#-vni64p_256"><pre><code class="language-none">class Foo { ... };
Foo* pf = new Foo;  // allocate memory, then construct object
delete pf;          // destruct object, and release memory</code></pre></div><p id="-298164730#-vni64p_257">关于内存配置和释放的流程如下</p><div class="table-wrapper detached"><table id="-298164730#-vni64p_258"><tr class="header-row" id="-298164730#-vni64p_271"><th id="-298164730#-vni64p_274"></th><th id="-298164730#-vni64p_275"><p>第一阶段</p></th><th id="-298164730#-vni64p_276"><p>第二阶段</p></th></tr><tr class="" id="-298164730#-vni64p_272"><td id="-298164730#-vni64p_277"><p>new</p></td><td id="-298164730#-vni64p_278"><p>调用<span class="inline-code" id="-298164730#-vni64p_280">::operator new</span>配置内存</p></td><td id="-298164730#-vni64p_279"><p>调用<span class="inline-code" id="-298164730#-vni64p_281">Foo::Foo()</span>构造对象</p></td></tr><tr class="" id="-298164730#-vni64p_273"><td id="-298164730#-vni64p_282"><p>delete</p></td><td id="-298164730#-vni64p_283"><p>调用<span class="inline-code" id="-298164730#-vni64p_285">Foo::~Foo()</span>析构对象</p></td><td id="-298164730#-vni64p_284"><p>调用<span class="inline-code" id="-298164730#-vni64p_286">::operator delete</span>释放内存</p></td></tr></table></div><p id="-298164730#-vni64p_259">简单来讲就是：</p><ol class="list list-decimal" id="-298164730#-vni64p_260" type="1" start="1"><li class="list-item" id="-298164730#-vni64p_287"><p>造一个房子 <span class="inline-code" id="-298164730#-vni64p_291">::operator new</span></p></li><li class="list-item" id="-298164730#-vni64p_288"><p>人住进去 <span class="inline-code" id="-298164730#-vni64p_292">Foo::Foo()</span></p></li><li class="list-item" id="-298164730#-vni64p_289"><p>人走了 <span class="inline-code" id="-298164730#-vni64p_293">Foo::~Foo()</span></p></li><li class="list-item" id="-298164730#-vni64p_290"><p>再把房子给拆了 <span class="inline-code" id="-298164730#-vni64p_294">::operator delete</span></p></li></ol><p id="-298164730#-vni64p_261">在STL allocator中对上面的步骤有精细的分工：</p><ol class="list list-decimal" id="-298164730#-vni64p_262" type="1" start="1"><li class="list-item" id="-298164730#-vni64p_295"><p><span class="inline-code" id="-298164730#-vni64p_299">alloc::allocate()</span> 配置空间</p></li><li class="list-item" id="-298164730#-vni64p_296"><p><span class="inline-code" id="-298164730#-vni64p_300">alloc::deallocate()</span> 释放空间</p></li><li class="list-item" id="-298164730#-vni64p_297"><p><span class="inline-code" id="-298164730#-vni64p_301">alloc::construct()</span> 构造对象</p></li><li class="list-item" id="-298164730#-vni64p_298"><p><span class="inline-code" id="-298164730#-vni64p_302">alloc::destroy() </span> 析构对象</p></li></ol><p id="-298164730#-vni64p_263">在STL标准中，allocator定义与<span class="inline-code" id="-298164730#-vni64p_303">&lt;memory&gt;</span>中，SGI<span class="inline-code" id="-298164730#-vni64p_304">&lt;memory&gt;</span>中包含如下两个文件</p><div class="detached code-block" id="-298164730#-vni64p_264"><pre><code class="language-none">#include&lt;stl_alloc.h&gt;     // for allocating and deallocating of memory
#include&lt;stl_construct.h&gt; // for constructing and destructing of object</code></pre></div><div class="container"><figure class="image-container"><img class="center image image-size" id="-298164730#-vni64p_265" alt="image_18.png" title="image_18.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/image_18.png" width="550" height="473"><figcaption class="center-text">image_18.png</figcaption></figure></div></section><section><h3 id="-298164730#construct-destroy" data-toc="construct-destroy#STL源码分析.md-construct-destroy">构造和析构基本工具: construct() &amp; destroy()</h3><div class="container"><figure class="image-container"><img class="center image image-size" id="-298164730#-vni64p_306" alt="image_19.png" title="image_19.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/image_19.png" width="435" height="396"><figcaption class="center-text">image_19.png</figcaption></figure></div><p id="-298164730#-vni64p_307">对上图内容的代码化:</p><p id="-298164730#-vni64p_308">prefix <span class="control" id="-298164730#-vni64p_328">specified</span></p><div class="detached code-block" id="-298164730#-vni64p_309"><pre><code class="language-cpp">#include &lt;new&gt;          // for placement new

template&lt;class T1, class T2&gt;
inline void construct(T1* p, const T2&amp; value){
    new(p) T1(value);   // placement new -&gt; invoke T1::T1(value);
}</code></pre></div><p id="-298164730#-vni64p_310">第一版<span class="inline-code" id="-298164730#-vni64p_329">destroy()</span><span class="control" id="-298164730#-vni64p_330">specified</span></p><div class="detached code-block" id="-298164730#-vni64p_311"><pre><code class="language-cpp">template&lt;class T&gt;       
inline void destroy(T* pointer){
    pointer-&gt;~T();      // invoke ~T()
}</code></pre></div><p id="-298164730#-vni64p_312"><span class="inline-code" id="-298164730#-vni64p_331">pointer-&gt;~T();</span>一般析构。</p><p id="-298164730#-vni64p_313">第二版<span class="inline-code" id="-298164730#-vni64p_332">destroy()</span><span class="control" id="-298164730#-vni64p_333">generalized</span></p><div class="detached code-block" id="-298164730#-vni64p_314"><pre><code class="language-cpp">template&lt;class T&gt;       
inline void destroy(ForwardIterator first, ForwardIterator last){
    __destroy(first, last, value_type(first));
}</code></pre></div><p id="-298164730#-vni64p_315"><span class="inline-code" id="-298164730#-vni64p_334">__destroy(first, last, value_type(first));</span>根据元素的类型选择最合适的方式进行析构。</p><p id="-298164730#-vni64p_316">第二版<span class="inline-code" id="-298164730#-vni64p_335">destroy()</span><span class="control" id="-298164730#-vni64p_336">SE</span></p><ul class="list" id="-298164730#-vni64p_317" start="1"><li class="list-item" id="-298164730#-vni64p_337"><p>SE1(char* ver.) -&gt; <span class="inline-code" id="-298164730#-vni64p_339">inline void destroy(char*, char*) {}</span></p></li><li class="list-item" id="-298164730#-vni64p_338"><p>SE2(wchar_t* ver.) -&gt; <span class="inline-code" id="-298164730#-vni64p_340">inline void destroy(wchar_t*, wchar_t*) {}</span></p></li></ul><p id="-298164730#-vni64p_318">判断元素类型是否有<span class="inline-code" id="-298164730#-vni64p_341">trivial destructor</span><span class="control" id="-298164730#-vni64p_342">generalized</span></p><div class="detached code-block" id="-298164730#-vni64p_319"><pre><code class="language-cpp">template&lt;class ForwardIterator, class T&gt;    
inline void __destroy(ForwardIterator first, ForwardIterator last, T*){
    typedef typename __type_traits&lt;T&gt;::has_trivial_destructor trivial_destructor;
    __destroy_aux(first, last, trivial_destructor());
}</code></pre></div><ul class="list" id="-298164730#-vni64p_320" start="1"><li class="list-item" id="-298164730#-vni64p_343"><p>元素类型有<span class="inline-code" id="-298164730#-vni64p_344">non-trivial destructor</span><span class="control" id="-298164730#-vni64p_345">specified</span></p></li></ul><div class="detached code-block" id="-298164730#-vni64p_321"><pre><code class="language-cpp">templace&lt;class ForwardIterator&gt;             
inline void __destroy_aux(ForwardIterator first, ForwardIterator last, __false_type){
    for(; first &lt; last; ++first) destroy(&amp;*first);
}</code></pre></div><ul class="list" id="-298164730#-vni64p_322" start="1"><li class="list-item" id="-298164730#-vni64p_346"><p>元素类型有<span class="inline-code" id="-298164730#-vni64p_347">trivial destructor</span><span class="control" id="-298164730#-vni64p_348">specified</span></p></li></ul><div class="detached code-block" id="-298164730#-vni64p_323"><pre><code class="language-cpp">template&lt;class ForwardIterator&gt;            
inline void __destroy_aux(ForwardIterator, ForwardIterator, __true_type){}</code></pre></div><p id="-298164730#-vni64p_324">补充和解释：</p><ol class="list list-decimal" id="-298164730#-vni64p_325" type="1" start="1"><li class="list-item" id="-298164730#-vni64p_349"><p>用来构造、析构的函数都为全局函数(<span class="emphasis" id="-298164730#-vni64p_353">STL规范：配置器必须拥有名为<span class="control" id="-298164730#-vni64p_354">construct()</span> 和 <span class="control" id="-298164730#-vni64p_355">destroy()</span> 两个成员函数</span>)</p></li><li class="list-item" id="-298164730#-vni64p_350"><p>上面的<span class="inline-code" id="-298164730#-vni64p_356">construct()</span>接受一个 <span class="emphasis" id="-298164730#-vni64p_357">指针p</span> 和一个 <span class="emphasis" id="-298164730#-vni64p_358">初值value</span>-&gt; 将初值设定到指针所指的位置 =&gt; <span class="inline-code" id="-298164730#-vni64p_359">placement new()</span></p></li><li class="list-item" id="-298164730#-vni64p_351"><p>第一版<span class="inline-code" id="-298164730#-vni64p_360">destroy()</span>接受一个指针，用于析构掉指针所指的对象。第二版<span class="inline-code" id="-298164730#-vni64p_361">destroy()</span>接受<span class="inline-code" id="-298164730#-vni64p_362">first</span>和<span class="inline-code" id="-298164730#-vni64p_363">last</span>两个迭代器，用于析构掉*[first, last)*范围内的所有对象</p></li><li class="list-item" id="-298164730#-vni64p_352"><p>在对象析构之前需要考虑该对象所有的析构函数是否<span class="emphasis" id="-298164730#-vni64p_364">trivial</span>-&gt; <span class="inline-code" id="-298164730#-vni64p_365">value_type()</span> (获取对象类型) -&gt; <span class="inline-code" id="-298164730#-vni64p_366">__type_traits&lt;T&gt;</span> (判断该类型对象的析构函数是否<span class="emphasis" id="-298164730#-vni64p_367">trivial</span>) </p><p> 4.1 是<span class="inline-code" id="-298164730#-vni64p_369">(__true_type)</span> ，直接忽略</p><p> 4.2 否<span class="inline-code" id="-298164730#-vni64p_371">(__false_type)</span> ，对范围内的对象逐个进行<span class="emphasis" id="-298164730#-vni64p_372">destroy()</span> (第一版)</p></li></ol></section><section><h3 id="-298164730#std-alloc" data-toc="std-alloc#STL源码分析.md-std-alloc">空间的配置与释放 std::alloc</h3><p id="-298164730#-vni64p_374">一般地，在对象构造前，要对其进行空间的配置，在对象析构后，要对配置的内存进行释放。 在SGI中，上述过程实现流程如下：</p><ul class="list" id="-298164730#-vni64p_375" start="1"><li class="list-item" id="-298164730#-vni64p_395"><p>向 <span class="emphasis" id="-298164730#-vni64p_399">system heap</span> 申请空间</p></li><li class="list-item" id="-298164730#-vni64p_396"><p>考虑多线程(<span class="emphasis" id="-298164730#-vni64p_400">multi-threads</span> )状态</p></li><li class="list-item" id="-298164730#-vni64p_397"><p>考虑<span class="control" id="-298164730#-vni64p_401">内存不足</span>时的应变措施</p></li><li class="list-item" id="-298164730#-vni64p_398"><p>考虑内存分配时可能导致的<span class="control" id="-298164730#-vni64p_402">内存碎片</span>问题</p></li></ul><p id="-298164730#-vni64p_376">内存碎片：不同的对象构造需要申请不同的大小的内存空间，但可能由于分配得不够合理（有大有小），导致会有一些较小的内存区块（这部分内存区块无法满足目标对象构造的内存需求）残留，随着时间的推移这些小的内存区块会越来越多，即使总的剩余内存足够大，但是已无法为大型的对象分配空间，因此造成内存浪费。</p><p id="-298164730#-vni64p_377">内存碎片可能会导致的问题：</p><ol class="list list-decimal" id="-298164730#-vni64p_378" type="1" start="1"><li class="list-item" id="-298164730#-vni64p_403"><p>碎片化的可用空间</p></li><li class="list-item" id="-298164730#-vni64p_404"><p>内存使用效率低下</p></li><li class="list-item" id="-298164730#-vni64p_405"><p>分配失败的概率增加</p></li><li class="list-item" id="-298164730#-vni64p_406"><p>性能下降</p></li></ol><p id="-298164730#-vni64p_379">内存碎片问题的可能解决方法：</p><ol class="list list-decimal" id="-298164730#-vni64p_380" type="1" start="1"><li class="list-item" id="-298164730#-vni64p_407"><p>使用固定大小的内存池：预分配固定大小的内存区块</p></li><li class="list-item" id="-298164730#-vni64p_408"><p>自定义内存配置器：根据实际需求进行内存分配</p></li><li class="list-item" id="-298164730#-vni64p_409"><p>内存压缩：手动对内存碎片进行清理</p></li><li class="list-item" id="-298164730#-vni64p_410"><p>智能内存管理：RAII和智能指针</p></li><li class="list-item" id="-298164730#-vni64p_411"><p>限制动态内存分配：对小型、生命周期短的对象使用基于堆栈的内存分配，对大型、生命周期长的对象使用动态内存分配</p></li></ol><p id="-298164730#-vni64p_381">在C++中，对内存进行配置的操作是<span class="inline-code" id="-298164730#-vni64p_412">::operator new()</span> ,对内存进行释放的操作是<span class="inline-code" id="-298164730#-vni64p_413">::operator delete()</span>。  可类比C中的<span class="inline-code" id="-298164730#-vni64p_415">malloc()</span>和<span class="inline-code" id="-298164730#-vni64p_416">free()</span>函数。  同时，在SGI中也是通过<span class="inline-code" id="-298164730#-vni64p_418">malloc()</span>和<span class="inline-code" id="-298164730#-vni64p_419">free()</span>两个函数来实现对内存的配置和释放。</p><p id="-298164730#-vni64p_382">考虑到上面提到的内存碎片问题，SGI设计了双层级的内存配置器：</p><div class="detached code-block" id="-298164730#-vni64p_383"><pre><code class="language-cpp">#ifdef
typedef __malloc_alloc_template&lt;0&gt; malloc_alloc;
typedef malloc_alloc alloc;     // set alloc as primary allocator
#else
// set alloc as secondary allocator
typedef __default_alloc_template&lt;__NODE_ALLOCATOR_THREADS, 0&gt; alloc;
#endif</code></pre></div><ul class="list" id="-298164730#-vni64p_384" start="1"><li class="list-item" id="-298164730#-vni64p_420"><p>第一级配置器直接使用<span class="inline-code" id="-298164730#-vni64p_422">malloc()</span>和<span class="inline-code" id="-298164730#-vni64p_423">free()</span></p></li><li class="list-item" id="-298164730#-vni64p_421"><p>第二级配置器则根据情况采用不同的分配策略： </p><ul class="list" id="-298164730#-vni64p_424" start="1"><li class="list-item" id="-298164730#-vni64p_425"><p>当需要配置的内存区块<span class="control" id="-298164730#-vni64p_427">大于128bytes</span>时，使用一级配置器</p></li><li class="list-item" id="-298164730#-vni64p_426"><p>当需要配置的内存区块<span class="control" id="-298164730#-vni64p_428">小于128bytes</span>时，使用二级配置器 -&gt; <span class="emphasis" id="-298164730#-vni64p_429">memory pool</span> (内存池)</p></li></ul></li></ul><p id="-298164730#-vni64p_385">SGI会为双层及的配置器封装一个如下的接口（为了使接口符合STL的标准）：</p><div class="detached code-block" id="-298164730#-vni64p_386"><pre><code class="language-cpp">template&lt;class T, class Alloc&gt;
class simple_alloc{
public:
    static T* allocate(size_t n){
        return 0 == n ? 0 : (T*) Alloc::allocate(n * sizeof(T));
    }
    static T* allocate(void){
        return (T*) Alloc::allocate(sizeof(T)); 
    }
    static void deallocate(T* p, size_t n){
        if(0 != n) Alloc::deallocate(p, n * sizeof(T)); 
    }
    static void deallocate(T* p){
        Alloc::deallocate(p, sizeof(T)); 
    }
};</code></pre></div><p id="-298164730#-vni64p_387">综上可见，该接口内的成员函数都是调用配置器内的成员函数，其中的配置单位为目标元素的大小<span class="inline-code" id="-298164730#-vni64p_430">sizeof(T)</span>。</p><p id="-298164730#-vni64p_388">SGI的STL容器全都使用<span class="inline-code" id="-298164730#-vni64p_431">simple_alloc</span>这个接口，如：</p><div class="detached code-block" id="-298164730#-vni64p_389"><pre><code class="language-cpp">template&lt;class T, class Alloc = alloc&gt; // default 
class vector{
protected:
    // specified allocator that allocates a size of element per time
    typedef simple_alloc&lt;value_type, Alloc&gt; data_allocator;
    void deallocate(){
        if(...) data_allocator(start, end_of_storage - start);
    }
    ...
};</code></pre></div><p id="-298164730#-vni64p_390">第一级配置器与第二级配置器关系图</p><div class="container"><figure class="image-container"><img class="center image image-size" id="-298164730#-vni64p_391" alt="image_20.png" title="image_20.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/image_20.png" width="533" height="240"><figcaption class="center-text">image_20.png</figcaption></figure></div><p id="-298164730#-vni64p_392">第一级配置器与第二级配置器的包装接口和运用方式关系图</p><div class="container"><figure class="image-container"><img class="center image image-size" id="-298164730#-vni64p_393" alt="image_21.png" title="image_21.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/image_21.png" width="533" height="548"><figcaption class="center-text">image_21.png</figcaption></figure></div></section><section><h3 id="-298164730#malloc-alloc-template" data-toc="malloc-alloc-template#STL源码分析.md-malloc-alloc-template">第一级配置器 __malloc_alloc_template 剖析</h3><div class="detached code-block" id="-298164730#-vni64p_433"><pre><code class="language-cpp">#if 0
#   include &lt;new&gt;
#   define THROW_BAD_ALLOC throw bad_alloc
#elif #defined(__THROW_BAD_ALLOC)
#   include &lt;iostream&gt;
#   define __THROW_BAD_ALLOC cerr &lt;&lt; &quot;out of memory&quot; &lt;&lt; endl; exit(1);
#endif</code></pre></div><p id="-298164730#-vni64p_434">特点：</p><ul class="list" id="-298164730#-vni64p_435" start="1"><li class="list-item" id="-298164730#-vni64p_453"><p>malloc-base allocator 比 default allocator速度慢</p></li><li class="list-item" id="-298164730#-vni64p_454"><p>一般而言是thread-safe，内存空间利用率较高</p></li></ul><p id="-298164730#-vni64p_436">注：</p><ol class="list list-decimal" id="-298164730#-vni64p_437" type="1" start="1"><li class="list-item" id="-298164730#-vni64p_455"><p>无参模板用法</p></li></ol><p id="-298164730#-vni64p_438"><span class="inline-code" id="-298164730#-vni64p_456">template&lt;&gt;</span>中定义内置类型与变量名，在实例化时直接给该变量赋值。</p><div class="detached code-block" id="-298164730#-vni64p_439"><pre><code class="language-cpp">template&lt;int inst&gt;
class ex{
public: 
  void printf() { std::cout &lt;&lt; &quot;inst: &quot; &lt;&lt; inst; }
};

int main(){
  /* ex&lt;para&gt; e1; here para = inst */
  ex&lt;3&gt; e1;
  e1.printf();
  return 0;
}</code></pre></div><ol class="list list-decimal" id="-298164730#-vni64p_440" type="1" start="2"><li class="list-item" id="-298164730#-vni64p_457"><p><span class="inline-code" id="-298164730#-vni64p_458">static</span>修饰符用法</p></li></ol><div class="table-wrapper detached"><table id="-298164730#-vni64p_441"><tr class="header-row" id="-298164730#-vni64p_459"><th id="-298164730#-vni64p_463"></th><th id="-298164730#-vni64p_464"><p>static</p></th><th id="-298164730#-vni64p_465"><p>non-static</p></th></tr><tr class="" id="-298164730#-vni64p_460"><td id="-298164730#-vni64p_466"><p>with instance</p></td><td id="-298164730#-vni64p_467"><p>accessible</p></td><td id="-298164730#-vni64p_468"><p>accessible</p></td></tr><tr class="" id="-298164730#-vni64p_461"><td id="-298164730#-vni64p_469"><p>without instance</p></td><td id="-298164730#-vni64p_470"><p>accessible</p></td><td id="-298164730#-vni64p_471"><p><span class="control" id="-298164730#-vni64p_472">inaccessible</span></p></td></tr><tr class="" id="-298164730#-vni64p_462"><td id="-298164730#-vni64p_473"><p>*this</p></td><td id="-298164730#-vni64p_474"><p><span class="control" id="-298164730#-vni64p_476">inaccessible</span></p></td><td id="-298164730#-vni64p_475"><p>accessible</p></td></tr></table></div><div class="detached code-block" id="-298164730#-vni64p_442"><pre><code class="language-cpp">#include &lt;iostream&gt;

class MyClass{
public:
    static void staticFunction(){
        std::cout &lt;&lt; &quot;Inside staticFunction&quot; &lt;&lt; '\n';
    }

    void nonstaticFunction(){
        std::cout &lt;&lt; &quot;Inside nonstaticFunction&quot; &lt;&lt; '\n';
    }
};

int main(){
    /* call static function without an instance */
    MyClass::staticFunction();

    /* class static function from an instance (this is uncommon but valid) */
    MyClass obj;
    obj.staticFunction();

    /* cannot call non-static function without an instance */
    MyClass::nonStaticFunction(); /* Error cannot call non-static function 
                                     without instance */

    /* call non-static function from an instance */
    obj.nonstaticFunction();

    return 0;
}</code></pre></div><ol class="list list-decimal" id="-298164730#-vni64p_443" type="1" start="3"><li class="list-item" id="-298164730#-vni64p_477"><p>函数指针用法</p></li></ol><div class="detached code-block" id="-298164730#-vni64p_444"><pre><code class="language-cpp">#include &lt;iostream&gt;

int add(int a, int b);
int subtract(int a, int b);

int main(){
    int(*operation)(int, int);  /* declaration of function pointer */

    operation = add;    /* assign address of add function to operation */
    printf(&quot;Addition result: %d\n&quot;, (*operation)(5, 3));    /* call function through function pointer */

    operation = subtract;   /* assign address of subtract function to operation */
    printf(&quot;Subtract result: %d\n&quot;, (*operation)(5, 3));    /* call function through function pointer */

    return 0;
}

int add(int a, int b){ return a + b; }
int subtract(int a, int b) { return a - b; }</code></pre></div><p id="-298164730#-vni64p_445">一级配置器</p><div class="detached code-block" id="-298164730#-vni64p_446"><pre><code class="language-cpp">template&lt;int inst&gt;
class __malloc_alloc_template {
private:
    /* the below are the function
     pointers which are used for cope with the out-of-memory(oom) */
    static void *oom_malloc(size_t);

    static void *oom_realloc(void *, size_t);

    static void (* __malloc_alloc_oom_handler)();

public:
    /* allocator */
    static void *allocate(size_t n) {
        void *result = malloc(n); // primary allocator employs malloc() directly
        /* when out of memory, invoke oom_malloc() */
        if (0 == result) result = oom_malloc(n);
        return result;
    }

    /* deallocator */
    static void deallocate(void *p, size_t /* n */) {
        free(p);  /* primary allocator employs free() directly */
    }

    /* reallocator */
    static void *reallocate(void *p, size_t /* old_sz */, size_t new_sz) {
        void *result = realloc(p, new_sz);
        /* primary allocator employs realloc() directly
 when out of memory, invoke oom_realloc()*/
        if (0 == result) result = oom_realloc(p, new_sz);
        return result;
    }

    /* emulate set_new_handler(), which means that
       out-of-memory handler is definable */
    static void (*set_malloc_handler(void (*f)()))() {
        void (* old)() = __malloc_alloc_oom_handler;
        __malloc_alloc_oom_handler = f;
        return (old);
    }
};

/* malloc_alloc out-of-memory banding */
template&lt;int inst&gt;
void (* __malloc_alloc_template&lt;inst&gt;::__malloc_alloc_oom_handler)() = 0;

template&lt;int inst&gt;
void* __malloc_alloc_template&lt;inst&gt;::oom_malloc(size_t n){
  void (* my_malloc_handler)();
  void* result;

  for(;;){ /* endlessly allocate and deallocate until allocate successfully */
    my_malloc_handler = __malloc_alloc_oom_handler;
    if(0 == my_malloc_handler) { __THROW_BAD_ALLOC; }
    (* my_malloc_handler)();
    result = malloc(n);
    if(result) return result;
   }
}</code></pre></div><p id="-298164730#-vni64p_447">注： <span class="inline-code" id="-298164730#-vni64p_478">typedef __malloc_alloc_template&lt;0&gt; malloc_alloc;</span> 此处<span class="inline-code" id="-298164730#-vni64p_480">inst</span>的值被指定为0</p><p id="-298164730#-vni64p_448">一级配置器主要采用 <span class="emphasis" id="-298164730#-vni64p_481">C</span> 中的<span class="inline-code" id="-298164730#-vni64p_482">malloc()</span>, <span class="inline-code" id="-298164730#-vni64p_483">free()</span>, <span class="inline-code" id="-298164730#-vni64p_484">realloc()</span>的函数实现内存的 配置、释放、重配置操作，并实现仿 <span class="emphasis" id="-298164730#-vni64p_485">C++</span> 的<span class="inline-code" id="-298164730#-vni64p_486">new-handler</span>机制(因为此处并没有直接使用 <span class="inline-code" id="-298164730#-vni64p_487">::operator new</span>来配置内存)</p><p id="-298164730#-vni64p_449">在 <span class="emphasis" id="-298164730#-vni64p_488">C++</span> 中 <span class="inline-code" id="-298164730#-vni64p_489">new handler</span> 的实现机制：当系统无法满足内存配置需求时，可调用一个自己指定的函数。  换言之，当 <span class="inline-code" id="-298164730#-vni64p_491">operator::new</span> 无法完成内存配置的操作时，在抛出异常前，会调用一个自己指定的 函数 <span class="emphasis" id="-298164730#-vni64p_492">new-handler</span> 来妥协解决内存不足的问题。</p><p id="-298164730#-vni64p_450">注：</p><ol class="list list-decimal" id="-298164730#-vni64p_451" type="1" start="1"><li class="list-item" id="-298164730#-vni64p_493"><p id="-298164730#-vni64p_496"><span class="emphasis" id="-298164730#-vni64p_497">SGI</span>中用 <span class="inline-code" id="-298164730#-vni64p_498">malloc</span> 而不是 <span class="inline-code" id="-298164730#-vni64p_499">::operator new</span> 来进行内存配置，因此需要实现一个类似 <span class="emphasis" id="-298164730#-vni64p_500">C++</span> 中 <span class="inline-code" id="-298164730#-vni64p_501">set_new_handler()</span> 的功能 <span class="inline-code" id="-298164730#-vni64p_502">set_malloc_handler()</span>。</p></li><li class="list-item" id="-298164730#-vni64p_494"><p id="-298164730#-vni64p_503">SGI的一级配置器的 <span class="inline-code" id="-298164730#-vni64p_504">allocate()</span> 和 <span class="inline-code" id="-298164730#-vni64p_505">realloc()</span> 都是在调用 <span class="inline-code" id="-298164730#-vni64p_506">malloc()</span> 和 <span class="inline-code" id="-298164730#-vni64p_507">realloc()</span> 不成功(发生内存不足等情况) 后才调用 <span class="inline-code" id="-298164730#-vni64p_508">oom_malloc()</span> 和 <span class="inline-code" id="-298164730#-vni64p_509">oom_realloc()</span> ，然后一直循环尝试配置和释放内存，直到内存配置成功为止，若内存配置始终不成功 那么 <span class="inline-code" id="-298164730#-vni64p_510">oom_malloc()</span> 和 <span class="inline-code" id="-298164730#-vni64p_511">oom_realloc()</span> 就会抛出<span class="inline-code" id="-298164730#-vni64p_512"> __THROW_BAD_ALLOC</span> 的 <span class="emphasis" id="-298164730#-vni64p_513">bad_alloc</span>异常信息，或直接 <span class="inline-code" id="-298164730#-vni64p_514">exit(1)</span> 中止程序。</p></li><li class="list-item" id="-298164730#-vni64p_495"><p id="-298164730#-vni64p_515">内存不足的问题的处理函数由程序的设计者完成。</p></li></ol></section><section><h3 id="-298164730#default-alloc-template" data-toc="default-alloc-template#STL源码分析.md-default-alloc-template">第二级配置器 __default_alloc_template 剖析</h3><p id="-298164730#-vni64p_517">二级配置器相较于以一级配置器多了一些额外的机制，减少了小型内存分配时所带 来的内存浪费(内存碎片)，且分配的内存越小为后续带来的内存空间管理的难度就越大， 因为系统总要靠这多出来的空间进行内存管理。</p><div class="container"><figure class="image-container"><img class="center image image-size" id="-298164730#-vni64p_518" alt="image_22.png" title="image_22.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/image_22.png" width="212" height="136"><figcaption class="center-text">image_22.png</figcaption></figure></div><p id="-298164730#-vni64p_519">SGI二级配置器的内存分配机制：</p><ul class="list" id="-298164730#-vni64p_520" start="1"><li class="list-item" id="-298164730#-vni64p_532"><p>当分配的内存区块足够大时(大于128bytes)，就转交给一级配置器处理。</p></li><li class="list-item" id="-298164730#-vni64p_533"><p>当分配的内存区块较小时(小于128bytes)，就通过内存池(memory pool)进行管理&mdash;&mdash;层级管理法(sub-allocation)</p></li></ul><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="-298164730#-vni64p_534"><span class="control" id="-298164730#-vni64p_535">层级管理法</span> 每次配置一大块内存，并维护对应的自由链表(free-list)。下次弱再有相同大小的内存需求，直接从free-lists中进行 分配，如果程序释放了小型内存区块，那么就由配置器回收到free-lists中。</p></div>
</blockquote>
<p id="-298164730#-vni64p_522">为了方便管理，SGI的二级配置器会主动将任何小额的内存需求量上调至 8 的倍数，并维护16个 free-lists，各自管理大小为 8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 96, 104, 112, 120, 128 bytes 的小额内存区块。</p><p id="-298164730#-vni64p_523"><span class="inline-code" id="-298164730#-vni64p_537">free-lists</span> 结构如下：</p><div class="detached code-block" id="-298164730#-vni64p_524"><pre><code class="language-none">union obj{
  union obj* free_list_link;
  char client_data[1];
};</code></pre></div><div class="container"><figure class="image-container"><img class="center image image-size" id="-298164730#-vni64p_525" alt="image_23.png" title="image_23.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/image_23.png" width="638" height="358"><figcaption class="center-text">image_23.png</figcaption></figure></div><p id="-298164730#-vni64p_526">此处， <span class="inline-code" id="-298164730#-vni64p_538">union obj* free_list_link</span> 可类比为链表中的 <span class="inline-code" id="-298164730#-vni64p_539">LinkList* next</span>， <span class="inline-code" id="-298164730#-vni64p_540">char client_data[1]</span>则用指向实际的内存区块，此种做法可以节省内存的开销。</p><p id="-298164730#-vni64p_527">补充：</p><ul class="list" id="-298164730#-vni64p_528" start="1"><li class="list-item" id="-298164730#-vni64p_541"><p><span class="inline-code" id="-298164730#-vni64p_543">struct</span>中的各个成员变量都有自己的内存空间</p></li><li class="list-item" id="-298164730#-vni64p_542"><p><span class="inline-code" id="-298164730#-vni64p_544">union</span>中的各个成员变量共享着一块内存空间</p></li></ul><p id="-298164730#-vni64p_529">二级配置器的部分实现</p><div class="detached code-block" id="-298164730#-vni64p_530"><pre><code class="language-cpp">#include &lt;cstddef&gt;

enum {__ALIGN = 8};
enum {__MAX_BYTES = 128};
enum {__NFREELISTS = __MAX_BYTES / __ALIGN };

template&lt;bool threads, int inst&gt;
class __default_alloc_template{
private:
    static size_t ROUND_UP(size_t bytes){ return (((bytes) + __ALIGN - 1) &amp; ~(__ALIGN - 1)); }
    /*  '(bytes + __ALIGN -1': This part adds an offset to the 'bytes' value. The '__ALIGN - 1'
     *  is used to ensure that we round up to the next multiple of '__ALIGN'.For example, if '__ALIGN'
     *  is 4, then '__ALIGN - 1' is 3, and adding 3 ensures that the result will be at least a multiple
     *  of 4 greater than 'bytes'.
     *  '&amp; !(__ALIGN - 1)‘: This part performs a bitwise AND operation wit the complement of '(__ALIGN - 4)'.
     *  The complement operation '~' flips all the bits of '(__ALIGN - 1)', effective creating a bitmask where
     *  all bits are set to 1 except for the lower bits determined by '__ALIGN - 1'. By performing a bitwise AND
     *  with this bitmask, we effectively set the lower bits to O, thus rounding down the result to the nearest
     *  multiple of '__ALIGN'.
     */
private:
    union obj{
        union obj* free_list_link;
        char client_data[1];
    };
private:
    /* 16 free-lists */
    static obj* volatile free_list[__NFREELISTS];
    /* employ Nth free-list according to the size
     * of memory chunk (begin with 1st memory chunk)
    */
    static size_t FREELIST_INDEX(size_t bytes){ return (((bytes) + __ALIGN + 1) / __ALIGN - 1); }
    /* return a object in size of n, and add other memory
     * chunks in size of n into free-list if possible
    */
    static void* refill(size_t n);
    /* allocate a memory space that can hold n objs
     * its capacity is size
     * if inconvenient to allocate for n objs, n cloud decrease
    */
    static void* refill(size_t size, int&amp; nobjs);

    // chunk allocation state
    static char* start_free;    // the start position in memory pool, only changes in chunk_alloc()
    static char* end_free;      // the end position in memory pool, only changes in chunk_alloc()
    static size_t heap_size;
public:
    static void* allocate(size_t n) { }
    static void deallocate(void* p, size_t n) { }
    static void* reallocate(void* p, size_t old_sz, size_t new_sz);
};

/* the original value and definition setting for static data member */
template &lt;bool threads, int inst&gt;
char* __default_alloc_template&lt;threads, inst&gt;::start_free = 0;

template &lt;bool threads, int inst&gt;
char* __default_alloc_template&lt;threads, inst&gt;::end_free = 0;

template &lt;bool threads, int inst&gt;
size_t __default_alloc_template&lt;threads, inst&gt;::heap_size = 0;

template &lt;bool threads, int inst&gt;
__default_alloc_template&lt;threads, inst&gt;::obj* volatile
__default_alloc_template&lt;threads, inst&gt;::free_list[__NFREELISTS] =
        {0, 0, 0, 0, 0, 0, 0, 0 , 0, 0, 0, 0, 0, 0, 0, 0};</code></pre></div></section><section><h3 id="-298164730#allocate" data-toc="allocate#STL源码分析.md-allocate">空间配置函数 allocate()</h3><p id="-298164730#-vni64p_546">配置器的标准接口函数allocate()，其工作方式如下：</p><ul class="list" id="-298164730#-vni64p_547" start="1"><li class="list-item" id="-298164730#-vni64p_552"><p>判断区块大小 </p><ul class="list" id="-298164730#-vni64p_553" start="1"><li class="list-item" id="-298164730#-vni64p_554"><p>大于128bytes调用一级配置器</p></li><li class="list-item" id="-298164730#-vni64p_555"><p>小于128bytes就检查对应的free list </p><ul class="list" id="-298164730#-vni64p_556" start="1"><li class="list-item" id="-298164730#-vni64p_557"><p>如果free list内有可用的区块，就直接用</p></li><li class="list-item" id="-298164730#-vni64p_558"><p>如果free list内没有可用的区块，就将区块大小上调至8倍数bytes，然后调用refill()，准备为free list重新填充空间</p></li></ul></li></ul></li></ul><div class="detached code-block" id="-298164730#-vni64p_548"><pre><code class="language-cpp">// n must be &gt; 0, to assure that 
// there is the memory allocated
static void* allocate(size_t n){
  obj* volatile* my_free_list;
  obj* result;
  
// if allocating memory &gt; 128 bytes
if(n &gt; (size_t) __MAX_BYTES){
  return (malloc_alloc:allocate(n));
}

// select a suitable chunk in 1 of 16 free lists
my_free_list = free_list + FREELIST_INDEX(n);
result = *my_free_list;
if (result == 0){
  // no find a available free list
  // preparing to refill another
  void* r = refill(ROUND_UP(n));
  return r;
}
// adjust free list
*my_free_list = result -&gt; free_list_link;
return (result);
};</code></pre></div><p id="-298164730#-vni64p_549"><span class="control" id="-298164730#-vni64p_559">内存区块从free list调出的操作</span></p><div class="container"><figure class="image-container"><img class="center image image-size" id="-298164730#-vni64p_550" alt="image_25.png" title="image_25.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/image_25.png" width="943" height="689"><figcaption class="center-text">image_25.png</figcaption></figure></div></section><section><h3 id="-298164730#deallocate" data-toc="deallocate#STL源码分析.md-deallocate">空间释放函数 deallocate()</h3><p id="-298164730#-vni64p_561">__default_alloc_template拥有一个标准接口函数deallocate()，其工作方式如下：</p><ul class="list" id="-298164730#-vni64p_562" start="1"><li class="list-item" id="-298164730#-vni64p_567"><p>判断区块大小 </p><ul class="list" id="-298164730#-vni64p_568" start="1"><li class="list-item" id="-298164730#-vni64p_569"><p>大于128bytes，直接调用一级配置器</p></li><li class="list-item" id="-298164730#-vni64p_570"><p>小于128bytes，找出对应的free list，将区块回收</p></li></ul></li></ul><div class="detached code-block" id="-298164730#-vni64p_563"><pre><code class="language-cpp">// p can not be 0
static void deallocate(void* p, size_t n){
    obj* q = (obj *)p;
    obj* volatile* my_free_list;
    
    // if size &gt; 128 bytes, call the primary allocator
    if(n &gt; (size_t) __MAX_BYTES){
        malloc_alloc::deallocate(p, n);
        return;
    }
    
    // selecting the corresponding free list
    my_free_list = free_list + FREELIST_INDEX(n);
    
    // adjust free list, recycle the chunk
    q -&gt; free_list_link = *my_free_list;
    *my_free_list = q;
}</code></pre></div><p id="-298164730#-vni64p_564"><span class="control" id="-298164730#-vni64p_571">内存区块回收至free list的操作</span></p><div class="container"><figure class="image-container"><img class="center image image-size" id="-298164730#-vni64p_565" alt="image_26.png" title="image_26.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/image_26.png" width="601" height="459"><figcaption class="center-text">image_26.png</figcaption></figure></div></section><section><h3 id="-298164730#free-lists" data-toc="free-lists#STL源码分析.md-free-lists">重新填充free lists</h3><p id="-298164730#-vni64p_573">在free lists中没有可用的区块时，调用refill()以为free list重新填充空间， 新的空间从内存池(经由chunk_alloc()完成)取出：</p><ul class="list" id="-298164730#-vni64p_574" start="1"><li class="list-item" id="-298164730#-vni64p_577"><p>当内存池中剩余的内存足够时，缺省取得20个新区块</p></li><li class="list-item" id="-298164730#-vni64p_578"><p>当内存池中剩余的内存不足时，取得的新区块数可能小于20</p></li></ul><div class="detached code-block" id="-298164730#-vni64p_575"><pre><code class="language-cpp">// return a obj in size of n
// and supply some chunks for free list properly sometimes
// supposing that n is upregulated to a multiple of 8
template &lt;bool threads, int inst&gt;
void* __default_alloc_template&lt;threads, inst&gt;::refill(size_t n){
    int nobjs = 20;
    // call chunk_alloc(), try to get n(objs) chunks 
    // as new nodes for free list
    char* chunk = chunk_alloc(n, nobjs); // nobjs -&gt; pass by reference
    obj* volatile* my_free_list;
    obj* result;
    obj* current_obj, * next_obj;
    int i;
    
    // if only get one chunk, then allocate this chunk to the target
    // so there is no new node for free list
    if(l == nobjs) return(chunk);
    // if not, adjust free list and prepare to link a new node
    my_free_list = free_list + FREELIST_INDEX(n);
    
    // create free list in chunk space
    result = (obj*)chunk;   // this piece of chunk will return to user
    // help free list point toward the new allocated space (from memory pool)
    *my_free_list = new_obj = (obj*)(chunk + n);
    // connect the each node in free list
    for(i = 1; ; i++){      // i begin with 1, because i[0] will be return to user
        current_obj = next_obj;
        if (nobjs - 1 == i){
            current_obj -&gt; free_list_link = 0;
            break;
        }else{
            current_obj -&gt; free_list_link = next_obj;
        }
    }
    return(result);
}</code></pre></div></section><section><h3 id="-298164730#memory-pool" data-toc="memory-pool#STL源码分析.md-memory-pool">内存池 memory pool</h3><p id="-298164730#-vni64p_580">在谈及到<span class="inline-code" id="-298164730#-vni64p_592">refill()</span>时，提到了关于<span class="inline-code" id="-298164730#-vni64p_593">chunk_alloc()</span>这个函数， 它是用来从内存池中取空间给<span class="emphasis" id="-298164730#-vni64p_594">free list</span>。</p><div class="detached code-block" id="-298164730#-vni64p_581"><pre><code class="language-cpp">template &lt;bool threads, int inst&gt;
char* __default_alloc_template&lt;threads, inst&gt;::chunk_alloc(size_t size, int&amp; nobjs){
    char* result;
    size_t total_bytes = size * nobjs;
    size_t bytes_left = end_free - start_free;  // the rest of memory pool

    if(bytes_left &gt;= total_bytes){
        // the rest of memory pool could satisfy the need
        result = start_free;
        start_free += total_bytes;
        return(result);
    }else if( bytes_left &gt;= size){
        // the rest of memory pool could not totally satisfy the need
        // but only one or more chunks
        nobjs = bytes_left / size;
        total_bytes = size * nobjs;
        result = start_free;
        start_free += total_bytes;
        return(result);
    }else{
        // memory pool can not supply the size o only one chunk
        size_t bytes_to_get = 2 * total_bytes + ROUND_UP(heap_size &gt;&gt; 4);
        // make full use of memory fragments
        if(bytes_left &gt; 0){
            // allocate some surplus memory for free list primarily
            // select the proper free list
            obj* volatile* my_free_list = free_list + FREELIST_INDEX(bytes_left);
            // adjust free list, integrate the surplus memory in memory pool
            ((obj*) start_free) -&gt; free_list_link = *my_free_list;
            *my_free_list = (obj*) start_free;
        }

        // configure heap to supply memory pool
        start_free = (char*) malloc(bytes_to_get);
        if(0 == start_free){
            // heap is not enough, malloc() fails
            int i;
            obj* volatile* my_free_list, *p;
            // check the memory that I currently have
            // allocate the small memory space is dangerous under multi-threads circumstance
            // select a proper free list
            // &quot;proper&quot; means that the unused memory is big enough to satisfy the need
            for(i = size; i &lt;= __MAX_BYTES; i += __ALIGN){
                my_free_list = free_list + FREELIST_INDEX(i);
                p = *my_free_list;
                if(0 != p){
                    // chunk not in free list
                    // adjust free list to release the unused memory
                    *my_free_list = p -&gt; free_list_link;
                    start_free = (char*) p;
                    end_free = start_free + i;
                    // revoke itself to fix nobjs
                    return(chunk_alloc(size, nobjs));
                    // any surplus memory will be integrated in free list as spare
                }
            }
            end_free = 0;   // if occur the accident, allocate the primary allocator
            // turning to out-of-memory
            start_free = (char*)malloc_alloc::allocate(bytes_to_get);
            // if failed, throw exception
            // if succeeded, memory lack will be fixed
        }
     heap_size += bytes_to_get;
        end_free = start_free + bytes_to_get;
        // revoke itself to fix nobjs
        return(chunk_alloc(size, nobjs));
    }</code></pre></div><p id="-298164730#-vni64p_582"><span class="inline-code" id="-298164730#-vni64p_595">chunk_alloc()</span>函数通过<span class="inline-code" id="-298164730#-vni64p_596">end_free - start_free</span>来判断内存中的内存余量：</p><ul class="list" id="-298164730#-vni64p_583" start="1"><li class="list-item" id="-298164730#-vni64p_597"><p>如果内存足够，就直接调出<span class="control" id="-298164730#-vni64p_599">20</span>个区块返回给<span class="emphasis" id="-298164730#-vni64p_600">free list</span></p></li><li class="list-item" id="-298164730#-vni64p_598"><p>如果内存不足 </p><ul class="list" id="-298164730#-vni64p_601" start="1"><li class="list-item" id="-298164730#-vni64p_602"><p>但够满足一个及以上区块，就调出(不足<span class="control" id="-298164730#-vni64p_604">20</span>个)剩余的区块</p></li><li class="list-item" id="-298164730#-vni64p_603"><p>甚至连一个区块都无法调出，此时尝试使用<span class="inline-code" id="-298164730#-vni64p_605">malloc()</span>从<span class="emphasis" id="-298164730#-vni64p_606">heap</span>中配置内存来增加内存池中的内存余量，配置的内存大小随着配置的次数逐渐增加</p></li></ul></li></ul><p id="-298164730#-vni64p_584">举例：</p><ul class="list" id="-298164730#-vni64p_585" start="1"><li class="list-item" id="-298164730#-vni64p_607"><p>当调用<span class="inline-code" id="-298164730#-vni64p_611">chunk_alloc(32, 20)</span>时，于是<span class="inline-code" id="-298164730#-vni64p_612">malloc()</span>配置<span class="control" id="-298164730#-vni64p_613">40</span>个<span class="control" id="-298164730#-vni64p_614">32bytes</span>区块， 取出其中的第一个区块，剩下的<span class="control" id="-298164730#-vni64p_615">19</span>个放入<span class="inline-code" id="-298164730#-vni64p_616">free_list[3]</span>进行维护，再将剩余的<span class="control" id="-298164730#-vni64p_617">20</span>个 留给内存池</p></li><li class="list-item" id="-298164730#-vni64p_608"><p>当再调用<span class="inline-code" id="-298164730#-vni64p_618">chunk_alloc(64, 20)</span>时，此时<span class="inline-code" id="-298164730#-vni64p_619">free_list[7]</span>空空如也， 而内存池中的内存余量<span class="control" id="-298164730#-vni64p_620">20 * 32 bytes / 64 bytes = 10</span>个，就先把这<span class="control" id="-298164730#-vni64p_621">10</span>个区块返回， 取出其中的第一个区块，剩下的9个放入<span class="inline-code" id="-298164730#-vni64p_622">free_list[7]</span>中进行维护。此时内存池空空如也</p></li><li class="list-item" id="-298164730#-vni64p_609"><p>再继续调用<span class="inline-code" id="-298164730#-vni64p_623">chunk_alloc(96, 20)</span> ，此时<span class="inline-code" id="-298164730#-vni64p_624">free_list[11]</span>空空如也，此时想要从内存池中找内存， 然而内存池中也是空空如也，于是以<span class="inline-code" id="-298164730#-vni64p_625">malloc()</span>配置<span class="control" id="-298164730#-vni64p_626">40 + n</span> (附加量)个<span class="control" id="-298164730#-vni64p_627">96bytes</span>区块，取出其中的第一个区块， 再将<span class="control" id="-298164730#-vni64p_628">19</span>个交给<span class="inline-code" id="-298164730#-vni64p_629">free_list[11]</span>进行维护，剩下的<span class="control" id="-298164730#-vni64p_630">20+n</span> (附加量)留给内存池&hellip;&hellip;</p></li><li class="list-item" id="-298164730#-vni64p_610"><p>当整个<span class="emphasis" id="-298164730#-vni64p_631">system heap</span>空间都不够了，以至于无法再继续向内存池中添加内存， <span class="inline-code" id="-298164730#-vni64p_632">malloc()</span>就不无法继续进行， <span class="inline-code" id="-298164730#-vni64p_633">chunk_alloc()</span>再在<span class="emphasis" id="-298164730#-vni64p_634">free list</span>中寻找是否有可用且足够大的区块，有就用，没有就找一级配置器帮忙， 一级配置器使用<span class="inline-code" id="-298164730#-vni64p_635">malloc()</span>进行内存配置，但它有<span class="emphasis" id="-298164730#-vni64p_636">out-of-memory</span>处理机制(类似于<span class="inline-code" id="-298164730#-vni64p_637">new handler</span>)： </p><ul class="list" id="-298164730#-vni64p_638" start="1"><li class="list-item" id="-298164730#-vni64p_639"><p>如果成功，释放出足够的内存以使用</p></li><li class="list-item" id="-298164730#-vni64p_640"><p>如果失败，抛出<span class="inline-code" id="-298164730#-vni64p_641">bad_alloc</span>异常</p></li></ul></li></ul><div class="container"><figure class="image-container"><img class="center image image-size" id="-298164730#-vni64p_586" alt="image_27.png" title="image_27.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/image_27.png" width="643" height="568"><figcaption class="center-text">image_27.png</figcaption></figure></div><p id="-298164730#-vni64p_587">提供标准配置接口的 simple_alloc</p><div class="detached code-block" id="-298164730#-vni64p_588"><pre><code class="language-cpp">template&lt;class T, class Alloc&gt;
class simple_alloc{
public:
    static T* allocate(size_t n){
        return 0 == n ? 0 : (T*) Alloc::allocate(n * sizeof(T));
    }
    static T* allocate(void){
        return (T*) Alloc::allocate(sizeof(T)); 
    }
    static void deallocate(T* p, size_t n){
        if(0 != n) Alloc::deallocate(p, n * sizeof(T)); 
    }
    static void deallocate(T* p){
        Alloc::deallocate(p, sizeof(T)); 
    }
};</code></pre></div><p id="-298164730#-vni64p_589">SGI通常使用这种方式来使用配置器：</p><div class="detached code-block" id="-298164730#-vni64p_590"><pre><code class="language-cpp">template &lt;class T, class Alloc = alloc&gt; // 缺省使用 alloc 为配置器
class vector{
    public:
        typedef T value_type;
    protected:  // 专属配置器，每次配置一个元素大小
        typedef simple_alloc&lt;value_type, Alloc&gt; data_allocator;
};</code></pre></div></section><section><h3 id="-298164730#-vni64p_138" data-toc="-vni64p_138#STL源码分析.md--vni64p_138">内存基本处理工具</h3><p id="-298164730#-vni64p_642">STL定义有5个全局函数，作用于未初始化空间上：</p><ol class="list list-decimal" id="-298164730#-vni64p_643" type="1" start="1"><li class="list-item" id="-298164730#-vni64p_645"><p><span class="inline-code" id="-298164730#-vni64p_650">construct()</span>-&gt; <span class="control" id="-298164730#-vni64p_651">构造</span></p></li><li class="list-item" id="-298164730#-vni64p_646"><p><span class="inline-code" id="-298164730#-vni64p_652">destroy()</span>-&gt; <span class="control" id="-298164730#-vni64p_653">析构</span></p></li><li class="list-item" id="-298164730#-vni64p_647"><p><span class="inline-code" id="-298164730#-vni64p_654">uninitialized_copy()</span>-&gt; <span class="inline-code" id="-298164730#-vni64p_655">copy()</span></p></li><li class="list-item" id="-298164730#-vni64p_648"><p><span class="inline-code" id="-298164730#-vni64p_656">uninitialized_fill()</span>-&gt; <span class="inline-code" id="-298164730#-vni64p_657">fill()</span></p></li><li class="list-item" id="-298164730#-vni64p_649"><p><span class="inline-code" id="-298164730#-vni64p_658">uninitialized_fill_n()</span>-&gt; <span class="inline-code" id="-298164730#-vni64p_659">fill_n()</span></p></li></ol><p id="-298164730#-vni64p_644">其中 <span class="inline-code" id="-298164730#-vni64p_660">copy()</span>, <span class="inline-code" id="-298164730#-vni64p_661">fill()</span>, <span class="inline-code" id="-298164730#-vni64p_662">fill_n()</span> 都为<span class="emphasis" id="-298164730#-vni64p_663">STL</span>算法</p></section><section><h3 id="-298164730#uninitialized-copy" data-toc="uninitialized-copy#STL源码分析.md-uninitialized-copy">uninitialized_copy()</h3><div class="detached code-block" id="-298164730#-vni64p_664"><pre><code class="language-cpp">template&lt;class InputIterator, class ForwardIterator&gt;
ForwardIterator
unitialized_copy(InputIterator first, InputIterator last, 
ForwardIterator result);</code></pre></div><p id="-298164730#-vni64p_665"><span class="inline-code" id="-298164730#-vni64p_666">uninitialized_copy()</span>将内存的配置与对象的构造分离开来，其工作方式：在输入范围内，利用迭代器<span class="inline-code" id="-298164730#-vni64p_667">i</span> ，该迭代器会调用 <span class="inline-code" id="-298164730#-vni64p_668">construct(&amp;*(result + (i - first)), *i)</span> ，以此来产生<span class="inline-code" id="-298164730#-vni64p_669">*i</span>的拷贝对象，并将拷贝得到的对象放置到输出范围的相对位置上。  当要实现一个容器时， <span class="inline-code" id="-298164730#-vni64p_671">uninitialized_copy()</span>可以帮助容器的全区间构造函数在配置内存区块（以包含范围内的所有元素）后，在该内存区块上构造元素。  C++对于此还有一个要求&mdash;&mdash;<span class="emphasis" id="-298164730#-vni64p_673">commit or rollback</span> ：若能对每个元素都成功能进行<span class="inline-code" id="-298164730#-vni64p_674">uninitialized_copy()</span> ，则<span class="emphasis" id="-298164730#-vni64p_675">commit</span> ，否则<span class="emphasis" id="-298164730#-vni64p_676">rollback</span>。</p></section><section><h3 id="-298164730#uninitialized-fill" data-toc="uninitialized-fill#STL源码分析.md-uninitialized-fill">uninitialized_fill</h3><div class="detached code-block" id="-298164730#-vni64p_677"><pre><code class="language-cpp">template&lt;class ForwardIterator, class T&gt;
void unintialized_fill(ForwardIterator first, ForwardIterator last,
 const T&amp;x);</code></pre></div><p id="-298164730#-vni64p_678"><span class="inline-code" id="-298164730#-vni64p_679">uninitialized_fill()</span>将内存配置与对象的构造分离开来，其工作方式：对于输入范围内的每个迭代器<span class="inline-code" id="-298164730#-vni64p_680">i</span> ，调用 <span class="inline-code" id="-298164730#-vni64p_681">construct(&amp;*i, x)</span> ，在<span class="inline-code" id="-298164730#-vni64p_682">i</span>所指之处放置x的拷贝对象。  C++对此同样也有<span class="emphasis" id="-298164730#-vni64p_684">commit or rollback</span>的要求：若能对每个元素都能成功进行<span class="inline-code" id="-298164730#-vni64p_685">uninitialized_fill()</span> ，则<span class="emphasis" id="-298164730#-vni64p_686">commit</span> ，如果有一个<span class="emphasis" id="-298164730#-vni64p_687">copy constructor</span>抛出异常(操作失败)， 则将所有成功产生的元素全部析构掉。</p></section><section><h3 id="-298164730#uninitialized-fill-n" data-toc="uninitialized-fill-n#STL源码分析.md-uninitialized-fill-n">uninitialized_fill_n</h3><div class="detached code-block" id="-298164730#-vni64p_688"><pre><code class="language-cpp">template&lt;class ForwardIterator, class Size, class T&gt;
ForwardIterator
uninitialized_fill_n(ForwardIterator first, Size n, const T&amp; x);</code></pre></div><p id="-298164730#-vni64p_689"><span class="inline-code" id="-298164730#-vni64p_690">uninitialized_fill_n()</span>将内存配置与对象的构造分离开来，它可以为指定范围内的所有元素设定相同的初值。 对于<span class="inline-code" id="-298164730#-vni64p_691">[first, first + n]</span>范围内的每个迭代器<span class="inline-code" id="-298164730#-vni64p_692">i</span>， <span class="inline-code" id="-298164730#-vni64p_693">uninitialized_fill_n()</span>会调用<span class="inline-code" id="-298164730#-vni64p_694">construct(&amp;*i, x)</span> ，为其在对应的位置上产生<span class="inline-code" id="-298164730#-vni64p_695">x</span>的拷贝对象。  C++对此同样也有<span class="emphasis" id="-298164730#-vni64p_697">commit or rollback</span>的要求：若能对每个元素都能成功<span class="inline-code" id="-298164730#-vni64p_698">uninitialized_fill_n()</span> ，则<span class="emphasis" id="-298164730#-vni64p_699">commit</span> ，如果有一个<span class="emphasis" id="-298164730#-vni64p_700">copy constructor</span>抛出异常(操作失败)， 则将所有成功产生的元素全部析构掉。</p></section><section><h3 id="-298164730#uninitialized-fill-n_1" data-toc="uninitialized-fill-n_1#STL源码分析.md-uninitialized-fill-n_1">uninitialized_fill_n 实现方法</h3><p id="-298164730#-vni64p_701"><span class="emphasis" id="-298164730#-vni64p_722">uninitialized_fill_n()</span> 函数接受 3 个参数:</p><ul class="list" id="-298164730#-vni64p_702" start="1"><li class="list-item" id="-298164730#-vni64p_723"><p>迭代器 first 指向欲初始化空间的起始处</p></li><li class="list-item" id="-298164730#-vni64p_724"><p>n 表示欲初始化空间的大小</p></li><li class="list-item" id="-298164730#-vni64p_725"><p>x 表示初值</p></li></ul><div class="detached code-block" id="-298164730#-vni64p_703"><pre><code class="language-cpp">template &lt;class ForwardIterator, class Size, class T&gt;
inline ForwardIterator uninitialized_fill_n(ForwardIterator first,  
                                            Size n,                 
                                            const T&amp; x              
                                            ) {
    return __uninitialized_fill_n(first, n, x, value_type(first));
    // for the above, call value_type() fetch out value type of first
}</code></pre></div><p id="-298164730#-vni64p_704">补充：萃取器(Extractor) 萃取器用于取出迭代器中特定信息，如元素类型、迭代器类型等</p><div class="detached code-block" id="-298164730#-vni64p_705"><pre><code class="language-cpp">// define a extractor 定义一个萃取器
template &lt;typename Iterator&gt;
struct IteratorTraits{
    using ValueType = typename Iterator::value_type;
};

// polarize pointer 偏特化指针类型
template&lt;typename T&gt;
struct IteratorTraits&lt;T*&gt;{
    using ValueType = T;
};

int main(){
    using Iter = std::vector&lt;int&gt;::iterator;
    using ValueType = typename IteratorTraits&lt;Iter&gt;::ValueType;
    std::cout &lt;&lt; &quot;Value type of iterator: &quot; &lt;&lt; typeid(ValueType).name() &lt;&lt; '\n';
    return 0;
}

输出:
Value type of interator: i -&gt; (int)</code></pre></div><p id="-298164730#-vni64p_706">uninitialized_fill_n()函数执行逻辑：</p><ul class="list" id="-298164730#-vni64p_707" start="1"><li class="list-item" id="-298164730#-vni64p_726"><p>利用萃取器萃取出 first 的value type</p></li><li class="list-item" id="-298164730#-vni64p_727"><p>判断此 value type 是否为POD型别</p></li></ul><div class="detached code-block" id="-298164730#-vni64p_708"><pre><code class="language-cpp">template &lt;class ForwardIterator, class Size, class T, class T1&gt;
inline ForwardIterator __uninitialized_fill_n(ForwardIterator first,
                                              Size n,
                                              const T&amp; x,
                                              T1*){
    typedef typename __type_traits&lt;T1&gt;::is_POD_type is_POD;
    return __uninitialized_fill_n_aux(first, n, x, is_POD());
}</code></pre></div><p id="-298164730#-vni64p_709">POD(Plain Old Data)指的是标量型别(scalar type)或传统的C struct型别。 因此POD型别内必然会有trivial ctor/dtor/copy/assignment函数(类比C++中的class)， 因此对POD型别采用效率最高的赋值方法，而对non-POD型别采用最安全的赋值方法：</p><ul class="list" id="-298164730#-vni64p_710" start="1"><li class="list-item" id="-298164730#-vni64p_728"><p>前提条件1：如果 copy assignment 等同于 assignment</p></li><li class="list-item" id="-298164730#-vni64p_729"><p>前提条件2：如果 destructor 等同于 trivial</p></li></ul><p id="-298164730#-vni64p_711">对于POD型别的处理：</p><div class="detached code-block" id="-298164730#-vni64p_712"><pre><code class="language-cpp">template&lt;class ForwardIterator, class Size, class T&gt;
inline ForwardIterator __uninitialized_fill_n_aux(ForwardIterator first,
                                                  Size n,
                                                  const T&amp; x,
                                                  __true_type){
    return fill_n(first, n, x);
}</code></pre></div><p id="-298164730#-vni64p_713">对于non-POD型别的处理：</p><div class="detached code-block" id="-298164730#-vni64p_714"><pre><code class="language-cpp">template &lt;class ForwardIterator, class Size, class T&gt;
ForwardIterator
__uninitialized_fill_n_aux(ForwardIterator first,
                           Size n,
                           const T&amp; x,
                           __false_type){
    ForwardIterator cur = first;
    for(; n &gt; 0; --n, ++cur) construct(&amp;*cur, x);
    return cur;
}</code></pre></div><p id="-298164730#-vni64p_715">补充： <span class="control" id="-298164730#-vni64p_730">POD型别</span> 在C++中， <span class="control" id="-298164730#-vni64p_732">Plain Old Data (POD)</span> 是一种数据类型，具有与C语言中结构体和联合体相似的特性。POD类型可以用于在性能和内存布局上保证与C语言兼容的场景。POD类型的主要特征包括：</p><ol class="list list-decimal" id="-298164730#-vni64p_716" type="1" start="1"><li class="list-item" id="-298164730#-vni64p_733"><p><span class="control" id="-298164730#-vni64p_734">标准布局类型（Standard Layout Type）</span>：</p></li></ol><ul class="list" id="-298164730#-vni64p_717" start="1"><li class="list-item" id="-298164730#-vni64p_735"><p>该类型的所有非静态数据成员具有相同的访问权限（全部是<span class="inline-code" id="-298164730#-vni64p_739">public</span>、 <span class="inline-code" id="-298164730#-vni64p_740">protected</span>或<span class="inline-code" id="-298164730#-vni64p_741">private</span>）。</p></li><li class="list-item" id="-298164730#-vni64p_736"><p>类/结构体没有虚函数或虚基类。</p></li><li class="list-item" id="-298164730#-vni64p_737"><p>所有非静态数据成员具有相同的访问控制（如全部是<span class="inline-code" id="-298164730#-vni64p_742">public</span>或全部是<span class="inline-code" id="-298164730#-vni64p_743">private</span>）。</p></li><li class="list-item" id="-298164730#-vni64p_738"><p>派生类和基类必须具有相同的访问控制。</p></li></ul><ol class="list list-decimal" id="-298164730#-vni64p_718" type="1" start="2"><li class="list-item" id="-298164730#-vni64p_744"><p><span class="control" id="-298164730#-vni64p_745">聚合类型（Aggregate Type）</span>：</p></li></ol><ul class="list" id="-298164730#-vni64p_719" start="1"><li class="list-item" id="-298164730#-vni64p_746"><p>没有用户定义的构造函数。</p></li><li class="list-item" id="-298164730#-vni64p_747"><p>没有私有或受保护的非静态数据成员。</p></li><li class="list-item" id="-298164730#-vni64p_748"><p>没有基类。</p></li><li class="list-item" id="-298164730#-vni64p_749"><p>没有虚函数。</p></li></ul><p id="-298164730#-vni64p_720">POD类型的主要优点包括：</p><ul class="list" id="-298164730#-vni64p_721" start="1"><li class="list-item" id="-298164730#-vni64p_750"><p><span class="control" id="-298164730#-vni64p_753">二进制兼容性</span> ：POD类型与C语言的数据结构二进制兼容，因此可以直接用于C和C++之间的数据交换。</p></li><li class="list-item" id="-298164730#-vni64p_751"><p><span class="control" id="-298164730#-vni64p_754">易于序列化</span> ：由于POD类型的内存布局是线性的和固定的，可以直接将其写入文件或通过网络发送。</p></li><li class="list-item" id="-298164730#-vni64p_752"><p><span class="control" id="-298164730#-vni64p_755">性能优化</span> ：编译器可以对POD类型进行更多的优化，因为它们没有复杂的构造函数、析构函数或虚函数表。</p></li></ul></section><section><h3 id="-298164730#-vni64p_143" data-toc="-vni64p_143#STL源码分析.md--vni64p_143">示例</h3><p id="-298164730#-vni64p_756">以下是一个POD类型的示例：</p><div class="detached code-block" id="-298164730#-vni64p_757"><pre><code class="language-cpp">struct Point {
    int x;
    int y;
};

struct Rectangle {
    Point top_left;
    Point bottom_right;
};</code></pre></div><p id="-298164730#-vni64p_758">以上两个结构体都是POD类型，因为它们符合POD类型的所有要求。它们没有用户定义的构造函数、析构函数、虚函数，并且数据成员的访问权限都是<span class="inline-code" id="-298164730#-vni64p_759">public</span>。</p></section><section><h3 id="-298164730#pod" data-toc="pod#STL源码分析.md-pod">非POD类型示例</h3><p id="-298164730#-vni64p_760">以下是一个非POD类型的示例：</p><div class="detached code-block" id="-298164730#-vni64p_761"><pre><code class="language-cpp">struct NonPOD {
    NonPOD() : x(0), y(0) {} // 用户定义的构造函数
    int x;
    int y;
};</code></pre></div><p id="-298164730#-vni64p_762">由于<span class="inline-code" id="-298164730#-vni64p_763">NonPOD</span>具有用户定义的构造函数，因此它不是POD类型。</p></section><section><h3 id="-298164730#uninitialized-copy_1" data-toc="uninitialized-copy_1#STL源码分析.md-uninitialized-copy_1">uninitialized_copy() 实现方法</h3><p id="-298164730#-vni64p_764">uninitialized_copy()函数接受三个参数：</p><ul class="list" id="-298164730#-vni64p_765" start="1"><li class="list-item" id="-298164730#-vni64p_779"><p>迭代器 first 指向输入端的起始位置</p></li><li class="list-item" id="-298164730#-vni64p_780"><p>迭代器 last 指向输入端的结束位置</p></li><li class="list-item" id="-298164730#-vni64p_781"><p>迭代器 result 指向输出端的起始处</p></li></ul><p id="-298164730#-vni64p_766">输入端区间表示为[first, last)的前闭后开区间</p><div class="detached code-block" id="-298164730#-vni64p_767"><pre><code class="language-cpp">template&lt;class InputIterator, class ForwardIterator&gt;
inline ForwardIterator uninitialized_copy(InputIterator first,
                                          InputIterator last,
                                          ForwardIterator result){
    return __uninitialized_copy(first, last, result, value_type(result));
}
/* value_type 获取 first 的 value type */</code></pre></div><p id="-298164730#-vni64p_768">这个函数的执行逻辑：</p><ol class="list list-decimal" id="-298164730#-vni64p_769" type="1" start="1"><li class="list-item" id="-298164730#-vni64p_782"><p>先用萃取器萃取出迭代器result的value type</p></li><li class="list-item" id="-298164730#-vni64p_783"><p>判断该类型是否为POD类型</p></li></ol><div class="detached code-block" id="-298164730#-vni64p_770"><pre><code class="language-cpp">template &lt;class InputIterator, class ForwardIterator, class T&gt;
inline ForwardIterator __uninitialized_copy(InputIterator first,
                                            InputIterator last,
                                            ForwardIterator result,
                                            T*){
    typedef typename __type_traits&lt;T&gt;::is_POD_type is_POD;
    return __uninitialized_copy_aux(first, last, result, is_POD());
    /* apt to use the result of is_POD() to complement type inference */
}</code></pre></div><p id="-298164730#-vni64p_771">POD(Plain Old Data)指的是标量型别(scalar type)或传统的C struct型别。 因此POD型别内必然会有trivial ctor/dtor/copy/assignment函数(类比C++中的class)， 因此对POD型别采用效率最高的赋值方法，而对non-POD型别采用最安全的赋值方法：</p><ul class="list" id="-298164730#-vni64p_772" start="1"><li class="list-item" id="-298164730#-vni64p_784"><p>前提条件1：如果 copy assignment 等同于 assignment</p></li><li class="list-item" id="-298164730#-vni64p_785"><p>前提条件2：如果 destructor 等同于 trivial</p></li></ul><p id="-298164730#-vni64p_773">对于POD型别的处理：</p><div class="detached code-block" id="-298164730#-vni64p_774"><pre><code class="language-cpp">template&lt;class InputIterator, class ForwardIterator&gt;
inline ForwardIterator __uninitialized_copy_aux(InputIterator first,
                                                InputIterator last,
                                                ForwardIterator result,
                                                __true_type){
    return copy(first, last, result);   // invoke copy() from STL
}</code></pre></div><p id="-298164730#-vni64p_775">对于non-POD型别的处理：</p><div class="detached code-block" id="-298164730#-vni64p_776"><pre><code class="language-cpp">template&lt;class InputIterator, class ForwardIterator&gt;
inline ForwardIterator __uninitialized_copy_aux(InputIterator first,
                                                InputIterator last,
                                                ForwardIterator result,
                                                __false_type){
    ForwardIterator cur = result;
    for(; first != last; ++first, ++cur) construct(&amp;*cur, last);
    /* 此处只能够一个一个的元素进行构造，不能进行批量操作 */
    return cur;
}</code></pre></div><p id="-298164730#-vni64p_777">对于 char* 和 wchar_t* 这两种类型， 采用最有效率的做法 memmove(直接对内存中的内容进行移动)：</p><ul class="list" id="-298164730#-vni64p_778" start="1"><li class="list-item" id="-298164730#-vni64p_786"><p id="-298164730#-vni64p_787">针对 const char*</p><div class="detached code-block" id="-298164730#-vni64p_788"><pre><code class="language-cpp">/* a specialized version for const char* */
inline char* uninitialized_copy(const char* first,
                                const char* last,
                                char* result){
    memmove(result, first, last - first);
    return result + (last - first);
}</code></pre></div><ul class="list" id="-298164730#-vni64p_789" start="1"><li class="list-item" id="-298164730#-vni64p_790"><p id="-298164730#-vni64p_791">针对 const wchar*</p><div class="detached code-block" id="-298164730#-vni64p_792"><pre><code class="language-cpp">/* a specialized version for const wchar* */
inline wchar_t* uninitialized_copy(const wchar_t* first,
                                    const wchar_t* last,
                                    wchar_t* result){
  memmove(result, first, last - first);
  return result + (last - first);
}</code></pre></div></li></ul></li></ul></section><section><h3 id="-298164730#uninitialized-fill_1" data-toc="uninitialized-fill_1#STL源码分析.md-uninitialized-fill_1">uninitialized_fill 实现方法</h3><p id="-298164730#-vni64p_793">uninitialized_fill()函数接受三个参数：</p><ul class="list" id="-298164730#-vni64p_794" start="1"><li class="list-item" id="-298164730#-vni64p_807"><p>迭代器 first 指向输出端的起始位置</p></li><li class="list-item" id="-298164730#-vni64p_808"><p>迭代器 last 指向输出端的结束处(前闭后开区间)</p></li><li class="list-item" id="-298164730#-vni64p_809"><p>x 表示初值</p></li></ul><div class="detached code-block" id="-298164730#-vni64p_795"><pre><code class="language-cpp">template &lt;class ForwardIterator, class T&gt;
inline void uninitialized_fill(ForwardIterator first,
                               ForwardIterator last,
                               const T&amp; x){
    __uninitialized_fill(first, last, x, value_type(first));
}</code></pre></div><p id="-298164730#-vni64p_796">这个函数的执行逻辑：</p><ol class="list list-decimal" id="-298164730#-vni64p_797" type="1" start="1"><li class="list-item" id="-298164730#-vni64p_810"><p>先用萃取器萃取出迭代器result的value type</p></li><li class="list-item" id="-298164730#-vni64p_811"><p>判断该类型是否为POD类型</p></li></ol><div class="detached code-block" id="-298164730#-vni64p_798"><pre><code class="language-cpp">template&lt;class ForwardIterator, class T, class T1&gt;
inline void __uninitialized_fill(ForwardIterator first,
                                 ForwardIterator last,
                                 const T&amp; x,
                                 T1*){
    typedef typename __type_trait&lt;T&gt;::is_POD_type is_POD;
    __uninitialized_fill_aux(first, last, x, is_POD());
}</code></pre></div><p id="-298164730#-vni64p_799">POD(Plain Old Data)指的是标量型别(scalar type)或传统的C struct型别。 因此POD型别内必然会有trivial ctor/dtor/copy/assignment函数(类比C++中的class)， 因此对POD型别采用效率最高的赋值方法，而对non-POD型别采用最安全的赋值方法：</p><ul class="list" id="-298164730#-vni64p_800" start="1"><li class="list-item" id="-298164730#-vni64p_812"><p>前提条件1：如果 copy assignment 等同于 assignment</p></li><li class="list-item" id="-298164730#-vni64p_813"><p>前提条件2：如果 destructor 等同于 trivial</p></li></ul><p id="-298164730#-vni64p_801">对于POD型别的处理：</p><div class="detached code-block" id="-298164730#-vni64p_802"><pre><code class="language-cpp">template&lt;class ForwardIterator, class T&gt;
inline void __uninitialized_fill_aux(ForwardIterator first,
                                     ForwardIterator last,
                                     const T&amp; x,
                                     __true_type){
    fill(first, last, x);
}</code></pre></div><p id="-298164730#-vni64p_803">对于non-POD型别的处理：</p><div class="detached code-block" id="-298164730#-vni64p_804"><pre><code class="language-cpp">template&lt;class ForwardIterator, class T&gt;
void __uninitialzied_fill_aux(ForwardIterator first,
                              ForwardIterator last,
                              const T&amp; x,
                              __false_type){
    ForwardIterator cur = first;
    for(; cur != last; cur++) construct(&amp;*cur, x);
}</code></pre></div><p id="-298164730#-vni64p_805">对内存进行操作的函数的泛化版本和特化版本</p><div class="container"><figure class="image-container"><img class="center image image-size" id="-298164730#-vni64p_806" alt="image_28.png" title="image_28.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/image_28.png" width="646" height="777"><figcaption class="center-text">image_28.png</figcaption></figure></div></section></section></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="158479441">The Terms in Book 《STL源码分析》</h1><section><h2 id="158479441#-hewmno_3" data-toc="-hewmno_3#The-Terms-in-Book-《STL源码分析》.md--hewmno_3">中英文对照</h2><div class="table-wrapper detached"><table id="158479441#-hewmno_4"><tr class="header-row" id="158479441#-hewmno_6"><th id="158479441#-hewmno_72"><p>英文</p></th><th id="158479441#-hewmno_73"><p>中文</p></th><th id="158479441#-hewmno_74"><p>中文(台湾)</p></th></tr><tr class="" id="158479441#-hewmno_7"><td id="158479441#-hewmno_75"><p>adapter</p></td><td id="158479441#-hewmno_76"><p>适配器</p></td><td id="158479441#-hewmno_77"><p>配接器</p></td></tr><tr class="" id="158479441#-hewmno_8"><td id="158479441#-hewmno_78"><p>arguments</p></td><td id="158479441#-hewmno_79"><p>实参（实质参数）</p></td><td id="158479441#-hewmno_80"><p>引数</p></td></tr><tr class="" id="158479441#-hewmno_9"><td id="158479441#-hewmno_81"><p>by reference</p></td><td id="158479441#-hewmno_82"><p>传引用</p></td><td id="158479441#-hewmno_83"><p>传址</p></td></tr><tr class="" id="158479441#-hewmno_10"><td id="158479441#-hewmno_84"><p>by value</p></td><td id="158479441#-hewmno_85"><p>传值</p></td><td id="158479441#-hewmno_86"><p>传值</p></td></tr><tr class="" id="158479441#-hewmno_11"><td id="158479441#-hewmno_87"><p>dereference</p></td><td id="158479441#-hewmno_88"><p>解引用</p></td><td id="158479441#-hewmno_89"><p>提领</p></td></tr><tr class="" id="158479441#-hewmno_12"><td id="158479441#-hewmno_90"><p>evaluate</p></td><td id="158479441#-hewmno_91"><p>计算</p></td><td id="158479441#-hewmno_92"><p>评估</p></td></tr><tr class="" id="158479441#-hewmno_13"><td id="158479441#-hewmno_93"><p>instance</p></td><td id="158479441#-hewmno_94"><p>实例</p></td><td id="158479441#-hewmno_95"><p>实体</p></td></tr><tr class="" id="158479441#-hewmno_14"><td id="158479441#-hewmno_96"><p>instantiated</p></td><td id="158479441#-hewmno_97"><p>实例化</p></td><td id="158479441#-hewmno_98"><p>实体化</p></td></tr><tr class="" id="158479441#-hewmno_15"><td id="158479441#-hewmno_99"><p>library</p></td><td id="158479441#-hewmno_100"><p>库</p></td><td id="158479441#-hewmno_101"><p>程序库</p></td></tr><tr class="" id="158479441#-hewmno_16"><td id="158479441#-hewmno_102"><p>range</p></td><td id="158479441#-hewmno_103"><p>范围</p></td><td id="158479441#-hewmno_104"><p>区间（使用于STL）</p></td></tr><tr class="" id="158479441#-hewmno_17"><td id="158479441#-hewmno_105"><p>resolve</p></td><td id="158479441#-hewmno_106"><p>解析</p></td><td id="158479441#-hewmno_107"><p>决议</p></td></tr><tr class="" id="158479441#-hewmno_18"><td id="158479441#-hewmno_108"><p>parameter</p></td><td id="158479441#-hewmno_109"><p>形参（形式参数）</p></td><td id="158479441#-hewmno_110"><p>参数</p></td></tr><tr class="" id="158479441#-hewmno_19"><td id="158479441#-hewmno_111"><p>type</p></td><td id="158479441#-hewmno_112"><p>类型</p></td><td id="158479441#-hewmno_113"><p>型别</p></td></tr><tr class="" id="158479441#-hewmno_20"><td id="158479441#-hewmno_114"><p>Object Oriented</p></td><td id="158479441#-hewmno_115"><p>面对对象</p></td><td id="158479441#-hewmno_116"></td></tr><tr class="" id="158479441#-hewmno_21"><td id="158479441#-hewmno_117"><p>design patterns</p></td><td id="158479441#-hewmno_118"><p>设计模式</p></td><td id="158479441#-hewmno_119"></td></tr><tr class="" id="158479441#-hewmno_22"><td id="158479441#-hewmno_120"><p>STL（Standard Template Library)</p></td><td id="158479441#-hewmno_121"><p>标准模板库</p></td><td id="158479441#-hewmno_122"></td></tr><tr class="" id="158479441#-hewmno_23"><td id="158479441#-hewmno_123"><p>GP(Genetic Programming)</p></td><td id="158479441#-hewmno_124"><p>泛型编程</p></td><td id="158479441#-hewmno_125"></td></tr><tr class="" id="158479441#-hewmno_24"><td id="158479441#-hewmno_126"><p>couping</p></td><td id="158479441#-hewmno_127"><p>耦合性</p></td><td id="158479441#-hewmno_128"></td></tr><tr class="" id="158479441#-hewmno_25"><td id="158479441#-hewmno_129"><p>reusability</p></td><td id="158479441#-hewmno_130"><p>复用性</p></td><td id="158479441#-hewmno_131"></td></tr><tr class="" id="158479441#-hewmno_26"><td id="158479441#-hewmno_132"><p>Open-Closed</p></td><td id="158479441#-hewmno_133"><p>开放性封闭</p></td><td id="158479441#-hewmno_134"></td></tr><tr class="" id="158479441#-hewmno_27"><td id="158479441#-hewmno_135"><p>container</p></td><td id="158479441#-hewmno_136"><p>容器</p></td><td id="158479441#-hewmno_137"></td></tr><tr class="" id="158479441#-hewmno_28"><td id="158479441#-hewmno_138"><p>allocator</p></td><td id="158479441#-hewmno_139"><p>空间配置器</p></td><td id="158479441#-hewmno_140"></td></tr><tr class="" id="158479441#-hewmno_29"><td id="158479441#-hewmno_141"><p>underscore</p></td><td id="158479441#-hewmno_142"><p>下划线</p></td><td id="158479441#-hewmno_143"></td></tr><tr class="" id="158479441#-hewmno_30"><td id="158479441#-hewmno_144"><p>component</p></td><td id="158479441#-hewmno_145"><p>组件</p></td><td id="158479441#-hewmno_146"></td></tr><tr class="" id="158479441#-hewmno_31"><td id="158479441#-hewmno_147"><p>iterator</p></td><td id="158479441#-hewmno_148"><p>迭代器</p></td><td id="158479441#-hewmno_149"></td></tr><tr class="" id="158479441#-hewmno_32"><td id="158479441#-hewmno_150"><p>sequence container</p></td><td id="158479441#-hewmno_151"><p>序列式容器</p></td><td id="158479441#-hewmno_152"></td></tr><tr class="" id="158479441#-hewmno_33"><td id="158479441#-hewmno_153"><p>associated container</p></td><td id="158479441#-hewmno_154"><p>关联式容器</p></td><td id="158479441#-hewmno_155"></td></tr><tr class="" id="158479441#-hewmno_34"><td id="158479441#-hewmno_156"><p>algorithm</p></td><td id="158479441#-hewmno_157"><p>算法</p></td><td id="158479441#-hewmno_158"></td></tr><tr class="" id="158479441#-hewmno_35"><td id="158479441#-hewmno_159"><p>functor or function object</p></td><td id="158479441#-hewmno_160"><p>仿函数或函数对象</p></td><td id="158479441#-hewmno_161"></td></tr><tr class="" id="158479441#-hewmno_36"><td id="158479441#-hewmno_162"><p>polymorphism</p></td><td id="158479441#-hewmno_163"><p>多态性</p></td><td id="158479441#-hewmno_164"></td></tr><tr class="" id="158479441#-hewmno_37"><td id="158479441#-hewmno_165"><p>virtual function</p></td><td id="158479441#-hewmno_166"><p>虚函数</p></td><td id="158479441#-hewmno_167"></td></tr><tr class="" id="158479441#-hewmno_38"><td id="158479441#-hewmno_168"><p>genericity</p></td><td id="158479441#-hewmno_169"><p>泛型</p></td><td id="158479441#-hewmno_170"></td></tr><tr class="" id="158479441#-hewmno_39"><td id="158479441#-hewmno_171"><p>override</p></td><td id="158479441#-hewmno_172"><p>覆盖</p></td><td id="158479441#-hewmno_173"></td></tr><tr class="" id="158479441#-hewmno_40"><td id="158479441#-hewmno_174"><p>argument deduced</p></td><td id="158479441#-hewmno_175"><p>参数推导</p></td><td id="158479441#-hewmno_176"></td></tr><tr class="" id="158479441#-hewmno_41"><td id="158479441#-hewmno_177"><p>subroutine</p></td><td id="158479441#-hewmno_178"><p>子程序</p></td><td id="158479441#-hewmno_179"></td></tr><tr class="" id="158479441#-hewmno_42"><td id="158479441#-hewmno_180"><p>procedure</p></td><td id="158479441#-hewmno_181"><p>程序</p></td><td id="158479441#-hewmno_182"></td></tr><tr class="" id="158479441#-hewmno_43"><td id="158479441#-hewmno_183"><p>data structure</p></td><td id="158479441#-hewmno_184"><p>数据结构</p></td><td id="158479441#-hewmno_185"></td></tr><tr class="" id="158479441#-hewmno_44"><td id="158479441#-hewmno_186"><p>Genetic Paradigm</p></td><td id="158479441#-hewmno_187"><p>泛型思维</p></td><td id="158479441#-hewmno_188"></td></tr><tr class="" id="158479441#-hewmno_45"><td id="158479441#-hewmno_189"><p>components taxonomy</p></td><td id="158479441#-hewmno_190"><p>软件组件分类学</p></td><td id="158479441#-hewmno_191"></td></tr><tr class="" id="158479441#-hewmno_46"><td id="158479441#-hewmno_192"><p>library of abstract concepts</p></td><td id="158479441#-hewmno_193"><p>抽象概念库</p></td><td id="158479441#-hewmno_194"></td></tr><tr class="" id="158479441#-hewmno_47"><td id="158479441#-hewmno_195"><p>Assignable</p></td><td id="158479441#-hewmno_196"><p>可被赋值</p></td><td id="158479441#-hewmno_197"></td></tr><tr class="" id="158479441#-hewmno_48"><td id="158479441#-hewmno_198"><p>Default constructible</p></td><td id="158479441#-hewmno_199"><p>默认构造</p></td><td id="158479441#-hewmno_200"></td></tr><tr class="" id="158479441#-hewmno_49"><td id="158479441#-hewmno_201"><p>Equality Comparable</p></td><td id="158479441#-hewmno_202"><p>等价可判断</p></td><td id="158479441#-hewmno_203"></td></tr><tr class="" id="158479441#-hewmno_50"><td id="158479441#-hewmno_204"><p>LessThan Comparable</p></td><td id="158479441#-hewmno_205"><p>可比较大小</p></td><td id="158479441#-hewmno_206"></td></tr><tr class="" id="158479441#-hewmno_51"><td id="158479441#-hewmno_207"><p>Regular</p></td><td id="158479441#-hewmno_208"><p>常规</p></td><td id="158479441#-hewmno_209"></td></tr><tr class="" id="158479441#-hewmno_52"><td id="158479441#-hewmno_210"><p>Input Iterator</p></td><td id="158479441#-hewmno_211"><p>输入迭代器</p></td><td id="158479441#-hewmno_212"></td></tr><tr class="" id="158479441#-hewmno_53"><td id="158479441#-hewmno_213"><p>Output Iterator</p></td><td id="158479441#-hewmno_214"><p>输出迭代器</p></td><td id="158479441#-hewmno_215"></td></tr><tr class="" id="158479441#-hewmno_54"><td id="158479441#-hewmno_216"><p>Forward Iterator</p></td><td id="158479441#-hewmno_217"><p>单向迭代器</p></td><td id="158479441#-hewmno_218"></td></tr><tr class="" id="158479441#-hewmno_55"><td id="158479441#-hewmno_219"><p>Bidirectional Iterator</p></td><td id="158479441#-hewmno_220"><p>双向迭代器</p></td><td id="158479441#-hewmno_221"></td></tr><tr class="" id="158479441#-hewmno_56"><td id="158479441#-hewmno_222"><p>Random Access Iterator</p></td><td id="158479441#-hewmno_223"><p>随机存取迭代器</p></td><td id="158479441#-hewmno_224"></td></tr><tr class="" id="158479441#-hewmno_57"><td id="158479441#-hewmno_225"><p>Unary Function</p></td><td id="158479441#-hewmno_226"><p>一元函数</p></td><td id="158479441#-hewmno_227"></td></tr><tr class="" id="158479441#-hewmno_58"><td id="158479441#-hewmno_228"><p>Binary Function</p></td><td id="158479441#-hewmno_229"><p>二元函数</p></td><td id="158479441#-hewmno_230"></td></tr><tr class="" id="158479441#-hewmno_59"><td id="158479441#-hewmno_231"><p>Predicate</p></td><td id="158479441#-hewmno_232"><p>一元判断式</p></td><td id="158479441#-hewmno_233"></td></tr><tr class="" id="158479441#-hewmno_60"><td id="158479441#-hewmno_234"><p>Binary Predicate</p></td><td id="158479441#-hewmno_235"><p>二元判断式</p></td><td id="158479441#-hewmno_236"></td></tr><tr class="" id="158479441#-hewmno_61"><td id="158479441#-hewmno_237"><p>policy</p></td><td id="158479441#-hewmno_238"><p>策略</p></td><td id="158479441#-hewmno_239"></td></tr><tr class="" id="158479441#-hewmno_62"><td id="158479441#-hewmno_240"></td><td id="158479441#-hewmno_241"></td><td id="158479441#-hewmno_242"></td></tr><tr class="" id="158479441#-hewmno_63"><td id="158479441#-hewmno_243"></td><td id="158479441#-hewmno_244"></td><td id="158479441#-hewmno_245"></td></tr><tr class="" id="158479441#-hewmno_64"><td id="158479441#-hewmno_246"></td><td id="158479441#-hewmno_247"></td><td id="158479441#-hewmno_248"></td></tr><tr class="" id="158479441#-hewmno_65"><td id="158479441#-hewmno_249"></td><td id="158479441#-hewmno_250"></td><td id="158479441#-hewmno_251"></td></tr><tr class="" id="158479441#-hewmno_66"><td id="158479441#-hewmno_252"></td><td id="158479441#-hewmno_253"></td><td id="158479441#-hewmno_254"></td></tr><tr class="" id="158479441#-hewmno_67"><td id="158479441#-hewmno_255"></td><td id="158479441#-hewmno_256"></td><td id="158479441#-hewmno_257"></td></tr><tr class="" id="158479441#-hewmno_68"><td id="158479441#-hewmno_258"></td><td id="158479441#-hewmno_259"></td><td id="158479441#-hewmno_260"></td></tr><tr class="" id="158479441#-hewmno_69"><td id="158479441#-hewmno_261"></td><td id="158479441#-hewmno_262"></td><td id="158479441#-hewmno_263"></td></tr><tr class="" id="158479441#-hewmno_70"><td id="158479441#-hewmno_264"></td><td id="158479441#-hewmno_265"></td><td id="158479441#-hewmno_266"></td></tr><tr class="" id="158479441#-hewmno_71"><td id="158479441#-hewmno_267"></td><td id="158479441#-hewmno_268"></td><td id="158479441#-hewmno_269"></td></tr></table></div><p id="158479441#-hewmno_5">\begin 公式 \label{</p></section></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="756852540">Algorithm_Tutorial</h1><section><h2 id="756852540#quick-sort" data-toc="quick-sort#Algorithm-Tutorial.md-quick-sort">Quick_Sort</h2><section><h3 id="756852540#ioya35_12" data-toc="ioya35_12#Algorithm-Tutorial.md-ioya35_12">快速排序</h3><p id="756852540#ioya35_19">Luogu P1177 (<a href="https://www.luogu.com.cn/problem/P1177">https://www.luogu.com.cn/problem/P1177</a>) 将读入的 N 个数从小到大排序后输出。</p></section><section><h3 id="756852540#ioya35_13" data-toc="ioya35_13#Algorithm-Tutorial.md-ioya35_13">输入格式</h3><p id="756852540#ioya35_21">第一行为一个正整数 N。 第二行包含 N 个空格隔开的正整数a<span id="756852540#ioya35_22"><sub>i</sub></span>。</p></section><section><h3 id="756852540#ioya35_14" data-toc="ioya35_14#Algorithm-Tutorial.md-ioya35_14">输出格式</h3><p id="756852540#ioya35_23">将给定的 N 个数从小到大输出，数之间空格隔开，行未换行且无空格。</p><p id="756852540#ioya35_24">对于 100% 的数据，有 1 &le; N &le; 10<span id="756852540#ioya35_30"><sup>5</sup></span> ，1 &le; a<span id="756852540#ioya35_31"><sub>i</sub></span> &le; 10<span id="756852540#ioya35_32"><sup>9</sup></span>。</p><p id="756852540#ioya35_25">样例：</p><div class="detached code-block" id="756852540#ioya35_26"><pre><code class="language-none">输入
8
9 1 7 6 6 3 2 8</code></pre></div><div class="detached code-block" id="756852540#ioya35_27"><pre><code class="language-none">输出
1 2 3 6 6 7 8 9</code></pre></div><p id="756852540#ioya35_28">快速排序主要利用<span class="control" id="756852540#ioya35_33">分治思想</span> ，时间复杂度<span class="control" id="756852540#ioya35_34">O(nlogn)</span>。</p><div class="detached code-block" id="756852540#ioya35_29"><pre><code class="language-none">int n, a[100005];

void quicksort(int l, int r){
    if(l == r) return;
    int i = l - 1, j = r + 1, x = q[(l + r) &gt;&gt; 1];
    while(i &lt; j){
        do i++; while(q[i] &lt; x);    // 向右查找 ≥x 的数
        do j--; while(q[j] &gt; x);    // 向左查找 ≤x 的数
        if(i &lt; j) swap(q[i], q[j]);
    }
    quicksort(l, j), quicksort(j + 1, r);
}</code></pre></div></section><section><h3 id="756852540#ioya35_15" data-toc="ioya35_15#Algorithm-Tutorial.md-ioya35_15">思路如下</h3><ol class="list list-decimal" id="756852540#ioya35_35" type="1" start="1"><li class="list-item" id="756852540#ioya35_36"><p>利用<span class="control" id="756852540#ioya35_39">i（左指针）</span>, <span class="control" id="756852540#ioya35_40">j（右指针）</span> 指向数列的区间外侧，数列的中值记为<span class="control" id="756852540#ioya35_41">x</span>。</p></li><li class="list-item" id="756852540#ioya35_37"><p>将数列中 <span class="control" id="756852540#ioya35_42">&le;x</span> 的数放左段， <span class="control" id="756852540#ioya35_43">&ge;x</span> 的数放右段。</p></li><li class="list-item" id="756852540#ioya35_38"><p>对于左右两段，再递归以上两个过程，直到每段只有一个数，即全部有序。 </p><div class="container"><figure class="image-container"><img class="center image image-size" id="756852540#ioya35_44" alt="quick_sort1.png" title="quick_sort1.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/quick_sort1.png" width="1985" height="618"><figcaption class="center-text">quick_sort1.png</figcaption></figure></div></li></ol></section><section><h3 id="756852540#ioya35_16" data-toc="ioya35_16#Algorithm-Tutorial.md-ioya35_16">过程模拟</h3><div class="container"><figure class="image-container"><img class="center image image-size" id="756852540#ioya35_45" alt="quick_sort2.png" title="quick_sort2.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/quick_sort2.png" width="1990" height="1169"><figcaption class="center-text">quick_sort2.png</figcaption></figure></div></section><section><h3 id="756852540#ioya35_17" data-toc="ioya35_17#Algorithm-Tutorial.md-ioya35_17">补充</h3><div class="container"><figure class="image-container"><img class="center image image-size" id="756852540#ioya35_46" alt="quick_sort4.png" title="quick_sort4.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/quick_sort4.png" width="2003" height="1103"><figcaption class="center-text">quick_sort4.png</figcaption></figure></div><p id="756852540#ioya35_47">即在中间值的左边找一个大于中间值的数m<span id="756852540#ioya35_52"><sub>1</sub></span>, 在中间值的右边找一个小于中间值的数m<span id="756852540#ioya35_53"><sub>2</sub></span>, 并且当m<span id="756852540#ioya35_54"><sub>1</sub></span>小于m<span id="756852540#ioya35_55"><sub>2</sub></span>时，才交换m<span id="756852540#ioya35_56"><sub>1</sub></span>和m<span id="756852540#ioya35_57"><sub>2</sub></span> ，交换完成后再进行分割，再对分割的区域重复上述的操作。</p><p id="756852540#ioya35_48"><span class="control" id="756852540#ioya35_58">STL实现</span></p><div class="detached code-block" id="756852540#ioya35_49"><pre><code class="language-none">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

int n, a[100005];

int main(){
    cin &gt;&gt; n;
    for(int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;a[i]);
    sort(a, a + n);
    for(int i = 0; i &lt; n; i++) printf(&quot;%d&quot;, &amp;a[i]);
    return 0;
}</code></pre></div><p id="756852540#ioya35_50"><span class="control" id="756852540#ioya35_59">一般实现</span></p><div class="detached code-block" id="756852540#ioya35_51"><pre><code class="language-none">#include &lt;iostream&gt;
using namespace std;

int n, a[100005];

void quicksort(int l, int r){
    if(l == r) return;
    int i = l - 1, j = r + 1, x = q[(l + r) &gt;&gt; 1];
    while(i &lt; j){
        do i++; while(q[i] &lt; x);    // 向右查找 ≥x 的数
        do j--; while(q[j] &gt; x);    // 向左查找 ≤x 的数
        if(i &lt; j) swap(q[i], q[j]);
    }
    quicksort(l, j), quicksort(j + 1, r);
}

int main(){
    cin &gt;&gt; n;
    for(int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;a[i]);
    quicksort(0, n - 1);
    for(int i = 0; i &lt; n; i++) printf(&quot;%d&quot;, &amp;a[i]); 
    return 0; 
}</code></pre></div></section><section><h3 id="756852540#ioya35_18" data-toc="ioya35_18#Algorithm-Tutorial.md-ioya35_18">题目</h3><p id="756852540#ioya35_60">Luogu P1923 (<a href="https://www.luogu.com.cn/problem/P1923">https://www.luogu.com.cn/problem/P1923</a>) 求第 k 小的数</p><p id="756852540#ioya35_61">输入 <span class="emphasis" id="756852540#ioya35_72">n</span> （1 &le; <span class="emphasis" id="756852540#ioya35_73">n</span> &le; 5000000 且 <span class="emphasis" id="756852540#ioya35_74">n</span> 为奇数）个数字a<span id="756852540#ioya35_75"><sub>i</sub></span> (1 &le; a<span id="756852540#ioya35_76"><sub>i</sub></span> &le; 10<span id="756852540#ioya35_77"><sup>9</sup></span>) ， 输出这些数字的第 <span class="emphasis" id="756852540#ioya35_78">k</span> 小的数。最小的数是第 0 小。</p><p id="756852540#ioya35_62">请尽量不要使用 <span class="inline-code" id="756852540#ioya35_79"> nth_element </span> 来写本题，因为本题的重点在于练习分治算法。 因为<span class="inline-code" id="756852540#ioya35_80"> nth_element </span>可以待<span class="inline-code" id="756852540#ioya35_81">quicksort</span>后再输出<span class="control" id="756852540#ioya35_82">nth_element</span> ，这种做法会消耗多余的时间去处理多余的一半部分。</p><p id="756852540#ioya35_63">样例:</p><div class="detached code-block" id="756852540#ioya35_64"><pre><code class="language-none">输入
5 1
4 3 2 1 5</code></pre></div><div class="detached code-block" id="756852540#ioya35_65"><pre><code class="language-none">输出
2</code></pre></div><div class="container"><figure class="image-container"><img class="center image image-size" id="756852540#ioya35_66" alt="kth_number.png" title="kth_number.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/kth_number.png" width="2012" height="556"><figcaption class="center-text">kth_number.png</figcaption></figure></div><p id="756852540#ioya35_67"><span class="control" id="756852540#ioya35_83">STL实现</span></p><div class="detached code-block" id="756852540#ioya35_68"><pre><code class="language-none">#include &lt;iostream&gt;
using namespace std;

int n, k, a[5000010];

int main(){
    cin &gt;&gt; n &gt;&gt; k;
    for(int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;,&amp;a[i]);
    nth_element(a, a + k, a + n);
    printf(&quot;%d\n&quot;, a[k]);
    return 0;
}</code></pre></div><p id="756852540#ioya35_69"><span class="control" id="756852540#ioya35_84">一般实现</span></p><div class="detached code-block" id="756852540#ioya35_70"><pre><code class="language-none">#include &lt;iostream&gt;
using namespace std;

int n, k, q[5000010];

template&lt;typename T&gt;
void Swap(T&amp; t1_, T&amp; t2_){
    T t_ = t1_;
    t1_ = t2_;
    t2_ = t;
}

void kth_number(int q[], int l, int r, int k){
    if(l &gt;= r） return q[l]; 
    
    int i = l - 1, j = r + 1, x = q[(l + r) &gt;&gt; 1];
    while(i &lt; j){
        do i++; while(q[i] &lt; x);
        do j--; while(q[j] &gt; x);
        if(i &lt; j) Swap(q[i], q[j]); 
    }
    if(k &lt;= j) return kth_number(q, l, j, k);
    else return kth_number(q, j + 1, r, k);
}

int main(){
    cin &gt;&gt; n &gt;&gt; k;
    for(int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, q[i]);
    cout &lt;&lt; kth_number(q, 0, n - 1, k);
    return 0;
}</code></pre></div></section></section><section><h2 id="756852540#merge-sort" data-toc="merge-sort#Algorithm-Tutorial.md-merge-sort">Merge_Sort</h2><section><h3 id="756852540#ioya35_85" data-toc="ioya35_85#Algorithm-Tutorial.md-ioya35_85">归并排序</h3><p id="756852540#ioya35_101">Luogu P1177 (<a href="https://www.luogu.com.cn/problem/P1177">https://www.luogu.com.cn/problem/P1177</a>) 将读入的<span class="emphasis" id="756852540#ioya35_103">N</span>个数从小到大排序后输出</p></section><section><h3 id="756852540#ioya35_86" data-toc="ioya35_86#Algorithm-Tutorial.md-ioya35_86">输入格式</h3><p id="756852540#ioya35_104">第一行为一个正整数<span class="emphasis" id="756852540#ioya35_105">N</span>。 第二行包含<span class="emphasis" id="756852540#ioya35_106">N</span>个空格隔开的正整数a<span id="756852540#ioya35_107"><sub>i</sub></span> ，为你需要进行排序的数。</p></section><section><h3 id="756852540#ioya35_87" data-toc="ioya35_87#Algorithm-Tutorial.md-ioya35_87">输出格式</h3><p id="756852540#ioya35_108">将给定的<span class="emphasis" id="756852540#ioya35_111">N</span>个数从小到大输出，数之间空格隔开，行末换行且无空格。</p><p id="756852540#ioya35_109">对于20%的数据，有1&le;<span class="emphasis" id="756852540#ioya35_112">N</span>&le;10<span id="756852540#ioya35_113"><sup>3</sup></span>;</p><p id="756852540#ioya35_110">对于100%的数据，有1&le;<span class="emphasis" id="756852540#ioya35_114">N</span>&le;10<span id="756852540#ioya35_115"><sup>5</sup></span> ，1&le;a<span id="756852540#ioya35_116"><sub>i</sub></span>&le;10<span id="756852540#ioya35_117"><sup>9</sup></span>。</p></section><section><h3 id="756852540#ioya35_88" data-toc="ioya35_88#Algorithm-Tutorial.md-ioya35_88">样例</h3><div class="detached code-block" id="756852540#ioya35_118"><pre><code class="language-none">输入
5
5 2 4 5 1</code></pre></div><div class="detached code-block" id="756852540#ioya35_119"><pre><code class="language-none">输出
1 2 4 4 5</code></pre></div><p id="756852540#ioya35_120">归并排序主要利用<span class="control" id="756852540#ioya35_128">分治思想</span> ，时间复杂度为O(<span class="emphasis" id="756852540#ioya35_129">nlogn</span>)。</p><div class="detached code-block" id="756852540#ioya35_121"><pre><code class="language-none">int n, a[100010], b[100010];    /* 此处a，b为辅助数组 */

void merge_sort(int q[], int l, int r){
    if(l &gt;= r) return;
    int mid = (l + r) &gt;&gt; 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);  /* 递归拆分 */
    
    int i = l, j = mid + 1, k = l;  /* 合并 */
    while(i &lt;= mid &amp;&amp; j &lt;= r){
        if(a[i] &lt;= a[j]) b[k++] = a[i++];
        else b[k++] = a[j++];
    }
    
    while(i &lt;= mid) b[k++] = a[i++];
    while(j &lt;= r) b[k++] = a[j++];
    for(i = l; i &lt;= r; i++) a[i] = b[i];
}
### 思路如下 ###</code></pre></div><ol class="list list-decimal" id="756852540#ioya35_122" type="1" start="1"><li class="list-item" id="756852540#ioya35_130"><p>对数列不断进行等长<span class="control" id="756852540#ioya35_133">拆分</span> ，直到为<span class="control" id="756852540#ioya35_134">一个数</span>的长度;</p></li><li class="list-item" id="756852540#ioya35_131"><p>回溯时，按升序<span class="control" id="756852540#ioya35_135">合并</span>左右两段。</p></li><li class="list-item" id="756852540#ioya35_132"><p>重复以上两个过程，直到递归结束。</p></li></ol><p id="756852540#ioya35_123"><span class="control" id="756852540#ioya35_136">划分</span></p><div class="container"><figure class="image-container"><img class="center image image-size" id="756852540#ioya35_124" alt="divide.png" title="divide.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/divide.png" width="769" height="660"><figcaption class="center-text">divide.png</figcaption></figure></div><div class="detached code-block" id="756852540#ioya35_125"><pre><code class="language-none">合并：
1. i,j 分别指向a的左右段起点，k指向b的起点。
2. 枚举a数组，如果左数≤右数，把左数放入b数组，否则，把右数放入b数组。
3. 把左段或右端剩余的数放入b数组。
4. 把b数组的当前段复制回a数组。</code></pre></div><div class="container"><figure class="image-container"><img class="center image image-size" id="756852540#ioya35_126" alt="conjunct.png" title="conjunct.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/conjunct.png" width="768" height="660"><figcaption class="center-text">conjunct.png</figcaption></figure></div><div class="table-wrapper detached"><table id="756852540#ioya35_127"><tr class="header-row" id="756852540#ioya35_137"><th id="756852540#ioya35_140"></th><th id="756852540#ioya35_141"><p>快速排序</p></th><th id="756852540#ioya35_142"><p>归并排序</p></th></tr><tr class="" id="756852540#ioya35_138"><td id="756852540#ioya35_143"><p>分治</p></td><td id="756852540#ioya35_144"><p>先交换后拆分</p></td><td id="756852540#ioya35_145"><p>先拆分后交换</p></td></tr><tr class="" id="756852540#ioya35_139"><td id="756852540#ioya35_146"><p>稳定性</p></td><td id="756852540#ioya35_147"><p>不稳定</p></td><td id="756852540#ioya35_148"><p>稳定</p></td></tr></table></div></section><section><h3 id="756852540#ioya35_89" data-toc="ioya35_89#Algorithm-Tutorial.md-ioya35_89">完整实现如下</h3><div class="detached code-block" id="756852540#ioya35_149"><pre><code class="language-none">#include &lt;iostream&gt;
using namespace std;
int n, a[100010], b[100010];

void merge_sort(int l, int r){
    if(l &gt;= r) return;
    int mid = (l + r) &gt;&gt; 1;
    merge_sort(l, mid); 
    merge_sort(mid + 1, r);

    int i = l, j = mid + 1, k = l;
    while(i &lt;= mid &amp;&amp; j &lt;= r)
        if(a[i] &lt;= a[j]) b[k++] = a[i++];
        else b[k++] = a[j++];

    while(i &lt;= mid) b[k++] = a[i++];
    while(j &lt;= r) b[k++] = a[j++];
    for(i = l; i &lt;= r; i++) a[i] = b[i];
}

int main(){
    cin &gt;&gt; n;
    for(int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;a[i]);
    merge_sort(0, n - 1);
    for(int i = 0; i &lt; n; i++) printf(&quot;%d &quot;, a[i]);
    return 0;
}</code></pre></div><p id="756852540#ioya35_150">Luogu P1908 (<a href="https://www.luogu.com.cn/problem/P1908">https://www.luogu.com.cn/problem/P1908</a>)逆序对</p><p id="756852540#ioya35_151">对于给定的一段正整数序列，逆序对就是序列中a<span id="756852540#ioya35_153"><sub>i</sub></span> &gt; a<span id="756852540#ioya35_154"><sub>j</sub></span> 且<span class="emphasis" id="756852540#ioya35_155">i</span> &lt; <span class="emphasis" id="756852540#ioya35_156">j</span>的有序对。注意序列中可能有重复数字。</p></section><section><h3 id="756852540#ioya35_90" data-toc="ioya35_90#Algorithm-Tutorial.md-ioya35_90">输入格式</h3><p id="756852540#ioya35_157">第一行，一个数n，表示序列中有<span class="emphasis" id="756852540#ioya35_162">n</span>个数。</p><p id="756852540#ioya35_158">第二行<span class="emphasis" id="756852540#ioya35_163">n</span>个数，表示给定的序列。序列中每个数字不超过10<span id="756852540#ioya35_164"><sup>9</sup></span>。</p><p id="756852540#ioya35_159">对于25%的数据，n&le;2500。</p><p id="756852540#ioya35_160">对于50%的数据，n&le;4 x 10<span id="756852540#ioya35_165"><sup>4</sup></span>。</p><p id="756852540#ioya35_161">对于所有数据，n&le;5 x 10<span id="756852540#ioya35_166"><sup>5</sup></span>。</p></section><section><h3 id="756852540#ioya35_91" data-toc="ioya35_91#Algorithm-Tutorial.md-ioya35_91">输出格式</h3><p id="756852540#ioya35_167">输出序列中逆序对的数目。</p><div class="detached code-block" id="756852540#ioya35_168"><pre><code class="language-none">输入
6 
5 4 2 6 3 1</code></pre></div><div class="detached code-block" id="756852540#ioya35_169"><pre><code class="language-none">输出
11</code></pre></div></section><section><h3 id="756852540#ioya35_92" data-toc="ioya35_92#Algorithm-Tutorial.md-ioya35_92">示例</h3><div class="container"><figure class="image-container"><img class="center image image-size" id="756852540#ioya35_170" alt="reverse_pair.png" title="reverse_pair.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/reverse_pair.png" width="547" height="446"><figcaption class="center-text">reverse_pair.png</figcaption></figure></div></section><section><h3 id="756852540#ioya35_93" data-toc="ioya35_93#Algorithm-Tutorial.md-ioya35_93">实现方法</h3><div class="detached code-block" id="756852540#ioya35_171"><pre><code class="language-none">#include &lt;iostream&gt;
using namespace std;

typedef long long LL;

int n, a[5000010], b[5000010];
LL res = 0;

void reverse_pair(int l, int r){
    if(l &gt;= r) return;
    int mid = (l + r) &gt;&gt; 1;
    reverse_pair(l, mid);
    reverse_pair(mid + 1, r);
    
    int i = l, j = mid + 1, k = l;
    while(i &lt;= mid &amp;&amp; j &lt;= r)
        if(a[i] &lt;= a[j]) b[k++] = a[i++];
        else b[k++] = a[j++], res += mid - i + 1;
     
    while(i &lt;= mid) b[k++] = a[i++];
    while(j &lt;= r) b[k++] = a[j++];
    for(i = l; i &lt;= r; i++) a[i] = b[i];
}

int main(){
    cin &gt;&gt; n;
    for(int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;a[i]);
    reverse_pair(0, n - 1);
    cout &lt;&lt; res;
    return 0;
}</code></pre></div><p id="756852540#ioya35_172"><span class="inline-code" id="756852540#ioya35_174">解释 of 'res += mid - i + 1': 当合并两个有序数组时，如果a[i]&gt;a[j]，说明a[i]及其后面的元素都比a[i]大，因为数组是有序的。所以，对于当前的a[j]来说，它与前半部分数组中剩余的元素构成逆序对。</span></p><p id="756852540#ioya35_173">Luogu P1966 (<a href="https://www.luogu.com.cn/problem/P1966">https://www.luogu.com.cn/problem/P1966</a>)火柴排队</p></section><section><h3 id="756852540#ioya35_94" data-toc="ioya35_94#Algorithm-Tutorial.md-ioya35_94">题目描述</h3><p id="756852540#ioya35_176">涵涵有两盒火柴，每盒装有 <span class="emphasis" id="756852540#ioya35_179">n</span> 根火柴，每根火柴都有一个高度。 现在将每盒中的火柴各自排成一列， 同一列火柴的高度互不相同， 两列火柴之间的距离定义为： <span class="control" id="756852540#ioya35_180">&sum;(a<span id="756852540#ioya35_181"><sub>i</sub></span> - b<span id="756852540#ioya35_182"><sub>i</sub></span>) <span id="756852540#ioya35_183"><sup>2</sup></span></span></p><p id="756852540#ioya35_177">其中 a<span id="756852540#ioya35_184"><sub>i</sub></span> 表示第一列火柴中第 <span class="emphasis" id="756852540#ioya35_185">i</span> 个火柴的高度，b<span id="756852540#ioya35_186"><sub>i</sub></span> 表示第二列火柴中第 <span class="emphasis" id="756852540#ioya35_187">i</span> 个火柴的高度。</p><p id="756852540#ioya35_178">每列火柴中相邻两根火柴的位置都可以交换，请你通过交换使得两列火柴之间的距离最小。请问得到这个最小的距离，最少需要交换多少次？如果这个数字太大，请输出这个最小交换次数对 <span class="control" id="756852540#ioya35_188">10<span id="756852540#ioya35_189"><sup>8</sup></span> - 3</span> 取模的结果。</p></section><section><h3 id="756852540#ioya35_95" data-toc="ioya35_95#Algorithm-Tutorial.md-ioya35_95">输入格式</h3><p id="756852540#ioya35_190">共三行，第一行包含一个整数 <span class="emphasis" id="756852540#ioya35_193">n</span> ，表示每盒中火柴的数目。</p><p id="756852540#ioya35_191">第二行有 <span class="emphasis" id="756852540#ioya35_194">n</span> 个整数，每两个整数之间用一个空格隔开，表示第一列火柴的高度。</p><p id="756852540#ioya35_192">第三行有 <span class="emphasis" id="756852540#ioya35_195">n</span> 个整数，每两个整数之间用一个空格隔开，表示第二列火柴的高度。</p></section><section><h3 id="756852540#ioya35_96" data-toc="ioya35_96#Algorithm-Tutorial.md-ioya35_96">输出格式</h3><p id="756852540#ioya35_196">一个整数，表示最少交换次数对 <span class="control" id="756852540#ioya35_197">10<span id="756852540#ioya35_198"><sup>8</sup></span> - 3</span> 取模的结果。</p></section><section><h3 id="756852540#1" data-toc="1#Algorithm-Tutorial.md-1">样例1</h3><div class="detached code-block" id="756852540#ioya35_199"><pre><code class="language-none">输入
4
2 3 1 4
3 2 1 4</code></pre></div><div class="detached code-block" id="756852540#ioya35_200"><pre><code class="language-none">输出
1</code></pre></div></section><section><h3 id="756852540#2" data-toc="2#Algorithm-Tutorial.md-2">样例2</h3><div class="detached code-block" id="756852540#ioya35_201"><pre><code class="language-none">输入
4
1 3 4 2
1 7 2 4</code></pre></div><div class="detached code-block" id="756852540#ioya35_202"><pre><code class="language-none">输出
2</code></pre></div><p id="756852540#ioya35_203"><span class="control" id="756852540#ioya35_212">输入输出样例说明一</span></p><p id="756852540#ioya35_204">最小距离是 <span class="emphasis" id="756852540#ioya35_213">0</span> ，最少需要交换 <span class="emphasis" id="756852540#ioya35_214">1</span> 次，比如：交换第 <span class="emphasis" id="756852540#ioya35_215">1</span> 列的前 <span class="emphasis" id="756852540#ioya35_216">2</span> 根火柴或者交换第 <span class="emphasis" id="756852540#ioya35_217">2</span> 列的前 <span class="emphasis" id="756852540#ioya35_218">2</span> 根火柴。</p><p id="756852540#ioya35_205"><span class="control" id="756852540#ioya35_219">输入输出样例说明二</span></p><p id="756852540#ioya35_206">最小距离是 <span class="emphasis" id="756852540#ioya35_220">10</span> ，最少需要交换 <span class="emphasis" id="756852540#ioya35_221">2</span> 次，比如：交换第 <span class="emphasis" id="756852540#ioya35_222">1</span> 列的中间 <span class="emphasis" id="756852540#ioya35_223">2</span> 根火柴的位置，再交换第 <span class="emphasis" id="756852540#ioya35_224">2</span> 列中后 <span class="emphasis" id="756852540#ioya35_225">2</span> 根火柴的位置。</p><p id="756852540#ioya35_207"><span class="control" id="756852540#ioya35_226">数据范围</span></p><p id="756852540#ioya35_208">对于 10% 的数据， 1 &le; <span class="emphasis" id="756852540#ioya35_227">n</span> &le; 10<span id="756852540#ioya35_228"><sup>1</sup></span>；</p><p id="756852540#ioya35_209">对于 30% 的数据，1 &le; <span class="emphasis" id="756852540#ioya35_229">n</span> &le; 10<span id="756852540#ioya35_230"><sup>2</sup></span>；</p><p id="756852540#ioya35_210">对于 60% 的数据，1 &le; <span class="emphasis" id="756852540#ioya35_231">n</span> &le; 10<span id="756852540#ioya35_232"><sup>3</sup></span>；</p><p id="756852540#ioya35_211">对于 100% 的数据，1 &le; <span class="emphasis" id="756852540#ioya35_233">n</span> &le; 10<span id="756852540#ioya35_234"><sup>5</sup></span> ，0 &le; 火柴高度 &le; 2<span id="756852540#ioya35_235"><sup>31</sup></span>。</p></section><section><h3 id="756852540#ioya35_99" data-toc="ioya35_99#Algorithm-Tutorial.md-ioya35_99">整体思路</h3><ol class="list list-decimal" id="756852540#ioya35_236" type="1" start="1"><li class="list-item" id="756852540#ioya35_237"><p>根据每盒火柴的高度，用快速排序<span class="inline-code" id="756852540#ioya35_240">quick_sort</span>对其从小到大进行排序</p></li><li class="list-item" id="756852540#ioya35_238"><p>利用第<span class="control" id="756852540#ioya35_241">2</span>盒火柴中的位置对第<span class="control" id="756852540#ioya35_242">1</span>盒火柴中的位置进行映射，使之与排序之前的位置相同</p></li><li class="list-item" id="756852540#ioya35_239"><p>再利用归并排序<span class="inline-code" id="756852540#ioya35_243">reverse_pair</span>计算逆序数(即要交换的次数，题目中指出相邻的两根火柴可交换)。</p></li></ol></section><section><h3 id="756852540#ioya35_100" data-toc="ioya35_100#Algorithm-Tutorial.md-ioya35_100">实现方法</h3><div class="detached code-block" id="756852540#ioya35_244"><pre><code class="language-none">#include &lt;cstdio&gt;

struct node{
    int num, ord;
    bool operator&lt;(node b1_){ return num &lt; b1_.num; }
    bool operator&gt;(node b2_){ return num &gt; b2_.num; }
}f[100010], s[100010];

template&lt;typename T&gt;
void Swap(T&amp; t1_, T&amp; t2_){
    T t_ = t1_;
    t1_ = t2_;
    t2_ = t_;
}

int a[100010], b[100010], n, ans = 0;

// 类比归并排序求逆序数
void reverse_pair(int l, int r){
    if(l &gt;= r) return;
    int mid = (l + r) &gt;&gt; 1;
    reverse_pair(l, mid);
    reverse_pair(mid + 1, r);
    
    int i = l, j = mid + 1, k = l;
    while(i &lt;= mid &amp;&amp; j &lt;= r)
        if(a[i] &lt;= a[j]) b[k++] = a[i++];
        else{
            b[k++] = a[j++];
            ans += mid - i + 1; // 求逆序数
            ans %= 99999997;    // 处理结果
        }
        
    while(i &lt;= mid) b[k++] = a[i++];
    while(j &lt;= r) b[k++] = a[j++];
    for(i = l; i &lt;= r; i++) a[i] = b[i];
}

// 一般快速排序
void quick_sort(node q[], int l, int r){
    if(l &gt;= r) return;
    int i = l - 1, j = r + 1;
    node x = q[(l + r) &gt;&gt; 1];
    while(i &lt; j){
        do i++; while(q[i] &lt; x);
        do j--; while(q[j] &gt; x);
        if(i &lt; j) Swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}

int main(){
    // 读入数据
    scanf(&quot;%d&quot;, &amp;n);
    for(int i = 1; i &lt;= n; i++){
        scanf(&quot;%d&quot;, &amp;f[i].num);
        f[i].ord = i;
    }
    
    for(int i = 1; i &lt;= n; i++){
        scanf(&quot;%d&quot;, &amp;s[i].num);
        s[i].ord = i;
    }
    
    // 根据高度对两盒火柴进行排序
    quick_sort(f, 1, n);    
    quick_sort(s, 1, n);
    
    // 映射火柴的顺序
    for(int i = 1; i &lt;= n; i++) a[f[i].ord] = s[i].ord;
    
    reverse_pair(1, n);
    printf(&quot;%d&quot;, ans);
    
    return 0;
}</code></pre></div></section></section><section><h2 id="756852540#binary-search" data-toc="binary-search#Algorithm-Tutorial.md-binary-search">Binary_Search</h2><p id="756852540#ioya35_245">Luogu P2249 (<a href="https://www.luogu.com.cn/problem/P2249">https://www.luogu.com.cn/problem/P2249</a>) 查找</p><section><h3 id="756852540#ioya35_246" data-toc="ioya35_246#Algorithm-Tutorial.md-ioya35_246">题目描述</h3><p id="756852540#ioya35_261">输入 <span class="emphasis" id="756852540#ioya35_262">n</span> 个不超过 10<span id="756852540#ioya35_263"><sup>9</sup></span> 的单调不减的（就是后面的数字不小于前面的数字）非负整 数a<span id="756852540#ioya35_265"><sub>1</sub></span>, a<span id="756852540#ioya35_266"><sub>2</sub></span>, ... , a<span id="756852540#ioya35_267"><sub>n</sub></span>, 然后进行 <span class="emphasis" id="756852540#ioya35_268">m</span> 次询问。对于每次询问，给出一个整数 <span class="emphasis" id="756852540#ioya35_269">q</span> ，要求输出这个数字在序列中第一次出现的编号，如果没有找的话输出 -1。</p></section><section><h3 id="756852540#ioya35_247" data-toc="ioya35_247#Algorithm-Tutorial.md-ioya35_247">输入格式</h3><p id="756852540#ioya35_270">第一行<span class="control" id="756852540#ioya35_273">2</span>个整数<span class="emphasis" id="756852540#ioya35_274">n</span>和<span class="emphasis" id="756852540#ioya35_275">m</span> ，表示数字个数和询问次数。</p><p id="756852540#ioya35_271">第二行<span class="emphasis" id="756852540#ioya35_276">n</span>个整数，表示这些待查询的数字。</p><p id="756852540#ioya35_272">第三行<span class="emphasis" id="756852540#ioya35_277">m</span>个整数，表示询问这些数字的编号，从1开始编号。</p></section><section><h3 id="756852540#ioya35_248" data-toc="ioya35_248#Algorithm-Tutorial.md-ioya35_248">输出格式</h3><p id="756852540#ioya35_278">输出一行，m个整数，以空格隔开，表示答案。</p></section><section><h3 id="756852540#ioya35_249" data-toc="ioya35_249#Algorithm-Tutorial.md-ioya35_249">样例</h3><div class="detached code-block" id="756852540#ioya35_279"><pre><code class="language-none">输入
11 3
1 3 3 3 5 7 9 11 13 15 15
1 3 6</code></pre></div><div class="detached code-block" id="756852540#ioya35_280"><pre><code class="language-none">输出
1 2 -1</code></pre></div><p id="756852540#ioya35_281">数据保证，1 &le; <span class="emphasis" id="756852540#ioya35_282">n</span> &le; 10<span id="756852540#ioya35_283"><sup>6</sup></span>， 0 &le; <span class="emphasis" id="756852540#ioya35_284">a<span id="756852540#ioya35_288"><sub>i</sub></span>, q</span> &le; 10<span id="756852540#ioya35_285"><sup>9</sup></span>, 1 &le; <span class="emphasis" id="756852540#ioya35_286">m</span> &le; 10<span id="756852540#ioya35_287"><sup>5</sup></span></p></section><section><h3 id="756852540#ioya35_250" data-toc="ioya35_250#Algorithm-Tutorial.md-ioya35_250">思路</h3><ol class="list list-decimal" id="756852540#ioya35_289" type="1" start="1"><li class="list-item" id="756852540#ioya35_290"><p>向存在目标值的区间缩小</p></li><li class="list-item" id="756852540#ioya35_291"><p>同时注意区间问题</p></li></ol></section><section><h3 id="756852540#ioya35_251" data-toc="ioya35_251#Algorithm-Tutorial.md-ioya35_251">模板一</h3><div class="detached code-block" id="756852540#ioya35_292"><pre><code class="language-none">#include &lt;iostream&gt; 
using namespace std;

int n, m, q, a[1000005];

int find(int q){
    int l = 0, r = n + 1;
    while(l + 1 &lt; r){   // 开区间
        int mid = (l + r) &gt;&gt; 1;
        if(a[mid] &gt;= q) r = mid;
        else l = mid;
    }
    return a[r] == q ? r : -1;
}

int main(){
    scanf(&quot;%d %d, &amp;n, &amp;m);
    for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]);
    for(int i = 1; i &lt;= m; i++) scanf(&quot;%d&quot;, &amp;q), printf(&quot;%d &quot;, find(q));
    return 0;
}</code></pre></div><p id="756852540#ioya35_293">当要查找的值不在左右边界时</p><div class="container"><figure class="image-container"><img class="center image image-size" id="756852540#ioya35_294" alt="binary_search.png" title="binary_search.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/binary_search.png" width="2366" height="1257"><figcaption class="center-text">binary_search.png</figcaption></figure></div><p id="756852540#ioya35_295">当要查找的值在左右边界时</p><div class="container"><figure class="image-container"><img class="center image image-size" id="756852540#ioya35_296" alt="binary_search_.png" title="binary_search_.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/binary_search_.png" width="2331" height="1281"><figcaption class="center-text">binary_search_.png</figcaption></figure></div><p id="756852540#ioya35_297">最大化和最小化查找 最大化即找最大下标 最小化即找最小下标</p><div class="container"><figure class="image-container"><img class="center image image-size" id="756852540#ioya35_298" alt="binary_search__.png" title="binary_search__.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/binary_search__.png" width="1618" height="1273"><figcaption class="center-text">binary_search__.png</figcaption></figure></div></section><section><h3 id="756852540#ioya35_252" data-toc="ioya35_252#Algorithm-Tutorial.md-ioya35_252">模板二</h3><div class="detached code-block" id="756852540#ioya35_299"><pre><code class="language-none">/* 闭区间 */
#include &lt;cstdio&gt;

int n, m, q, a[1000005];

int find(int k){
    int l = 1, r = n;   /* 闭区间 */
    while(l &lt; r){
        int mid = (l + r) &gt;&gt; 1;
        if(a[mid] &gt;= k) r = mid;
        else l = mid + 1; /* *** */
    }
    return a[r] == k ? r : -1;
}

int main(){
    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
    for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]);
    for(int i = 1; i &lt;= m; i++) scanf(&quot;%d&quot;, &amp;q), printf(&quot;%d &quot;, find(q));
    return 0;
}</code></pre></div></section><section><h3 id="756852540#ioya35_253" data-toc="ioya35_253#Algorithm-Tutorial.md-ioya35_253">模板三</h3><div class="detached code-block" id="756852540#ioya35_300"><pre><code class="language-none">#include &lt;cstdio&gt;

int n, m, q, a[1000005];

int find(int k){
    int ans = 0;
    int l = 1, r = n; /* 闭区间 */
    while(l &lt;= r){  // l == r + 1 时结束
        int mid = (l + r) &gt;&gt; 1;
        if(a[mid] &gt;= q) ans = mid, r = mid - 1; /* 利用 ans 记录 mid
        else l = mid + 1;
    }
    return a[ans] == q ? ans : -1;
}

int main(){
    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
    for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]);
    for(int i = 1; i &lt;= m; i++) scanf(&quot;%d&quot;, &amp;q), printf(&quot;%d &quot;, find(q));
    return 0;
}</code></pre></div></section><section><h3 id="756852540#ioya35_254" data-toc="ioya35_254#Algorithm-Tutorial.md-ioya35_254">模板四</h3><div class="detached code-block" id="756852540#ioya35_301"><pre><code class="language-none">/* 算法库实现 */
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

int n, m, q, a[1000005];

int main(){
    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
    for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]);
    for(int i = 1; i &lt;= m; i++){
        scanf(&quot;%d&quot;, &amp;q);
        int ans = lower_bound(a + 1, a + n + 1, q) - a; // 缩小区间
        if(a[ans] == q) printf(&quot;%d &quot;, ans);
        else printf(&quot;-1 &quot;);
    }
    return 0;
}</code></pre></div><p id="756852540#ioya35_302">Luogu P1024 (<a href="https://www.luogu.com.cn/problem/P1024">https://www.luogu.com.cn/problem/P1024</a>) 一元三次方程求解</p></section><section><h3 id="756852540#ioya35_255" data-toc="ioya35_255#Algorithm-Tutorial.md-ioya35_255">题目描述</h3><p id="756852540#ioya35_304">有形如： <span class="emphasis" id="756852540#ioya35_305">ax<span id="756852540#ioya35_307"><sup>3</sup></span> + bx<span id="756852540#ioya35_308"><sup>2</sup></span> + cx + d = 0</span> 这样的一个一元三次方程。给出该方程中各项的系数（<span class="emphasis" id="756852540#ioya35_306">a,b,c,d</span>均为实数）， 并约定该方程存在三个不同的实根（根的范围在 -100 至 100 之间），且根于根之差的绝对值 &ge; 1。要求由小到大依次在同一 行输出这三个实根（根于根之间留有空格），并精确到小数点后2位。</p></section><section><h3 id="756852540#ioya35_256" data-toc="ioya35_256#Algorithm-Tutorial.md-ioya35_256">输入格式</h3><p id="756852540#ioya35_309">一行， <span class="emphasis" id="756852540#ioya35_310">4</span>个实数<span class="emphasis" id="756852540#ioya35_311">a,b,c,d</span>。</p></section><section><h3 id="756852540#ioya35_257" data-toc="ioya35_257#Algorithm-Tutorial.md-ioya35_257">输出格式</h3><p id="756852540#ioya35_312">一行， <span class="emphasis" id="756852540#ioya35_313">3</span>个实根，从小到大输出，并精确到小数点后2位。</p></section><section><h3 id="756852540#ioya35_258" data-toc="ioya35_258#Algorithm-Tutorial.md-ioya35_258">样例</h3><div class="detached code-block" id="756852540#ioya35_314"><pre><code class="language-none">输入
1 -5 -4 20</code></pre></div><div class="detached code-block" id="756852540#ioya35_315"><pre><code class="language-none">输出
-2.00 2.00 5.00</code></pre></div><div class="container"><figure class="image-container"><img class="center image image-size" id="756852540#ioya35_316" alt="root1_.png" title="root1_.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/root1_.png" width="2187" height="931"><figcaption class="center-text">root1_.png</figcaption></figure></div><div class="container"><figure class="image-container"><img class="center image image-size" id="756852540#ioya35_317" alt="root2_.png" title="root2_.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/root2_.png" width="2299" height="1162"><figcaption class="center-text">root2_.png</figcaption></figure></div></section><section><h3 id="756852540#ioya35_259" data-toc="ioya35_259#Algorithm-Tutorial.md-ioya35_259">实现</h3><div class="detached code-block" id="756852540#ioya35_318"><pre><code class="language-none">#include &lt;cstdio&gt;

double a, b, c, d;

double fun(double x) { return a * x * x * x + b * x * x + c * x + d; }

double root(double l, double r){
    while(r - l &gt; 0.0001){  // 精度控制
        double mid = (l + r) / 2;
        if(fun(mid) * fun(l) &lt; 0) r = mid;
        else l = mid;
    }
    return r;
}

int main(){
    scanf(&quot;%lf %lf %lf %lf&quot;, &amp;a, &amp;b, &amp;c, &amp;d);
    for(int i = -100; i &lt; 100; i++){
        double y1 = fun(i), y2 = fun(i + 1);
        if(!y1) printf(&quot;%.2lf &quot;, i * 1.0);  // 若 i 本身就是根的情况
        if(y1 * y2 &lt; 0) printf(&quot;%.2lf &quot;, root(i, i + 1));
    }
    return 0;
}</code></pre></div></section></section><section><h2 id="756852540#high-precision" data-toc="high-precision#Algorithm-Tutorial.md-high-precision">High_Precision</h2><section><h3 id="756852540#ioya35_319" data-toc="ioya35_319#Algorithm-Tutorial.md-ioya35_319">高精度加法</h3></section><section><h3 id="756852540#ioya35_320" data-toc="ioya35_320#Algorithm-Tutorial.md-ioya35_320">题目描述</h3><p id="756852540#ioya35_332">高精度加法，相当于 a + b problem, 需用考虑负数</p></section><section><h3 id="756852540#ioya35_321" data-toc="ioya35_321#Algorithm-Tutorial.md-ioya35_321">输入格式</h3><p id="756852540#ioya35_333">分两行输入。 <span class="emphasis" id="756852540#ioya35_334">a, b &le; 100<span id="756852540#ioya35_335"><sup>500</sup></span>。</span></p></section><section><h3 id="756852540#ioya35_322" data-toc="ioya35_322#Algorithm-Tutorial.md-ioya35_322">输出格式</h3><p id="756852540#ioya35_336">输出只有一行，代表 <span class="emphasis" id="756852540#ioya35_340">a + b</span>的值。</p><p id="756852540#ioya35_337">样例</p><div class="detached code-block" id="756852540#ioya35_338"><pre><code class="language-none">输入
1001
9099</code></pre></div><div class="detached code-block" id="756852540#ioya35_339"><pre><code class="language-none">输出
10100</code></pre></div></section><section><h3 id="756852540#ioya35_323" data-toc="ioya35_323#Algorithm-Tutorial.md-ioya35_323">实现一</h3><div class="detached code-block" id="756852540#ioya35_341"><pre><code class="language-none">#include &lt;iostream&gt;
using namespace std;

const int N = 505;
int a[N], b[N], c[N];
int la, lb, lc;

void add(int a[], int b[], int c[]){
    for(int i = 1; i &lt;= lc; i++){
        c[i] += a[i] + b[i];
        c[i + 1] = c[i] / 10;
        c[i] %= 10;
    }
    if(c[lc + 1]) lc++; // 若 a = 900, b = 300, c(lc = 3) = 1300
                        // 此时 lc = 3，故需要特判 lc 位置的下一位，检测是否还有数字
}

int main(){
    string sa, sb; cin &gt;&gt; sa &gt;&gt; sb;
    la = sa.size(), lb = sb.size(), lc = max(la, lc);
    // 因为读入时 高位在后，所以要逆序读入
    for(int i = 1; i &lt;= la; i++) a[i] = sa[la - i] - '0'; //将 sa 中的数字逆序存入 a 中
    for(int i = 1; i &lt;= lb; i++) b[i] = sb[lb - i] - '0'; //同理
    add(a, b, c);
    for(int i = lc; i; i--) printf(&quot;%d&quot;, c[i]); //逆序输出     
    return 0;
}</code></pre></div></section><section><h3 id="756852540#ioya35_324" data-toc="ioya35_324#Algorithm-Tutorial.md-ioya35_324">实现二</h3><div class="detached code-block" id="756852540#ioya35_342"><pre><code class="language-none">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

typedef vector&lt;int&gt; VI;
VI a, b, c;
int la, lb, lc;

void add(VI&amp; a, VI&amp; b, VI&amp; c){
    int t = 0;
    for(int i = 0; i &lt; lc; i++){
        if(i &lt; la) t += a[i];
        if(i &lt; lb) t += b[i];
        c.push_back(t % 10);
        t /= 10;
    }
    if(t) c.push_back(t);   
}

int main(){
    string sa, sb; cin &gt;&gt; sa &gt;&gt; sb;
    la = sa.size(), lb = sb.size(), lc = max(la, lb);
    for(int i = la - 1; ~i; i--) a.push_back(sa[i] - '0');
    for(int i = lb - 1; ~i; i--) b.push_back(sb[i] - '0');
    add(a, b, c);
    for(int i = c.size() - 1; ~i; i--) printf(&quot;%d&quot;, c[i]);    
    return 0;
}</code></pre></div></section><section><h3 id="756852540#ioya35_325" data-toc="ioya35_325#Algorithm-Tutorial.md-ioya35_325">高精度减法</h3></section><section><h3 id="756852540#ioya35_326" data-toc="ioya35_326#Algorithm-Tutorial.md-ioya35_326">题目描述</h3><p id="756852540#ioya35_343">高精度减法</p></section><section><h3 id="756852540#ioya35_327" data-toc="ioya35_327#Algorithm-Tutorial.md-ioya35_327">输入格式</h3><p id="756852540#ioya35_344">两个整数 <span class="emphasis" id="756852540#ioya35_345">a, b</span> （第二个可能比第一个大）</p></section><section><h3 id="756852540#ioya35_328" data-toc="ioya35_328#Algorithm-Tutorial.md-ioya35_328">输出格式</h3><p id="756852540#ioya35_346">结果（是负数要输出负号）</p></section><section><h3 id="756852540#ioya35_329" data-toc="ioya35_329#Algorithm-Tutorial.md-ioya35_329">样例</h3><div class="detached code-block" id="756852540#ioya35_347"><pre><code class="language-none">输入
2
1</code></pre></div><div class="detached code-block" id="756852540#ioya35_348"><pre><code class="language-none">输出
1</code></pre></div></section><section><h3 id="756852540#ioya35_330" data-toc="ioya35_330#Algorithm-Tutorial.md-ioya35_330">实现一</h3><div class="detached code-block" id="756852540#ioya35_349"><pre><code class="language-none">#include &lt;iostream&gt;
using namespace std;

const int N = 100050;
int a[N], b[N], c[N];
int la, lb, lc;

bool cmp(int a[], int b[]){
    if(la != lb) return la &lt; lb;
    for(int i = la; i; i--) if(a[i] &lt; b[i]) return a[i] &lt; b[i];
    return false;
}

void sub(int a[], int b[], int c[]){
    for(int i = 1; i &lt;= lc; i++){
        if(a[i] &lt; b[i]) a[i + 1]--, a[i] += 10;
        c[i] = a[i] + b[i];
    }
    while(c[lc] == 0 &amp;&amp; lc &gt; 1) lc--;
}

int main(){
    string sa, sb; cin &gt;&gt; sa &gt;&gt; sb;
    for(int i = 1; i &lt; la; i++) a[i] = sa[la - i] - '0';
    for(int i = 1; i &lt; lb; i++) b[i] = sb[lb - i] - '0';
    if(cmp(a, b) cout &lt;&lt; &quot;-&quot;;
    sub(a, b, c);
    for(int i = lc; i; i--) printf(&quot;%d&quot;, c[i]);
    
    return 0;
}</code></pre></div></section><section><h3 id="756852540#ioya35_331" data-toc="ioya35_331#Algorithm-Tutorial.md-ioya35_331">实现二</h3><div class="detached code-block" id="756852540#ioya35_350"><pre><code class="language-none">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

typedef vector&lt;int&gt; VI;
VI a, b, c;

bool cmp(VI a, VI b){
    if(a.size() != b.size()) return a.size() &lt; b.size();
    for(int i = a.size(); ~i; i--) if(a[i] != b[i]) return a[i] &lt; b[i];
    return false;
}

void sub(VI a, VI b, VI&amp; c){
    int t = 0;
    for(int i = 0; i &lt; a.size(); i++){
        t = a[i];
        if(i &lt; b.size()) t -= b[i];
        if(t &lt; 0) a[i + 1]--, t += 10;
        c.push_back(t);
    }
    while(c.size() &gt; 1 &amp;&amp; !c.back()) c.size()--;
}

int main(){
    string sa, sb; cin &gt;&gt; sa &gt;&gt; sb;
    for(int i = sa.size() - 1; ~i; i--) a.push_back(sa[i] - '0');
    for(int i = sb.size() - 1; ~i; i--) b.push_back(sb[i] - '0');
    if(cmp(a, b)) swap(a, b), cout &lt;&lt; '-'&quot;;
    sub(a, b, c);
    for(int i = c.size() - 1; ~i; i--) printf(&quot;%d&quot;, c[i]);
    return 0;
}</code></pre></div></section></section><section><h2 id="756852540#prefix-sum-difference" data-toc="prefix-sum-difference#Algorithm-Tutorial.md-prefix-sum-difference">Prefix_Sum &amp; Difference</h2></section><section><h2 id="756852540#dual-pointers" data-toc="dual-pointers#Algorithm-Tutorial.md-dual-pointers">Dual_Pointers</h2></section><section><h2 id="756852540#bit-operation" data-toc="bit-operation#Algorithm-Tutorial.md-bit-operation">Bit_Operation</h2></section><section><h2 id="756852540#discretization" data-toc="discretization#Algorithm-Tutorial.md-discretization">Discretization</h2></section><section><h2 id="756852540#merge-parts" data-toc="merge-parts#Algorithm-Tutorial.md-merge-parts">Merge_Parts</h2><section><h3 id="756852540#edited-by-ppqwqqq" data-toc="edited-by-ppqwqqq#Algorithm-Tutorial.md-edited-by-ppqwqqq">Edited by ppQwQqq</h3></section></section></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="79725369">Topic title</h1><p id="79725369#dmr3hw_3">为了在MySQL中进行相应的实验，我们需要将每个实验的内容从SQL Server转换为MySQL。以下是详细的替代实验步骤和内容：</p><section><h2 id="79725369#mysql_1" data-toc="mysql_1#Git-Tutorial.md-mysql_1">实验一 MySQL的安装及管理工具的使用</h2><section><h3 id="79725369#dmr3hw_11" data-toc="dmr3hw_11#Git-Tutorial.md-dmr3hw_11">实验要求与目的</h3><ol class="list list-decimal" id="79725369#dmr3hw_13" type="1" start="1"><li class="list-item" id="79725369#dmr3hw_14"><p>了解MySQL安装对软、硬件的要求，掌握安装方法。</p></li><li class="list-item" id="79725369#dmr3hw_15"><p>了解MySQL的配置方法。</p></li><li class="list-item" id="79725369#dmr3hw_16"><p>了解MySQL包含的主要组件及其功能。</p></li><li class="list-item" id="79725369#dmr3hw_17"><p>熟悉MySQL管理平台的界面及基本使用方法。</p></li><li class="list-item" id="79725369#dmr3hw_18"><p>了解在MySQL管理平台中执行SQL语句的方法。</p></li></ol></section><section><h3 id="79725369#dmr3hw_12" data-toc="dmr3hw_12#Git-Tutorial.md-dmr3hw_12">实验步骤</h3><ol class="list list-decimal" id="79725369#dmr3hw_19" type="1" start="1"><li class="list-item" id="79725369#dmr3hw_20"><p id="79725369#dmr3hw_25"><span class="control" id="79725369#dmr3hw_27">安装MySQL</span></p><ul class="list" id="79725369#dmr3hw_26" start="1"><li class="list-item" id="79725369#dmr3hw_28"><p>下载MySQL Community Server安装包并进行安装。</p></li><li class="list-item" id="79725369#dmr3hw_29"><p>安装过程中，注意选择需要的组件，如MySQL Server、MySQL Workbench等。</p></li></ul></li><li class="list-item" id="79725369#dmr3hw_21"><p id="79725369#dmr3hw_30"><span class="control" id="79725369#dmr3hw_32">配置MySQL</span></p><ul class="list" id="79725369#dmr3hw_31" start="1"><li class="list-item" id="79725369#dmr3hw_33"><p>使用<span class="inline-code" id="79725369#dmr3hw_35">mysql_secure_installation</span>进行初始配置。</p></li><li class="list-item" id="79725369#dmr3hw_34"><p>配置<span class="inline-code" id="79725369#dmr3hw_36">my.cnf</span>文件以满足特定需求（如端口、字符集等）。</p></li></ul></li><li class="list-item" id="79725369#dmr3hw_22"><p id="79725369#dmr3hw_37"><span class="control" id="79725369#dmr3hw_39">MySQL主要组件</span></p><ul class="list" id="79725369#dmr3hw_38" start="1"><li class="list-item" id="79725369#dmr3hw_40"><p>了解MySQL Server、MySQL Workbench、MySQL Shell等组件及其功能。</p></li></ul></li><li class="list-item" id="79725369#dmr3hw_23"><p id="79725369#dmr3hw_41"><span class="control" id="79725369#dmr3hw_43">MySQL Workbench使用</span></p><ul class="list" id="79725369#dmr3hw_42" start="1"><li class="list-item" id="79725369#dmr3hw_44"><p>打开MySQL Workbench，连接到MySQL服务器。</p></li><li class="list-item" id="79725369#dmr3hw_45"><p>了解Workbench界面的基本布局，如导航面板、SQL编辑器等。</p></li></ul></li><li class="list-item" id="79725369#dmr3hw_24"><p id="79725369#dmr3hw_46"><span class="control" id="79725369#dmr3hw_48">执行SQL语句</span></p><ul class="list" id="79725369#dmr3hw_47" start="1"><li class="list-item" id="79725369#dmr3hw_49"><p id="79725369#dmr3hw_50">在MySQL Workbench的SQL编辑器中输入并执行简单的SQL查询，例如：</p><div class="detached code-block" id="79725369#dmr3hw_51"><pre><code class="language-sql">SELECT VERSION();</code></pre></div></li></ul></li></ol></section></section><section><h2 id="79725369#mysql_2" data-toc="mysql_2#Git-Tutorial.md-mysql_2">实验二 MySQL数据库的管理</h2><section><h3 id="79725369#dmr3hw_52" data-toc="dmr3hw_52#Git-Tutorial.md-dmr3hw_52">实验要求与目的</h3><ol class="list list-decimal" id="79725369#dmr3hw_54" type="1" start="1"><li class="list-item" id="79725369#dmr3hw_55"><p>了解MySQL数据库的逻辑结构和物理结构的特点。</p></li><li class="list-item" id="79725369#dmr3hw_56"><p>掌握使用MySQL Workbench对数据库进行管理的方法。</p></li></ol></section><section><h3 id="79725369#dmr3hw_53" data-toc="dmr3hw_53#Git-Tutorial.md-dmr3hw_53">实验步骤</h3><ol class="list list-decimal" id="79725369#dmr3hw_57" type="1" start="1"><li class="list-item" id="79725369#dmr3hw_58"><p id="79725369#dmr3hw_61"><span class="control" id="79725369#dmr3hw_63">逻辑结构</span></p><ul class="list" id="79725369#dmr3hw_62" start="1"><li class="list-item" id="79725369#dmr3hw_64"><p>了解数据库、表、视图、存储过程等逻辑结构。</p></li></ul></li><li class="list-item" id="79725369#dmr3hw_59"><p id="79725369#dmr3hw_65"><span class="control" id="79725369#dmr3hw_67">物理结构</span></p><ul class="list" id="79725369#dmr3hw_66" start="1"><li class="list-item" id="79725369#dmr3hw_68"><p>了解MySQL的存储引擎（如InnoDB、MyISAM等）的特点。</p></li></ul></li><li class="list-item" id="79725369#dmr3hw_60"><p id="79725369#dmr3hw_69"><span class="control" id="79725369#dmr3hw_71">数据库管理</span></p><ul class="list" id="79725369#dmr3hw_70" start="1"><li class="list-item" id="79725369#dmr3hw_72"><p id="79725369#dmr3hw_73">使用MySQL Workbench创建数据库和表：</p><div class="detached code-block" id="79725369#dmr3hw_74"><pre><code class="language-sql">CREATE DATABASE testdb;
USE testdb;
CREATE TABLE test_table (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(255) NOT NULL
);</code></pre></div></li></ul></li></ol></section></section><section><h2 id="79725369#sql-ddl" data-toc="sql-ddl#Git-Tutorial.md-sql-ddl">实验三 SQL定义语言（DDL）操作</h2><section><h3 id="79725369#dmr3hw_75" data-toc="dmr3hw_75#Git-Tutorial.md-dmr3hw_75">实验要求与目的</h3><ol class="list list-decimal" id="79725369#dmr3hw_77" type="1" start="1"><li class="list-item" id="79725369#dmr3hw_78"><p>熟悉SQL定义语言（DDL）的基本概念和作用。</p></li><li class="list-item" id="79725369#dmr3hw_79"><p>掌握使用SQL DDL语句进行基本表结构的定义、修改、删除的方法。</p></li><li class="list-item" id="79725369#dmr3hw_80"><p>了解常见的数据类型及其在MySQL中的应用。</p></li></ol></section><section><h3 id="79725369#dmr3hw_76" data-toc="dmr3hw_76#Git-Tutorial.md-dmr3hw_76">实验步骤</h3><ol class="list list-decimal" id="79725369#dmr3hw_81" type="1" start="1"><li class="list-item" id="79725369#dmr3hw_82"><p id="79725369#dmr3hw_85"><span class="control" id="79725369#dmr3hw_87">创建表</span></p><div class="detached code-block" id="79725369#dmr3hw_86"><pre><code class="language-sql">CREATE TABLE students (
    student_id INT AUTO_INCREMENT,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    enrollment_date DATE,
    PRIMARY KEY (student_id)
);</code></pre></div></li><li class="list-item" id="79725369#dmr3hw_83"><p id="79725369#dmr3hw_88"><span class="control" id="79725369#dmr3hw_90">修改表</span></p><ul class="list" id="79725369#dmr3hw_89" start="1"><li class="list-item" id="79725369#dmr3hw_91"><p id="79725369#dmr3hw_94">添加列：</p><div class="detached code-block" id="79725369#dmr3hw_95"><pre><code class="language-sql">ALTER TABLE students ADD COLUMN email VARCHAR(100);</code></pre></div></li><li class="list-item" id="79725369#dmr3hw_92"><p id="79725369#dmr3hw_96">删除列：</p><div class="detached code-block" id="79725369#dmr3hw_97"><pre><code class="language-sql">ALTER TABLE students DROP COLUMN email;</code></pre></div></li><li class="list-item" id="79725369#dmr3hw_93"><p id="79725369#dmr3hw_98">修改列数据类型：</p><div class="detached code-block" id="79725369#dmr3hw_99"><pre><code class="language-sql">ALTER TABLE students MODIFY COLUMN first_name VARCHAR(100);</code></pre></div></li></ul></li><li class="list-item" id="79725369#dmr3hw_84"><p id="79725369#dmr3hw_100"><span class="control" id="79725369#dmr3hw_102">删除表</span></p><div class="detached code-block" id="79725369#dmr3hw_101"><pre><code class="language-sql">DROP TABLE students;</code></pre></div></li></ol></section></section><section><h2 id="79725369#mysql" data-toc="mysql#Git-Tutorial.md-mysql">实验四 MySQL数据表的增、删、改操作</h2><section><h3 id="79725369#dmr3hw_103" data-toc="dmr3hw_103#Git-Tutorial.md-dmr3hw_103">实验要求与目的</h3><ol class="list list-decimal" id="79725369#dmr3hw_105" type="1" start="1"><li class="list-item" id="79725369#dmr3hw_106"><p>熟悉MySQL中数据的基本操作，包括插入（INSERT）、修改（UPDATE）、删除（DELETE）。</p></li><li class="list-item" id="79725369#dmr3hw_107"><p>理解MySQL的常用数据类型，并能在实际的数据操作中正确应用。</p></li></ol></section><section><h3 id="79725369#dmr3hw_104" data-toc="dmr3hw_104#Git-Tutorial.md-dmr3hw_104">实验步骤</h3><ol class="list list-decimal" id="79725369#dmr3hw_108" type="1" start="1"><li class="list-item" id="79725369#dmr3hw_109"><p id="79725369#dmr3hw_112"><span class="control" id="79725369#dmr3hw_114">插入数据</span></p><div class="detached code-block" id="79725369#dmr3hw_113"><pre><code class="language-sql">INSERT INTO students (first_name, last_name, enrollment_date)
VALUES ('John', 'Doe', '2023-01-01');</code></pre></div></li><li class="list-item" id="79725369#dmr3hw_110"><p id="79725369#dmr3hw_115"><span class="control" id="79725369#dmr3hw_117">修改数据</span></p><div class="detached code-block" id="79725369#dmr3hw_116"><pre><code class="language-sql">UPDATE students
SET last_name = 'Smith'
WHERE student_id = 1;</code></pre></div></li><li class="list-item" id="79725369#dmr3hw_111"><p id="79725369#dmr3hw_118"><span class="control" id="79725369#dmr3hw_120">删除数据</span></p><div class="detached code-block" id="79725369#dmr3hw_119"><pre><code class="language-sql">DELETE FROM students
WHERE student_id = 1;</code></pre></div></li></ol></section></section><section><h2 id="79725369#sql_1" data-toc="sql_1#Git-Tutorial.md-sql_1">实验五 使用SQL语言进行简单查询</h2><section><h3 id="79725369#dmr3hw_121" data-toc="dmr3hw_121#Git-Tutorial.md-dmr3hw_121">实验要求与目的</h3><ol class="list list-decimal" id="79725369#dmr3hw_123" type="1" start="1"><li class="list-item" id="79725369#dmr3hw_124"><p>熟练掌握SQL的SELECT语句，包括投影、选择、排序、分组等操作。</p></li><li class="list-item" id="79725369#dmr3hw_125"><p>熟练使用SQL的比较运算符、逻辑运算符、字符匹配运算符、算术运算符等。</p></li><li class="list-item" id="79725369#dmr3hw_126"><p>利用分组函数进行数据的汇总和统计。</p></li></ol></section><section><h3 id="79725369#dmr3hw_122" data-toc="dmr3hw_122#Git-Tutorial.md-dmr3hw_122">实验步骤</h3><ol class="list list-decimal" id="79725369#dmr3hw_127" type="1" start="1"><li class="list-item" id="79725369#dmr3hw_128"><p id="79725369#dmr3hw_132"><span class="control" id="79725369#dmr3hw_134">简单查询</span></p><div class="detached code-block" id="79725369#dmr3hw_133"><pre><code class="language-sql">SELECT first_name, last_name FROM students;</code></pre></div></li><li class="list-item" id="79725369#dmr3hw_129"><p id="79725369#dmr3hw_135"><span class="control" id="79725369#dmr3hw_137">使用WHERE子句</span></p><div class="detached code-block" id="79725369#dmr3hw_136"><pre><code class="language-sql">SELECT * FROM students WHERE enrollment_date &gt; '2023-01-01';</code></pre></div></li><li class="list-item" id="79725369#dmr3hw_130"><p id="79725369#dmr3hw_138"><span class="control" id="79725369#dmr3hw_140">排序</span></p><div class="detached code-block" id="79725369#dmr3hw_139"><pre><code class="language-sql">SELECT * FROM students ORDER BY last_name ASC;</code></pre></div></li><li class="list-item" id="79725369#dmr3hw_131"><p id="79725369#dmr3hw_141"><span class="control" id="79725369#dmr3hw_143">分组和聚合函数</span></p><div class="detached code-block" id="79725369#dmr3hw_142"><pre><code class="language-sql">SELECT COUNT(*), AVG(student_id) FROM students;</code></pre></div></li></ol></section></section><section><h2 id="79725369#sql" data-toc="sql#Git-Tutorial.md-sql">实验六 使用SQL语言进行复杂查询</h2><section><h3 id="79725369#dmr3hw_144" data-toc="dmr3hw_144#Git-Tutorial.md-dmr3hw_144">实验要求与目的</h3><ol class="list list-decimal" id="79725369#dmr3hw_146" type="1" start="1"><li class="list-item" id="79725369#dmr3hw_147"><p>熟练掌握SQL的连接查询和嵌套查询的语法和用法。</p></li><li class="list-item" id="79725369#dmr3hw_148"><p>理解并应用连接条件和子查询的逻辑，确保查询结果的准确性和完整性。</p></li></ol></section><section><h3 id="79725369#dmr3hw_145" data-toc="dmr3hw_145#Git-Tutorial.md-dmr3hw_145">实验步骤</h3><ol class="list list-decimal" id="79725369#dmr3hw_149" type="1" start="1"><li class="list-item" id="79725369#dmr3hw_150"><p id="79725369#dmr3hw_152"><span class="control" id="79725369#dmr3hw_154">连接查询</span></p><div class="detached code-block" id="79725369#dmr3hw_153"><pre><code class="language-sql">SELECT a.first_name, b.course_name
FROM students a
INNER JOIN courses b ON a.student_id = b.student_id;</code></pre></div></li><li class="list-item" id="79725369#dmr3hw_151"><p id="79725369#dmr3hw_155"><span class="control" id="79725369#dmr3hw_157">嵌套查询</span></p><div class="detached code-block" id="79725369#dmr3hw_156"><pre><code class="language-sql">SELECT first_name, last_name
FROM students
WHERE student_id IN (SELECT student_id FROM courses WHERE course_name = 'Math');</code></pre></div></li></ol></section></section><section><h2 id="79725369#dmr3hw_10" data-toc="dmr3hw_10#Git-Tutorial.md-dmr3hw_10">实验七 索引的创建与管理</h2><section><h3 id="79725369#dmr3hw_158" data-toc="dmr3hw_158#Git-Tutorial.md-dmr3hw_158">实验要求与目的</h3><ol class="list list-decimal" id="79725369#dmr3hw_160" type="1" start="1"><li class="list-item" id="79725369#dmr3hw_161"><p>掌握在MySQL中创建、修改和删除索引的方法。</p></li><li class="list-item" id="79725369#dmr3hw_162"><p>了解主键、外键和唯一约束的概念和作用。</p></li><li class="list-item" id="79725369#dmr3hw_163"><p>学会在MySQL中创建、修改和删除主键、外键和唯一约束。</p></li><li class="list-item" id="79725369#dmr3hw_164"><p>理解这些数据库对象如何影响数据的完整性和查询性能。</p></li></ol></section><section><h3 id="79725369#dmr3hw_159" data-toc="dmr3hw_159#Git-Tutorial.md-dmr3hw_159">实验步骤</h3><ol class="list list-decimal" id="79725369#dmr3hw_165" type="1" start="1"><li class="list-item" id="79725369#dmr3hw_167"><p id="79725369#dmr3hw_170"><span class="control" id="79725369#dmr3hw_172">创建索引</span></p><div class="detached code-block" id="79725369#dmr3hw_171"><pre><code class="language-sql">CREATE INDEX idx_lastname ON students (last_name);</code></pre></div></li><li class="list-item" id="79725369#dmr3hw_168"><p id="79725369#dmr3hw_173"><span class="control" id="79725369#dmr3hw_175">删除索引</span></p><div class="detached code-block" id="79725369#dmr3hw_174"><pre><code class="language-sql">DROP INDEX idx_lastname ON students;</code></pre></div></li><li class="list-item" id="79725369#dmr3hw_169"><p id="79725369#dmr3hw_176"><span class="control" id="79725369#dmr3hw_178">主键、外键和唯一约束</span></p><ul class="list" id="79725369#dmr3hw_177" start="1"><li class="list-item" id="79725369#dmr3hw_179"><p id="79725369#dmr3hw_182">创建主键：</p><div class="detached code-block" id="79725369#dmr3hw_183"><pre><code class="language-sql">ALTER TABLE students ADD PRIMARY KEY (student_id);</code></pre></div></li><li class="list-item" id="79725369#dmr3hw_180"><p id="79725369#dmr3hw_184">创建外键：</p><div class="detached code-block" id="79725369#dmr3hw_185"><pre><code class="language-sql">ALTER TABLE courses ADD CONSTRAINT fk_student
FOREIGN KEY (student_id) REFERENCES students(student_id);</code></pre></div></li><li class="list-item" id="79725369#dmr3hw_181"><p id="79725369#dmr3hw_186">创建唯一约束：</p><div class="detached code-block" id="79725369#dmr3hw_187"><pre><code class="language-sql">ALTER TABLE students ADD CONSTRAINT unique_email UNIQUE (email);</code></pre></div></li></ul></li></ol><p id="79725369#dmr3hw_166">以上是将SQL Server实验内容转换为MySQL实验内容的详细步骤和说明。希望这些内容能帮助你顺利完成实验任务。</p></section></section></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="-1529361291">《TCP/IP详解卷一：协议》</h1><section><h2 id="-1529361291#-28v3h4_3" data-toc="-28v3h4_3#《TCP-IP详解卷一：协议》.md--28v3h4_3">第一章 概述</h2><section><h3 id="-1529361291#-28v3h4_5" data-toc="-28v3h4_5#《TCP-IP详解卷一：协议》.md--28v3h4_5">分层</h3><div class="table-wrapper detached"><table id="-1529361291#-28v3h4_15"><tr class="header-row" id="-1529361291#-28v3h4_30"><th id="-1529361291#-28v3h4_35"><p>层次</p></th><th id="-1529361291#-28v3h4_36"><p>功能</p></th></tr><tr class="" id="-1529361291#-28v3h4_31"><td id="-1529361291#-28v3h4_37"><p>应用层</p></td><td id="-1529361291#-28v3h4_38"><p>Telnet、FTP和e-mail</p></td></tr><tr class="" id="-1529361291#-28v3h4_32"><td id="-1529361291#-28v3h4_39"><p>运输层</p></td><td id="-1529361291#-28v3h4_40"><p>TCP和UDP</p></td></tr><tr class="" id="-1529361291#-28v3h4_33"><td id="-1529361291#-28v3h4_41"><p>网络层</p></td><td id="-1529361291#-28v3h4_42"><p>IP、ICMP和IGMP</p></td></tr><tr class="" id="-1529361291#-28v3h4_34"><td id="-1529361291#-28v3h4_43"><p>链路层</p></td><td id="-1529361291#-28v3h4_44"><p>设备驱动程序及接口卡</p></td></tr></table></div><ol class="list list-decimal" id="-1529361291#-28v3h4_16" type="1" start="1"><li class="list-item" id="-1529361291#-28v3h4_45"><p>链路层：一般指设备驱动程序及接口卡，处理一些物理传输媒介的细节。</p></li><li class="list-item" id="-1529361291#-28v3h4_46"><p>网络层：一般用于处理分组在网络中的活动。</p></li><li class="list-item" id="-1529361291#-28v3h4_47"><p>运输层：一般用于两台主机上应用程序间的<span class="control" id="-1529361291#-28v3h4_48">端到端</span>的通信。</p></li></ol><div class="table-wrapper detached"><table id="-1529361291#-28v3h4_17"><tr class="header-row" id="-1529361291#-28v3h4_49"><th id="-1529361291#-28v3h4_52"><p>协议</p></th><th id="-1529361291#-28v3h4_53"><p>特点</p></th><th id="-1529361291#-28v3h4_54"><p>处理方式</p></th></tr><tr class="" id="-1529361291#-28v3h4_50"><td id="-1529361291#-28v3h4_55"><p>TCP</p></td><td id="-1529361291#-28v3h4_56"><p>可靠性高</p></td><td id="-1529361291#-28v3h4_57"><p>数据分组-&gt;发送到网络层-&gt;确认收到-&gt;再进行相关的时钟设置等-&gt;发送到下一层</p></td></tr><tr class="" id="-1529361291#-28v3h4_51"><td id="-1529361291#-28v3h4_58"><p>UDP</p></td><td id="-1529361291#-28v3h4_59"><p>可靠性低</p></td><td id="-1529361291#-28v3h4_60"><p>数据分组-&gt;发送到下一层</p></td></tr></table></div><p id="-1529361291#-28v3h4_18"><span class="control" id="-1529361291#-28v3h4_61">任意的可靠性必须由<span class="emphasis" id="-1529361291#-28v3h4_62">应用层</span>提供</span></p><ol class="list list-decimal" id="-1529361291#-28v3h4_19" type="1" start="4"><li class="list-item" id="-1529361291#-28v3h4_63"><p>应用层： 一般用于处理特定的应用程序细节。</p></li></ol><p id="-1529361291#-28v3h4_20">此处，顶层（应用层）与下三层的不同在于， <span class="control" id="-1529361291#-28v3h4_64">顶层</span>只需要关心<span class="control" id="-1529361291#-28v3h4_65">应用程序</span>的细节， <span class="control" id="-1529361291#-28v3h4_66">下三层</span>处理<span class="control" id="-1529361291#-28v3h4_67">通信细节</span>。</p><p id="-1529361291#-28v3h4_21">局域网上运行FTP的两台主机</p><div class="container"><figure class="image-container"><img class="center image image-size" id="-1529361291#-28v3h4_22" alt="image.png" title="image.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/image.png" width="534" height="301"><figcaption class="center-text">image.png</figcaption></figure></div><p id="-1529361291#-28v3h4_23">服务模式：Client - Server: Client - <span id="-1529361291#-28v3h4_68"><sup>请求</sup></span>-&gt; Server, Server - <span id="-1529361291#-28v3h4_69"><sup>响应</sup></span>-&gt; Client</p><div class="table-wrapper detached"><table id="-1529361291#-28v3h4_24"><tr class="header-row" id="-1529361291#-28v3h4_70"><th id="-1529361291#-28v3h4_75"><p>协议</p></th><th id="-1529361291#-28v3h4_76"><p>层次</p></th></tr><tr class="" id="-1529361291#-28v3h4_71"><td id="-1529361291#-28v3h4_77"><p>FTP</p></td><td id="-1529361291#-28v3h4_78"><p>应用层</p></td></tr><tr class="" id="-1529361291#-28v3h4_72"><td id="-1529361291#-28v3h4_79"><p>TCP</p></td><td id="-1529361291#-28v3h4_80"><p>运输层</p></td></tr><tr class="" id="-1529361291#-28v3h4_73"><td id="-1529361291#-28v3h4_81"><p>IP</p></td><td id="-1529361291#-28v3h4_82"><p>网络层</p></td></tr><tr class="" id="-1529361291#-28v3h4_74"><td id="-1529361291#-28v3h4_83"><p>以太网协议</p></td><td id="-1529361291#-28v3h4_84"><p>链路层</p></td></tr></table></div><p id="-1529361291#-28v3h4_25"><span class="control" id="-1529361291#-28v3h4_85">TCP/IP</span>为一个<span class="emphasis" id="-1529361291#-28v3h4_86">协议族</span> (Internet Protocol Suite)</p><div class="table-wrapper detached"><table id="-1529361291#-28v3h4_26"><tr class="header-row" id="-1529361291#-28v3h4_87"><th id="-1529361291#-28v3h4_90"><p>链接互联网的方法</p></th><th id="-1529361291#-28v3h4_91"><p>层次</p></th></tr><tr class="" id="-1529361291#-28v3h4_88"><td id="-1529361291#-28v3h4_92"><p>路由器(最简单)</p></td><td id="-1529361291#-28v3h4_93"><p>网路层</p></td></tr><tr class="" id="-1529361291#-28v3h4_89"><td id="-1529361291#-28v3h4_94"><p>网桥</p></td><td id="-1529361291#-28v3h4_95"><p>链路层</p></td></tr></table></div><div class="container"><figure class="image-container"><img class="center image image-size" id="-1529361291#-28v3h4_27" alt="image_1.png" title="image_1.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/image_1.png" width="442" height="311"><figcaption class="center-text">image_1.png</figcaption></figure></div><p id="-1529361291#-28v3h4_28">通过路由器(Router)连接的两个网络</p><p id="-1529361291#-28v3h4_29"><span class="control" id="-1529361291#-28v3h4_96">在TCP/IP协议族中，网络层IP提供的是一种不可靠的服务。</span></p></section><section><h3 id="-1529361291#tcp-ip" data-toc="tcp-ip#《TCP-IP详解卷一：协议》.md-tcp-ip">TCP/IP的分层</h3><div class="container"><figure class="image-container"><img class="center image image-size" id="-1529361291#-28v3h4_97" alt="image_2.png" title="image_2.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/image_2.png" width="422" height="435"><figcaption class="center-text">image_2.png</figcaption></figure></div><p id="-1529361291#-28v3h4_98">TCP/IP协议族中不同层次的协议</p><p id="-1529361291#-28v3h4_99">虽然<span class="control" id="-1529361291#-28v3h4_105">TCP</span>使用不可靠的IP服务，但是它却提供一种可靠的运输层服务。</p><p id="-1529361291#-28v3h4_100"><span class="control" id="-1529361291#-28v3h4_106">UDP</span>为应用程序发送和接收数据报。</p><p id="-1529361291#-28v3h4_101"><span class="control" id="-1529361291#-28v3h4_107">IP</span>是网络层上的主要协议，同时被TCP和UDP使用， <span class="control" id="-1529361291#-28v3h4_108">TCP</span>和<span class="control" id="-1529361291#-28v3h4_109">UDP</span>的每组数据都通过端系统和每个中间路由器中的<span class="control" id="-1529361291#-28v3h4_110">IP</span>层在互联网中进行传输</p><p id="-1529361291#-28v3h4_102"><span class="control" id="-1529361291#-28v3h4_111">ICMP</span>是<span class="control" id="-1529361291#-28v3h4_112">IP</span>协议的附属协议， <span class="control" id="-1529361291#-28v3h4_113">IP</span>层用它来与其他主机或路由器交换错误报文和其他重要信息。</p><p id="-1529361291#-28v3h4_103"><span class="control" id="-1529361291#-28v3h4_114">IGMP</span>是Internet组管理协议，它用来把一个<span class="control" id="-1529361291#-28v3h4_115">UDP</span>数据报多播到多个主机。</p><p id="-1529361291#-28v3h4_104"><span class="control" id="-1529361291#-28v3h4_116">ARP</span> (地址解析协议)和<span class="control" id="-1529361291#-28v3h4_117">RARP</span> (逆地址解析协议)是某些网络接口使用的特殊协议，用来转换<span class="control" id="-1529361291#-28v3h4_118">IP</span>层和网络接口层的地址。</p></section><section><h3 id="-1529361291#-28v3h4_7" data-toc="-28v3h4_7#《TCP-IP详解卷一：协议》.md--28v3h4_7">互联网的地址</h3><p id="-1529361291#-28v3h4_119">互联网上的每个接口必须有一个唯一的Internet地址（也称作IP地址，其长度为32bit）。</p><p id="-1529361291#-28v3h4_120">IP地址的结构</p><div class="container"><figure class="image-container"><img class="center image image-size" id="-1529361291#-28v3h4_121" alt="image_3.png" title="image_3.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/image_3.png" width="405" height="231"><figcaption class="center-text">image_3.png</figcaption></figure></div><div class="table-wrapper detached"><table id="-1529361291#-28v3h4_122"><tr class="header-row" id="-1529361291#-28v3h4_126"><th id="-1529361291#-28v3h4_133"><p>类型</p></th><th id="-1529361291#-28v3h4_134"><p>范围</p></th></tr><tr class="" id="-1529361291#-28v3h4_127"><td id="-1529361291#-28v3h4_135"><p>A</p></td><td id="-1529361291#-28v3h4_136"><p><span class="control" id="-1529361291#-28v3h4_137">0</span> .0.0.0 到 <span class="control" id="-1529361291#-28v3h4_138">127</span> .255.255.255</p></td></tr><tr class="" id="-1529361291#-28v3h4_128"><td id="-1529361291#-28v3h4_139"><p>B</p></td><td id="-1529361291#-28v3h4_140"><p><span class="control" id="-1529361291#-28v3h4_141">128</span> .0.0.0 到 <span class="control" id="-1529361291#-28v3h4_142">191</span> .255.255.255</p></td></tr><tr class="" id="-1529361291#-28v3h4_129"><td id="-1529361291#-28v3h4_143"><p>C</p></td><td id="-1529361291#-28v3h4_144"><p><span class="control" id="-1529361291#-28v3h4_145">192</span> .0.0.0 到 <span class="control" id="-1529361291#-28v3h4_146">223</span> .255.255.255</p></td></tr><tr class="" id="-1529361291#-28v3h4_130"><td id="-1529361291#-28v3h4_147"><p>D</p></td><td id="-1529361291#-28v3h4_148"><p><span class="control" id="-1529361291#-28v3h4_149">224</span> .0.0.0 到 <span class="control" id="-1529361291#-28v3h4_150">239</span> .255.255.255</p></td></tr><tr class="" id="-1529361291#-28v3h4_131"><td id="-1529361291#-28v3h4_151"><p>E</p></td><td id="-1529361291#-28v3h4_152"><p><span class="control" id="-1529361291#-28v3h4_153">240</span> .0.0.0 到 <span class="control" id="-1529361291#-28v3h4_154">247</span> .255.255.255</p></td></tr><tr class="" id="-1529361291#-28v3h4_132"><td id="-1529361291#-28v3h4_155"><p>结论</p></td><td id="-1529361291#-28v3h4_156"><p>可以通过观察这些地址的<span class="control" id="-1529361291#-28v3h4_157">第一个十进制整数</span>来区分各个类型的地址</p></td></tr></table></div><p id="-1529361291#-28v3h4_123">这些32位的地址通常写成四个十进制的数，其中每个整数对应一个字节&mdash;&mdash;<span class="control" id="-1529361291#-28v3h4_158">点分十进制表示法(Dotted decimal notation)</span></p><p id="-1529361291#-28v3h4_124">重点：多接口主机具有多个IP地址，其中<span class="control" id="-1529361291#-28v3h4_159">每个接口都对应一个IP地址</span>。</p><div class="table-wrapper detached"><table id="-1529361291#-28v3h4_125"><tr class="header-row" id="-1529361291#-28v3h4_160"><th id="-1529361291#-28v3h4_164"><p>IP地址类型</p></th><th id="-1529361291#-28v3h4_165"><p>目的端</p></th></tr><tr class="" id="-1529361291#-28v3h4_161"><td id="-1529361291#-28v3h4_166"><p>单播地址</p></td><td id="-1529361291#-28v3h4_167"><p>单个主机</p></td></tr><tr class="" id="-1529361291#-28v3h4_162"><td id="-1529361291#-28v3h4_168"><p>广播地址</p></td><td id="-1529361291#-28v3h4_169"><p>目标网络上的所有主机</p></td></tr><tr class="" id="-1529361291#-28v3h4_163"><td id="-1529361291#-28v3h4_170"><p>多播地址</p></td><td id="-1529361291#-28v3h4_171"><p>同一组内的所有主机</p></td></tr></table></div></section><section><h3 id="-1529361291#-28v3h4_8" data-toc="-28v3h4_8#《TCP-IP详解卷一：协议》.md--28v3h4_8">域名系统</h3><p id="-1529361291#-28v3h4_172">在<span class="emphasis" id="-1529361291#-28v3h4_173">TCP/IP</span>领域中， <span class="control" id="-1529361291#-28v3h4_174">域名系统(DNS)是一个分布的数据库</span> ，由它来提供<span class="control" id="-1529361291#-28v3h4_175">IP地址</span>和<span class="control" id="-1529361291#-28v3h4_176">主机名</span>之间的<span class="control" id="-1529361291#-28v3h4_177">映射</span>信息。</p></section><section><h3 id="-1529361291#-28v3h4_9" data-toc="-28v3h4_9#《TCP-IP详解卷一：协议》.md--28v3h4_9">封装</h3><p id="-1529361291#-28v3h4_178">当应用程序用<span class="control" id="-1529361291#-28v3h4_189">TCP</span>传送数据时，数据被送入<span class="control" id="-1529361291#-28v3h4_190">协议栈</span>中，然后逐个通过每一层直到被当作一串比特流送入网络。</p><div class="container"><figure class="image-container"><img class="center image image-size" id="-1529361291#-28v3h4_179" alt="image_6.png" title="image_6.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/image_6.png" width="536" height="381"><figcaption class="center-text">image_6.png</figcaption></figure></div><p id="-1529361291#-28v3h4_180">TCP传给IP的数据单元称作TCP报文段（TCP段，TCP segment)。</p><p id="-1529361291#-28v3h4_181">IP传给网络接口层的数据单元称作IP数据报（IP datagram）。</p><p id="-1529361291#-28v3h4_182">通过以太网传输的比特流叫做帧（Frame）。</p><p id="-1529361291#-28v3h4_183">以太网数据帧的<span class="control" id="-1529361291#-28v3h4_191">物理特性</span>是其长度必须在<span class="control" id="-1529361291#-28v3h4_192">46 ~ 1500字节</span>之间。</p><p id="-1529361291#-28v3h4_184">UDP数据与TCP数据基本一致。唯一不同在于UDP传给IP的信息单元称作<span class="control" id="-1529361291#-28v3h4_193">UDP数据报（UDP datagram）</span> ，而且<span class="control" id="-1529361291#-28v3h4_194">UDP的首部长为8字节</span>。</p><p id="-1529361291#-28v3h4_185">由于TCP、UDP、ICMP、IGMP都要向IP传送数据，因此IP必须在生成的IP首部中加入<span class="control" id="-1529361291#-28v3h4_195">某种标识</span> ，用于表明数据<span class="control" id="-1529361291#-28v3h4_196">属于哪一层</span>。 为此，IP在首部中存入一个长度为<span class="control" id="-1529361291#-28v3h4_197">8bit</span>的数值，称作<span class="control" id="-1529361291#-28v3h4_198">协议域</span>。</p><div class="table-wrapper detached"><table id="-1529361291#-28v3h4_186"><tr class="header-row" id="-1529361291#-28v3h4_199"><th id="-1529361291#-28v3h4_204"><p>bit值</p></th><th id="-1529361291#-28v3h4_205"><p>协议</p></th></tr><tr class="" id="-1529361291#-28v3h4_200"><td id="-1529361291#-28v3h4_206"><p>1</p></td><td id="-1529361291#-28v3h4_207"><p>ICMP协议</p></td></tr><tr class="" id="-1529361291#-28v3h4_201"><td id="-1529361291#-28v3h4_208"><p>2</p></td><td id="-1529361291#-28v3h4_209"><p>IGMP协议</p></td></tr><tr class="" id="-1529361291#-28v3h4_202"><td id="-1529361291#-28v3h4_210"><p>6</p></td><td id="-1529361291#-28v3h4_211"><p>TCP协议</p></td></tr><tr class="" id="-1529361291#-28v3h4_203"><td id="-1529361291#-28v3h4_212"><p>17</p></td><td id="-1529361291#-28v3h4_213"><p>UDP协议</p></td></tr></table></div><p id="-1529361291#-28v3h4_187">类似地，许多应用程序在使用TCP或UDP来传送数据时，运输层协议在生成报文首部时要存入一个应用程序的标识符。 TCP和UDP都用一个16bit的端口号来表示不同的应用程序。TCP和UDP把源端口号和目的端口号分别存入报文首部中。</p><p id="-1529361291#-28v3h4_188">网络接口在发送和接收IP、ARP和RARP数据时，也必须在以太网的帧首部加入某种形式的标识，以指明生成数据的网络层协议。因此，以太网的帧首部也有一个16bit的帧类型域。</p></section><section><h3 id="-1529361291#-28v3h4_10" data-toc="-28v3h4_10#《TCP-IP详解卷一：协议》.md--28v3h4_10">分用</h3><p id="-1529361291#-28v3h4_214">当目标主机收到一个以太网数据帧时，数据就开始从协议栈中有底向上升，同时去掉各层协议加上的报文首部。</p><p id="-1529361291#-28v3h4_215">每层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议。</p><div class="container"><figure class="image-container"><img class="center image image-size" id="-1529361291#-28v3h4_216" alt="image_7.png" title="image_7.png" src="C:/Users/28762/WritersideProjects/Tutorial/Writerside/images/image_7.png" width="569" height="352"><figcaption class="center-text">image_7.png</figcaption></figure></div></section><section><h3 id="-1529361291#-28v3h4_11" data-toc="-28v3h4_11#《TCP-IP详解卷一：协议》.md--28v3h4_11">客户-服务器模型</h3><p id="-1529361291#-28v3h4_217">模型设计目的：让服务器为客户提供一些<span class="control" id="-1529361291#-28v3h4_219">特定</span>的服务。</p><div class="table-wrapper detached"><table id="-1529361291#-28v3h4_218"><tr class="header-row" id="-1529361291#-28v3h4_220"><th id="-1529361291#-28v3h4_223"><p>服务器类型</p></th><th id="-1529361291#-28v3h4_224"><p>工作流程</p></th><th id="-1529361291#-28v3h4_225"><p>优缺点</p></th></tr><tr class="" id="-1529361291#-28v3h4_221"><td id="-1529361291#-28v3h4_226"><p>重复型 for UDP</p></td><td id="-1529361291#-28v3h4_227"><p>等待request -&gt; 处理request -&gt; 发送response -&gt; 重复上述流程</p></td><td id="-1529361291#-28v3h4_228"><p>缺点：当在服务器处理request时，不能为其他用户提供服务</p></td></tr><tr class="" id="-1529361291#-28v3h4_222"><td id="-1529361291#-28v3h4_229"><p>并发型 for TCP</p></td><td id="-1529361291#-28v3h4_230"><p>等待request -&gt; 启动一个新的服务器处理request（其余操作由操作系统完成） -&gt; 重复上述流程</p></td><td id="-1529361291#-28v3h4_231"><p>优点：可以根据需求生成其他服务其为用户提供服务</p></td></tr></table></div></section><section><h3 id="-1529361291#-28v3h4_12" data-toc="-28v3h4_12#《TCP-IP详解卷一：协议》.md--28v3h4_12">端口号</h3><p id="-1529361291#-28v3h4_232"><span class="control" id="-1529361291#-28v3h4_236">服务器</span>一般都是通过知名<span class="control" id="-1529361291#-28v3h4_237">端口号</span>来识别的。</p><div class="table-wrapper detached"><table id="-1529361291#-28v3h4_233"><tr class="header-row" id="-1529361291#-28v3h4_238"><th id="-1529361291#-28v3h4_244"><p>名字</p></th><th id="-1529361291#-28v3h4_245"><p>TCP端口号</p></th><th id="-1529361291#-28v3h4_246"><p>UDP端口号</p></th><th id="-1529361291#-28v3h4_247"><p>RFC</p></th><th id="-1529361291#-28v3h4_248"><p>描述</p></th></tr><tr class="" id="-1529361291#-28v3h4_239"><td id="-1529361291#-28v3h4_249"><p>echo</p></td><td id="-1529361291#-28v3h4_250"><p>7</p></td><td id="-1529361291#-28v3h4_251"><p>7</p></td><td id="-1529361291#-28v3h4_252"><p>862</p></td><td id="-1529361291#-28v3h4_253"><p>服务器返回客户发送的所有内容</p></td></tr><tr class="" id="-1529361291#-28v3h4_240"><td id="-1529361291#-28v3h4_254"><p>discard</p></td><td id="-1529361291#-28v3h4_255"><p>9</p></td><td id="-1529361291#-28v3h4_256"><p>9</p></td><td id="-1529361291#-28v3h4_257"><p>863</p></td><td id="-1529361291#-28v3h4_258"><p>服务器丢弃客户发送的所有内容</p></td></tr><tr class="" id="-1529361291#-28v3h4_241"><td id="-1529361291#-28v3h4_259"><p>daytime</p></td><td id="-1529361291#-28v3h4_260"><p>13</p></td><td id="-1529361291#-28v3h4_261"><p>13</p></td><td id="-1529361291#-28v3h4_262"><p>867</p></td><td id="-1529361291#-28v3h4_263"><p>服务器以可读形式返回时间和日期</p></td></tr><tr class="" id="-1529361291#-28v3h4_242"><td id="-1529361291#-28v3h4_264"><p>chargen</p></td><td id="-1529361291#-28v3h4_265"><p>19</p></td><td id="-1529361291#-28v3h4_266"><p>19</p></td><td id="-1529361291#-28v3h4_267"><p>864</p></td><td id="-1529361291#-28v3h4_268"><p>当客户发送一个数据报时，TCP服务器发送一串连续的字符流，直到客户中断连接，UDP服务器发送一个随机长度的数据报</p></td></tr><tr class="" id="-1529361291#-28v3h4_243"><td id="-1529361291#-28v3h4_269"><p>time</p></td><td id="-1529361291#-28v3h4_270"><p>37</p></td><td id="-1529361291#-28v3h4_271"><p>37</p></td><td id="-1529361291#-28v3h4_272"><p>868</p></td><td id="-1529361291#-28v3h4_273"><p>服务器返回一个二进制形式的32bit数，表示从UTC时间1900年1月1日午夜至今的秒数</p></td></tr></table></div><p id="-1529361291#-28v3h4_234">从上表可以看出，当使用TCP和UDP提供相同的服务时，一般选择相同的端口号。</p><p id="-1529361291#-28v3h4_235">注：之所以端口号都是奇数，是因为这些端口号都是从NCP端口号派生出来的（NCP,即网络控制协议，时ARPANET的运输层协议，是TCP的前身）。 NCP是单工的，不是全双工的，因此每个应用程序需要两个连接，需要预留一对奇数和偶数端口号，当TCP和UDP成为标准的运输层协议时。每个应用程序只需要一个端口号，因此就使用了NCP中的奇数。</p></section><section><h3 id="-1529361291#-28v3h4_13" data-toc="-28v3h4_13#《TCP-IP详解卷一：协议》.md--28v3h4_13">互联网</h3><p id="-1529361291#-28v3h4_274"><span class="control" id="-1529361291#-28v3h4_276">internet</span>的意思是用<span class="control" id="-1529361291#-28v3h4_277">一个共同的协议族把多个网络连接在一起</span> 。而<span class="control" id="-1529361291#-28v3h4_278">Internet</span>指的是世界范围内通过TCP/IP互相通信的<span class="control" id="-1529361291#-28v3h4_279">所有主机集合</span>。</p><p id="-1529361291#-28v3h4_275">Internet是一个internet，但internet不等于Internet。</p></section><section><h3 id="-1529361291#-28v3h4_14" data-toc="-28v3h4_14#《TCP-IP详解卷一：协议》.md--28v3h4_14">小结</h3><ol class="list list-decimal" id="-1529361291#-28v3h4_280" type="1" start="1"><li class="list-item" id="-1529361291#-28v3h4_281"><p id="-1529361291#-28v3h4_286">TCP/IP协议族分为四层：链路层、网络层、运输层和应用层，每一层各司其职。</p></li><li class="list-item" id="-1529361291#-28v3h4_282"><p id="-1529361291#-28v3h4_287">在TCP/IP中，网络层和运输层之间的区别是最关键的：网络层（IP）提供点到点的服务，而运输层（TCP和UDP）提供端到端服务。</p></li><li class="list-item" id="-1529361291#-28v3h4_283"><p id="-1529361291#-28v3h4_288">一个互联网是网络的网络。构造互联网共同的基石是路由器，它们在IP层把网络连在一起。</p></li><li class="list-item" id="-1529361291#-28v3h4_284"><p id="-1529361291#-28v3h4_289">在一个互联网上，每个接口都用IP地址来标识，尽管用户习惯使用主机名而不是IP地址。</p></li><li class="list-item" id="-1529361291#-28v3h4_285"><p id="-1529361291#-28v3h4_290">域名系统为主机名和IP地址之间提供动态的映射。端口号用来标识互相通信的应用程序。服务器使用知名端口号，而客户使用特定的端口号。</p></li></ol></section></section><section><h2 id="-1529361291#-28v3h4_4" data-toc="-28v3h4_4#《TCP-IP详解卷一：协议》.md--28v3h4_4">第二章 链路层</h2><p id="-1529361291#-28v3h4_291">链路层主要的三个作用：</p><ol class="list list-decimal" id="-1529361291#-28v3h4_292" type="1" start="1"><li class="list-item" id="-1529361291#-28v3h4_297"><p>为IP模块发送和接受IP数据报</p></li><li class="list-item" id="-1529361291#-28v3h4_298"><p>为ARP模块发送ARP请求和接收ARP应答</p></li><li class="list-item" id="-1529361291#-28v3h4_299"><p>为ARP发送RARP请求和接收RARP应答</p></li></ol><p id="-1529361291#-28v3h4_293">TCP/IP支持多种不同的链路层协议，这取决于网络所使用的硬件。</p><section><h3 id="-1529361291#ieee-802" data-toc="ieee-802#《TCP-IP详解卷一：协议》.md-ieee-802">以太网和IEEE 802封装</h3><p id="-1529361291#-28v3h4_300">以太网采用一种称作<span class="emphasis" id="-1529361291#-28v3h4_301">CSMA/CD</span>的接入方法，即带冲突检测的载波侦听多路接入,其速率为<span class="control" id="-1529361291#-28v3h4_302">10Mb/s</span> ，地址为48bit。</p></section><section><h3 id="-1529361291#-28v3h4_295" data-toc="-28v3h4_295#《TCP-IP详解卷一：协议》.md--28v3h4_295">尾部封装</h3></section><section><h3 id="-1529361291#slip-ip" data-toc="slip-ip#《TCP-IP详解卷一：协议》.md-slip-ip">SLIP: 串行线路IP</h3></section></section></article></div></section></div></body></html>