# 第二章 构造/析构/赋值运算

## 条款5：了解 C++ 默默编写并调用那些函数

当定义了一个没有构造函数（constructor)、析构函数(destructor)和拷贝构造函数(copy assignment)的类，
在编译期间， 编译器会为这个类生成默认(default)的构造函数、析构函数和拷贝构造函数，且是public和inline。

例如：  
定义了一个空类
```C++
class Empty { };
```
在编译后就成了如下的类：
```C++
class Empty(){
public:
    Empty() { ... }                     // default 构造函数
    Empty (const Empty& rhs) { ... }    // default 拷贝构造函数
    ~Empty() { ... }                    // default 析构(non-virtual)函数

    Empty& operator=(const Empty& rhs) { ... }  // 重载拷贝赋值操 作符
};
```
只有当这些函数被被调用时它们才被编译器实现：
```C++
    Empty e1;       // default 构造函数
    Empty e2(e1);   // 拷贝构造函数
    e2 = e1;        // 拷贝赋值函数
                    // 析构函数
```

对于拷贝构造和赋值运算而言，编译器为此所实现的功能仅仅是将源对象的每一个non-static成员复制到目标对象。
```C++
template<typename T>
class Test{
public:
    Test(const char* val_, const T& val_t){}
    Test(const std::string& val_, const T& val_t){}
private:
    std::string val;
    T val_T;
};
```
上面的Test类中已经声明了一个或多个构造函数，因此编译器将不再为它生成default构造函数。  
然后Test类中只声明了构造函数，还有copy构造没有实现和copy assignment没有重载及析构函数没有实现，因此编译器会自动实现这些函数。
```C++
    Test<int> t("ppqwqqq", 12);
    Test<int> t_(t);    // 调用拷贝构造
```
在Test类的对象`t(Test<int>)`中成员变量有std::string类型的val和int类型的val_T,在将t复制给t_时，具体赋值流程如下：
* 对于val(std::string类型)，调用std::string类中的copy构造，来对t_进行赋值
* 对于val_t(T->int，int为内置类型)，对t中val_T的值的每一个bit进行复制，并赋值给t_的val_T

编译器自己生成的copy assignment重载函数必须合法才能使用
```C++
template<typename T>
class T1{
public:
    // 此处的构造函数接受一个reference to non-const std::string类型的参数
    // 和const T&类型的参数
    T1(std::string& str_, const T& val_): str(str_), val(val_){}
private:
    std::string& str;
    const T val;
};

    std::string text_1{"Text1" };
    std::string text_2{"Text2" };
    T1<int> t1(text_1, 123);
    T1<int> t2(text_2, 456);
    t1 = t2;
```
关于t1=t2，进行如下讨论：
* 对t1赋值之前，t1.str和t2.str都指向各自的string对象
* 然后对于操作t1.str = t2.str而言，它不是合法的，因为str的类型为reference to string，而引用绑定一个对象后，无法再改指向其他对象。

因此编译器不会为t1=t2，这种含有reference的成员生成copy assignment重载函数，因此要实现t1 = t2就得需要自己实现copy assignment重载函数。
不仅是对于reference类型的成员变量如此，const类型的成员变量也一样。
对于这种情况需要自己对copy assignment重载函数进行实现：
```C++
    T1& operator=(const T1& other){
        if(this != &other){
            str = other.str;
            /* illgegal
             * val = other.val;
             * val is const
             */
            .....
        }
        return *this;
    }
```
关于基类和子类：如果在基类中copy assignment被声明为private，那么编译器将不会为其子类生成copy assignment，因为在子类中生成的copy assignment 可以处理关于基类的成员，但是又无法访问基类中的copy assignment。


## 条款6：若不想使用编译器自己生成的函数，就该明确拒绝
有时候，可能不想让下面这种情况发生
```C++
    class_ c1;
    class_ c2;
    class_ c3(c1);
    c1 = c2;
```
对于这种拷贝构造、拷贝复制等操作没有实现，且不想让它们被编译器生成，即目标是要阻止copying这种操作被调用。  
首先要知道的一点是，编译器生成的函数的性质为public，若要实现上述目标可以将其声明为private，来阻止它们被调用，
但这么做并不是绝对安全的，因为friend属性的成员函数依旧可以调用private函数。
为了解决这个问题，可以将其声明为private属性的函数并不去实现它。
```C++
class class_{
private:
    class_ (const class_&);
    class_& operator=(const class_&);
};
```
一般要对阻止一个类的拷贝构造和拷贝复制函数被调用时，可以让这个类继承一个base class，
在这个base class可以进行如下操作：
```C++
class uncopyable{
protected:
    uncopyable() {}     // 允许继承此类的对象进行构造和析构
    ~uncopyable() {}
private:
    uncopyable (const uncopyable&);              // 阻止拷贝构造
    uncopyable& operator=(const uncopyable&);    // 阻止拷贝赋值
};

class derived_: private uncopyable{             // 此类不需要再声明拷贝构造函数和拷贝赋值函数
};
```
在进行上述声明后，如果进行下面的操作会被拒绝：
```C++
    derived d1;
    derived d2;
    derived d3(d1);     // error
    d2 = d1;            // error
```
总结：  
不想让编译器自己生成的函数被调用，可以对此函数进行private声明并不予实现。

## 条款7：为多态基类声明 virtual 析构函数
在使用C++的过程中，有时可能会实现如下的操作
```C++
class Person{ }; // 普通人
class Student:public Person{ }; // 学生
class Teacher:public Person{ }; // 教师
class Headmaster:public Person{ }; // 校长
```
现在想要实现一个函数通过基类指针获取派生类的实例，来调用派生类实例的方法，来实现其多态性
```C++
Person* getPerson();    // 返回一个指针，指向派生类 
                        // Person类动态分配对象
```
在C/C++中经由 malloc/new 实例化的类往往都被存放在堆上，这些实例的生命周期具有可控制性，
以至于在使用完这些实例后需要手动将其 free/delete 以避免内存泄漏：
```C++
Person* prs = getPerson();  // 从Person的继承体系中获取一个动态分配的对象
...
delete prs;                 // 释放prs，避免内存泄露
```
而在这其中有一个问题，其中getPerson()返回的指针指向一个继承的类对象，
然而此对象经由一个基类对象指针调用析构函数(non-virtual)而被删除。
在实际执行时会出现这样的结果：基类对象的成员被删除，而继承的类对象的自身特有部分没有被删除，
同时继承的类对象里的析构函数也未能执行起来，导致会有多余的成分没有被析构掉从而形成了内存泄露的结果。  
解决这种问题的一种方法：给基类(base class)定义一个virtual析构函数，这样在调用基类的析构函数时，
同时也会调用派生类的析构函数，这样就可以删除整个对象(及所有继承及基类的成员)。
```C++
class Person{
public:
    Person() = defualt;
    virtual ~Person() = default;
};

class Student: public Person{
    Student() = defualt;
    virtual ~Student() = default;
};

Person* getPerson(){
    return new Student();
}

Person prs = getPerson();
delete prs;
```
一个基类(base class)将其函数定义为virtual，是为了能让其继承类(derived class)能够对此函数进行不同的实现。
任何带有virtual类型函数的类其中也对应存在一个virtual析构函数。  
如果一个类中没有一个virtual函数，那么说明这个类不将会被作为一个基类。  
换言之，如果不想让一个类成为基类，在其中声明virtual函数是不适当的。  
此外，对于有虚函数的类，编译器会为该类创建一个虚函数表(virtual table)，每个对象会存储一个指向虚函数表的指针(virtual pointer)，  
虚函数表存储了该类的虚函数的地址，因此，对内存的开销也会产生额外的负担：
* vptr指针的内存开销：每个对象存储一个指向虚函数表的指针：4字节(x86), 8字节(x64)
* 虚函数表的内存开销：
    * 虚函数的数量
    * 类的层次结构：
        * 继承关系
        * 虚函数重载
    * 多重继承

总而言之，但类中有一个及以上数量的虚函数时，才为此类声明virtual类型的析构函数。

如果想定义一个抽象基类，但是没有合适的成员函数选择，此时，可以声明一个纯虚析构函数

```C++
class abst_class{
public:
    virtual ~abst_class() = 0;
};
```
为基类定义一个virtual析构函数主要用于多态性质的基类，
声明一个基类的对象以调用其派生类，即通过此基类接口来处理派生类对象。
但并非所有的这样的基类(定义了virtual虚构函数的类)都是用来间接处理派生对象的，
而是纯粹作为一个抽象基类来使用，例如：STL。

总结：
具有多态性质的基类内应该有一个virtual析构函数，在类内部具有virtual属性的成员函数的类内部也应该有virtual属性的析构函数。
如果一个类的设计初衷不是为了作为一个基类或者多态性质的基类使用，那么就不要在其中声明virtual属性的析构函数。

## 条款8：别让异常逃离析构函数
在C++中，在析构函数中抛出异常不是一个明智之举。
```C++
class Widget{
  ...
  ~Widget() { ... }  /* 此处可能抛出一个异常 */
};

void func(){
  std::vector<Widget> v;
}                   /* v 在此处被销毁 */
```
此处vector v中的Widget将被释放，若当v[0]释放时有异常抛出，在v[1]释放时又有异常抛出，
在这种两个异常同时存在的情况下，将会导致程序调用 std::terminate 从而导致程序崩溃，
即使使用其他标准库中的容器也会导致同样的情况，这种情况在C++中是非常糟糕的。

使用场景之一：建立数据库连接和断开数据库连接
```C++
class DBConnection{
public:
  ...
  static DBConncetion create();
  /* 建立数据库连接，此方法返回一个DBConnection对象 */
  
  void close();
  /* 此处断开数据库连接，断开失败则抛出异常 */
};
```
为了避免用户忘记在DBConnection对象上调用close()方法，我们可以手动实现一个DBConnection的析构函数，
在DBConnection对象的生命周期结束时，其析构函数调用close()方法。
```C++
/* 手动实现一个class来对DBConnection对象进行管理 */
class DBConn{
public:
  ...
  ~DBConn(){
    db.close();
  }     /* 保证在DBConnection对象的生命周期结束后
           数据库的连接总是会断开
        */
private:
  DBConnection db;
};
{
  DBConn dbc(DBConnection::create()); 
  /* 建立DBConnection对象
     通过DBConn进行管理
     通过DBConne的接口
     使用DBConnection对象
     在DBConnection对象生命周期结束时
     DBConn为DBConnection调用close()
   */
}
```
此处若close()被成功调用，那么程序仍可顺利进行，如果其抛出异常，
那么会导致一个棘手的问题，DBConnection对象中的其他成员或许无法被正常释放，
导致资源泄露，对此问题的解决办法：

* 如果close抛出异常就结束程序，可以通过 abort 完成
```C++
DBConn::~DBConn() {
  try{ db.close(); }
  catch( ... ) {
    /* 将close()抛出异常的记录写入日志文件 */
    std::abort();
  }
}
```
当close抛出异常后，为了阻止这种异常在栈展开的过程中传播出去之前就先结束程序运行。

* 忽视因调用close而引发的异常
```C++
DBConn::~DBConn(){
  trY { db.close(); }
  catch(...) {
    /* 生成日志文件，记录调用close抛出异常的记录 */
    /* 此处不对异常进行反馈，程序依然向后运行 */
  }
}
```
以上提到的两种方法属于下策，对于这种情况另有更好的解决办法：  
对DBConn的设计进行调整
```C++
class DBConn{
public:
  ...
  void close(){
    db.close();
    closed = true;  /* 记录用户是否手动关闭了数据库连接 */
  }
  ~DBConn(){
    if (!closed){   /* 如果用户没有手动关闭数据库的连接 */
      try{ db.close(); }
      catch(...){
        /* 记录下调用close时的异常信息 */
        /* std::abort(); */
        /* 此处可忽略close抛出的异常
           或者直接结束程序
        */
      }
    }
  }
private:
  DBConnection db;
  bool closed;
};
```
此处用户可以手动选择是否关闭数据库连接，如果没有手动关闭，在DBConnection对象的生命周期结束时，其会调用自身的析构函数来断开与数据库的连接。

总结：
* 析构函数绝对不要抛出异常，如果在析构函数中调用了一个函数而导致了异常，此析构函数应该捕捉异常，并阻止它们的在栈的展开的过程中继续传播或直接结束程序。
* 如果用户要对某个函数进行操作的过程中抛出异常做出回应，那么就要在拥有该成员函数的类中提供一个函数来执行该操作。

## 条款9：决不在构造和析构过程中调用 virtual 函数 ###
引入事例：利用class的继承体系来模仿各个行业的交易操作
```C++
class Transaction{ /* base class */
public:
  Transaction( );
  virtual void logTransaction() const = 0;
};

Transaction::Transaction(){
  ...
  logTransaction();
}

class BuyTransaction: public Transaction{ /* derived class */
public:
  virtual void logTransaction() const;
}
```

现在将 BuyTransaction 实例化，其顺序为：
1. 先构造基类 Transaction
2. 调用基类内的 logTransaction()
3. 构造继承类 BuyTransaction

由此可见，所调用的 logTransaction 是属于基类 Transaction 的，
而不是 BuyTransaction 中的 logTransaction。毕竟，
继承类中的 logTransaction 很大概率上会涉及到基类中的成员变量，
所以在基类被构造完成之前调用被实现基类的虚函数是一个危险的操作。

换句话说，在继承类(derived class)构造其基类(base class)的过程中，
此继承类(derived class)实际为基类(base class)，即当前继承类的仅具有基类的属性。   
对于上述例子而言，
即使是下面这种实现方式也会有一定的潜在问题：  
在构造继承类时调用的仍是基类中的logTransaction()
```C++
class Transaction{
public:
  Transcation( ) { init(); }
  virtual void logTransaction() const = 0;
  void logTransaction() { }
  ...
private:
  void init(){
    ...
    logTransaction();
  }
};
```

解决这种的问题的方法：
* 在 Transaction 类中将 logTransaction() 改为 non-virtual，然后用成员初值列的初始化方式对基类中的成员变量进行初始化， 然后继承类的构造函数就可以正常地调用 non-virtual logTransaction。
  ```C++
  class Transaction{
  public:
    explicit Transaction(const std::string& logInfo);
    void logTransaction(const std::string& logInfo) const;
    /* 此时 logTransaction() 是一个non-virtual函数 */
  };
  Transaction::Transaction(const std::string& logInfo){
    ...
    logTransaction(logInfo);
  }
  class buyTransaction: public Transaction{
  public:
    buyTransaction( params): 
    Transaction(createLogString( params )){
      ... /* 将log信息传给基类构造函数 */
    }
  private:
    static std::string createLogString( params );
  };
  ```
  简而言之，此处虚函数无法从基类中被调用至继承的类中，但是可以将继承类中需要初始化的变量向基类方向传递至基类构造函数来达到自己想要的目的。

    * 避免在构造函数中调用虚函数及其解决方法：
        * 使用非虚函数替代虚函数
      ```C++
      class Transaction{
      public:
        explicit Transaction(const std::string& logInfo){
        /* 在构造函数中调用一个非虚函数 */
          logTransaction(logInfo);
        }
        void logTransaction(const std::string& logInfo) const{
          /* Other components */
        }
      };
      
      class BuyTransaction: public Transaction{
      public:
        BuyTransaction(const std::string& params):
        Transaction(createLogString(params)){
          /* 此处利用基类的构造函数对需要初始化的信息进行初始化 */
          /* 以此为例，其继承类的部分构造过程如下:
          * 1. 调用static createLogString对需要初始化的参数进行传递
          * 2. 继承类在构造函数中调用基类的构造函数
          * 3. 基类在进行构造时调用自身的logTransaction函数
          */
      }
      private:
        static std::string createLogString(const std::string& params){
          return "Log info for BuyTransaction" + params;
        }
      }; 
      ```
        * 在构造函数之后进行初始化操作
      ```C++
      class Transaction{
      public:
          Transaction(){}
      
      
          virtual void logTransaction() const = 0;
          /* 等待在继承类中进行实现 */
      
          void init(const std::string& logInfo){
              logTransaction(logInfo);
          }
      };
      
      class BuyTransaction: public Transaction{
      public:
          BuyTransaction(const std::string& params): Transaction(){
              init(createLogString(params));
          }
      
          void logTransaction(const std::string& logInfo) const override{
              /* Other components */
          }
      
      private:
          static std::string createLogString(const std::string& params){
              return "Log info for BuyTransaction" + params;
          }
      };
      ```
        * 使用两个阶段的构造模式
      ```C++
      class Transaction {
      public:
        Transaction() {
        // 基本初始化
        }
      
        virtual void logTransaction() const = 0;
        /* 等待在后面的继承类中实现 */
      
       void completeConstruction(const std::string& logInfo) {
          logTransaction(logInfo);
        }
      };
      
      class BuyTransaction : public Transaction {
      public:
        BuyTransaction(const std::string& params) :
        Transaction() {
          completeConstruction(createLogString(params));
        }
      
        void logTransaction(const std::string& logInfo) const override {
              // 记录 BuyTransaction 的日志
        }
      
      private:
        static std::string createLogString(const std::string& params) {
          // 创建日志字符串
          return "Log info for BuyTransaction: " + params;
        }
      };
      ```

总结：
* 在构造和析构过程中不要调用virtual函数，因为在继承类(derived class)中无法调用基类的virtual函数（关于相对继承而言）。

## 条款10：令 operator= 返回一个 reference to *this
关于赋值操作符=
```C++
int x, y, z;
/* 关于赋值操作符=，可以写为连锁赋值的形式 */
x = y = z = 15;
/* 增强赋值操作的可读性，如下： */
x = (y = (z = 15))
```
实现连锁赋值的操作的前提是赋值操作符必须返回一个指向=左边实参的引用。  
对于一个自定义类而言，在对其赋值操作符=进行重载时，其返回值类型应该如下：
```C++
class MyWidget{
public:
  ...
  MyWidget& operator=(const MyWidget& rhs){
    ...
    return * this;
  }
  /* 对于其他类型的函数参数也适用 */
  MyWidget& operator=(int rhs){
    ...
    return * this;
  }
  /* 对于其他类型的赋值操作符也适用 */
  MyWidget& operator+=(const MyWidget& rhs){
    ...
    return * this;
  }
};
```
对于这样的赋值操作符重载操作在标准库中的一些容器(例如：vector, string, complex等)中也存在。

总结：
* 让赋值(assignment)操作符返回一个 reference to *this。

## 条款11：在 operator= 中处理“自我赋值”
在代码实现的过程中，可能会出现以下这种情况——“自我赋值”:
```C++
class MyWidget{ };
MyWidget w;
...
w = w; /* 自己对自己进行赋值 */

/* 一种容易忽视的自我赋值情况 */
a[i] = a[j] /* 当 i == j 时，
             * a[i] = a[j]
             * 这就成了自我赋值 */

/* 另一种容易忽视的自我赋值情况 */
* px = * py;
```
对于 * px = * py 这种赋值情况而言，当px 与 py恰好指向同一个实例时，这也就成为了自我赋值。  
上述情况，都是基于“别名(aliasing)”所产生的结果，因为有一个及以上的方法(pointer or reference)指向同一个对象。  
对于继承体系而言，只要派生的对象都继承于同一个基类，就会自然的产生自我赋值的这种情况，因此这一般是一个不可避免的问题：
```C++
class Base{ ... };
class Derived: public Base { ... };
void action(const Base& rb, Derived* pd);
/* 此处的 rb 和 pd 可能是同一个对象 */
```

当要自行实现资源管理时，很容易掉入“停止使用资源之前提前对此资源进行了释放”这种陷阱。例如，
创建一个Widget类保存一个指向动态分配的位图(Bitmap)的指针：
```C++
class Bitmap { ... };
class Widget { 
  ...
private:
  Bitmap* pb; /* * pb 一个指向从 heap 分配得到的对象 */
};
```
对于Widget类的中=赋值的重载实现：
```C++
Widegt& Widget::operator=(const Widget& rhs){
  delete pb;                // 删除当前的 pb 指针
  pb = new Bitmap(*rhs.pb); // 使用 rhs 的 Bitmap
  return *this;
}
/* 这种情况并不安全 */
```
这里自我赋值的情况在于，如果 operator= 重载函数中的 *this(被赋值的对象) 和 rhs 是一个对象，
那么 delete pb 不只是删除当前对象的bitmap, 也会删除rhs中的bitmap，待到执行结束，*this 会指向一个已经被删除的对象，这种情况是很危险的。

解决这种问题的方法还是在operator=中添加一个"证同条件"，达到自我赋值检验的目的：
```C++
Widget& Widget::operator(const Widget& rhs){
  if(this == &rhs) return * this; // 证同条件
  /* *this 和 &rhs 指向的不是同一个对象 */ 
  delete pb;
  pd = new Bitmap(*rhs.pb);
  return *this;
}
```
前一个 operator= 不仅不具备“自我赋值的安全性”，也不具备“异常安全性”。  
添加了证同条件的 operator= 也存在着一些问题，如果是在"new Bitmap"导致异常(不论是因为分配时内存不足或因为Bitmap的copy构造函数抛出异常)，
Widget 的 pb 指针最终会指向一个被删除的Bitmap，这种情况也很危险，对于这种情况，更加需要重视的是如何处理异常安全性，以此再改善之前的的“自我赋值”：
```C++
/* 确保在对pb赋值时，pb所指的对象没有被删除 */
Widget& Widget::operator=(const Widget& rhs){
  Bitmap* pOrig = pb;       // 存下原来的 pb
  pb = new Bitmap(*rhs.pb); // 可能 throw exception
  delete pOrig;             // 删除原来的 pb
  return *this;
}
```
如果"new Bitmap"抛出异常，pb及其Widget保持原状，在没有证同条件的情况下，依旧能处理自我赋值，
因为存在一份事先存下来的 Orig 可以帮助恢复至 pb 被赋值前的状态。

如果想要提高运行效率，可以在operator=前加一个证同条件。但是也要知道自我赋值这种情况发生的概率大小，
毕竟这个修改给函数增加了一个新的判断分支，因此同时也会影响执行速度，prefetching(预取)、caching(缓存)和pipelining(流水线)等指令的效率都会因此降低。

> **补充**  
> **prefetching**: 处理器进行预取时会根据指令流进行预测。如果插入额外的条件判断，可能会改变指令流的顺序，从而影响预取结果，导致预取的数据不是立即需要的，降低预取的效率。  
> **caching**: 额外的判断分支可能导致不同的代码路径访问不同的数据，增加缓存失效(cache miss)的可能性。当缓存失效时，处理器需要从较慢的缓存中加载数据，导致性能下降。
> **pipelining**: 条件判断会引入分支，如果处理器预测错误的分治，会导致流水线停顿(pipeline stall)，清空错误路径上的指令，重新加载正确的指令。这种停顿会严重影响处理器的指令吞吐量。

要确保operator=的“异常安全“和”自我赋值安全“的第一个替代方案是，使用 copy and swap 技术来实现：
```C++
class Widget{
  ...
  void swap(Widget& rhs); // 交换 *this 和 rhs 的数据
  ...
};
Widget& Widget::operator=(const Widget& rhs){
  Widget temp(ths);   // 对 rhs 进行备份为 temp 
  swap(temp);         // 将 *this 数据与备份数据 temp 进行交换
  return *this;
}
```
operator=另一种更高效的(但是降低了代码的可读性)写法如下：
```C++
Widget& Widget::operator=(Wdiget rhs){  // rhs 是被传递对象的一个备份
  swap(rhs);                            // 此处利用 pass by value
  return *this;                         // 将 *this 的数据与备份的数据进行互换
}
```
参考依据：
1. 一个类的 copy assignment 操作符可能被声明为"按值传递(pass by value)的方式接受实参"。
2. 通过按值传递(pass by value)的方式处理会多出一份rhs的备份数据。

总结：
* 确保当前对象在进行自我赋值时operator=有着正确处理行为，例如：
    * 比较"来源对象"和"目标对象"的地址
    * copy and swap 技术
    * 正确且具有可读性的语句
* 确保一个函数在操作多个对象时，对于相同的对象的处理仍然正确。

## 条款12：复制对象时勿忘其每一个成分
良好的面向对象系统会将对象的内部封装起来，只留两个函数负责对象拷贝，即copy构造函数和copy assignment操作符。  
对于以上两种函数，如果自己不主动实现，编译器会自动生成。对于自己实现的版本，当这些函数出错时，编译器不会给出任何提示信息，因此会增加debug难度。

示例：实现一个 顾客类 (Customer Class)，手动实现其中的copying函数，同时实现一个 logCall 记录函数的调用
```C++
void logCall(const std::string& funcName);
class Customer{
public:
  ...
  Customer(const Customer& rhs);
  Customer& operator=(const Customer& rhs);
  ...
private:
  std::string name;
};

/* 拷贝构造 */
Customer::Customer(const Customer& rhs): name(rhs.name) /* 复制rhs的数据 */ {
  logCall("Customer copy constructor");
}

/* =赋值运算符重载 */
Customer& Customer::operator=(const Customer& rhs){
  logCall("Customer copy assignment operator");
  name = rhs.name;  // 复制rhs的数据
  return *this;     
}
```
以上是对类的copy构造和copy assignment运算符的一般实现。  
但是对于以下情况就会有所不同：
```C++
class Date { ... };
class Customer {
public:
  /* 同前 */
private:
  std::string name;
  Date lastTransaction;
};
```
此处若还是使用之前的copying函数，那么执行的就是局部拷贝或部分拷贝(partial copy)，因为它们只复制了顾客的name，
但没有复制新添加的 lastTransaction，编译器也不会对此做出任何提示或者警告，因为这是手动实现的copying函数，为了实现对所有成员变量的copy，
也必须手动修改对应copying函数。  
倘若这样的问题出现在一个继承体系中：
```C++
class PriorityCustomer: public Customer{
public:
  ...
  PriorityCustomer(const PriorityCustomer& rhs);
  PriorityCustomer& operator=(const PriorityCustomer& rhs);
  ...
private:
  int priority;
};

PriorityCustomer::PriorityCustomer(const PriorityCustomer& rhs):
        priority(rhs.priority){
  logCall("PriorityCustomer copy constructor");        
}

PriorityCustomer& PriorityCustomer::
operator=(const PriorityCustomer& rhs){
  logCall("PriorityCustomer copy assignment operator");
  priority = rhs.priority;
  return *this;
}
```
上面的继承类 PriorityCustomer 的copying函数只复制了当前PriorityCustomer中的成员变量，但因为这个PriorityCustomer是继承自Customer的，
即其父类(Customer)中的成员变量没有被复制，因此也导致了一个局部复制(partial copy)，而此时因为没有对父类中的成员变量进行赋值，
导致父类会调用其default构造函数(无参构造函数)，default构造函数将针对name和lastTransaction执行缺省的初始化操作。

任何时候，为继承类实现copying函数，必须也要复制其父类的所有成员变量，父类中的成员变量往往是private属性的，所以继承类copying函数需要调用父类的相应copying函数对父类中的成员变量进行赋值：
```C++
PriorityCustomer::PriorityCustomer(const PriorityCustomer& rhs):
  Customer(rhs),  // 调用父类的构造函数，对父类成员进行赋值
  priority(rhs.priority){
  logCall("PriorityCustomer copy constructor");
}

Priority& Priority::operator=(const PriorityCustomer& rhs){
  logCall("PriorityCustomer copy assignment operator");
  Customer::operator=(rhs); // 调用父类的的赋值函数，对父类成员进行赋值
  priority = rhs.priority;
  return *this;
}
```
综上可总结出的经验：
1. 复制所有local成员变量
2. 调用所有 base classes 内合适的copying函数

切记，是调用对应的copying函数，不要让 copy assignment 操作符重载函数去调用 copy 构造函数，因为构造一个已经存在的对象这样的操作是没有意义的，
同样，也不要让 copy 构造函数去调用 copy assignment 操作符重载函数。因为构造函数是用来创建新的实例的，而 assignment 操作符只适用于已经创建好的实例上，对于一个没有初始化的对象使用 assignment 操作符是一个没有意义的操作。

如果在 copy 构造函数和 copy assignment 操作符中有相同的部分，建立一个新的成员函数给两者调用。这样的函数一般是private属性且名为init，这个操作可以安全消除copy 构造函数和 copy assignment 操作符之间的代码重复。
```C++
class PriorityCustomer: public Customer{
public:
  PriorityCustomer(const PriorityCustomer& rhs){
    init(rhs);
    logCall("PriorityCustomer copy constructor");
  }

  PriorityCustomer& operator=(const PriorityCustomer& rhs){
    if(this != rhs){
      Customer::operator(rhs);
      init(rhs);
    }
    logCall("PriorityCustomer copy assignment operator");
    return *this;
  }
  
private:
  int priority;
  void init(const PriorityCustomer& rhs){
    priority = rhs.priority;
  }
};
```

总结：
* copying函数应该确保复制“对象内的所有成员变量”及“所有父类(base class)成分"。
* 在继承类中的copying函数应该调用父类中对应的copying函数。
* 将copy构造函数和copy assignment操作符中的具有相同部分功能的代码写入到一个单独的函数中，供这两者调用。