# 2. 函数模板

## 2.1 初探函数模板

函数模板提供了一种函数行为，该函数行为可以为多种不同的类型进行调用，
这些函数和普通函数很相似，唯一区别就是有些函数元素是未确定的，这些元素将在使用时被初始化。

### 2.1.1 定义模板
```C++
template<typename T>
inline T const& max(T const& a, T const& b){
    return a < b ? a : b;
}
```
不同于一般的函数，这个函数模板的参数在未被调用前其类型未被确定，
所以使用模板参数 T 来替代。

参数模板的语法形式：
```C++
    template<comma-separated-list-of-parameters>
    template<参数列表>
```
在上述例子中，参数列表是 typename T，类型参数为 T（此处类型参数可以使用任意标识符），
调用这个函数时需要指定 T 的类型，此处 T 的类型可以是基本类型、类等。

对于 operator< 这个操作符的重载就可以使用类型 T，因为 a 和 b 就是使用这个运算符来进行比较的。

`template<typename T>` 中的关键字 typename 还可以替换为 class：
```C++
template<class T>
inline T const& max(T const& a, T const& b){

}
```
从语义上讲，这里的 class 和 typename 是等价的，即使这里使用的是 class，但仍可以使用任何类型（ps:该类型提供模板使用的操作）来实例化模板参数。

但是此处 class 的使用往往会产生的误导的作用，认为只有类才能够替代 T，所以对于引入类型参数的这种用法，应该使用 typename，同时也要注意在引入参数时不能够使用 struct 代替 typename 关键字。

### 2.1.2 使用模板
使用 max() 函数模板的示例：
```C++
#include <iostream>
#include <string>

template<typename T>
inline T const& max(T const& a, T const& b){
    return a > b ? a : b;
}

int main(){
    int i = 42;
    std::cout << "max(7, i): " << ::max(7, i) << '\n';

    double f1 = 3.4;
    double f2 = -6.7;
    std::cout << "max(f1, f2): " << ::max(f1, f2) << '\n';

    std::string s1 = "mathematics";
    std::string s2 = "math";
    std::cout << "max(s1, s2): " << ::max(s1, s2) << '\n';
}
/* output:
 * max(7, i): 42
 * max(f1, f2): 3.4
 * max(s1, s2): mathematics
 */
```
注：此处使用域限定符::是为了避免二义性，因为在标准库中也有一个std::max()模板。

通常而言，并不是把模板编译成一个可以处理任何类型的单一实体，而是对于实例化模板参数的每种类型，都会从模板中产生出一个不同的实体。  

当 T 被实例化为 int 时：
```C++
template<typename T>
T const& max(T const& a, T const& b){
    return a > b ? a : b;
}

#ifdef USE_TEMPLATE
template<>
const int& max<int>(int const& a, int const& b){
    return a > b ? a : b;
}
#endif
```

当 T 被实例化为 std::string 时：
```C++
template<typename T>
T const& max(T const& a, T const& b){
    return a > b ? a : b;
}

#ifdef USE_TEMPLATE
template<>
const std::basic_string<char, std::char_traits<char>, 
std::allocator<char> > & max<std::basic_string<char, 
std::char_traits<char>, 
std::allocator<char>>>(const std::basic_string<char, std::char_traits<char>, 
std::allocator<char> > & a, const std::basic_string<char, std::char_traits<char>,
std::allocator<char> > & b)
{
  return operator>(std::operator<=>(a, b), __cmp_cat::__unspec(0)) ? a : b;
}
#endif
```
只要使用函数模板，编译器会自动地对相应类型的 T 进行实例化。

然而使用一个不支持模板内部使用的类型来实例化一个模板，这会导致编译错误：
```C++
    std::complex<float> c1, c2;
    ...
    max(c1, c2); /* 这将导致编译出错，
                  * 因为std::complex并不支持operator <
                  */  
```
由此可以得出的结论，模板被编译了两次，分别发生在：
1. 实例化之前，进行语法检查。
2. 实例化期间，进行实例化类型支持检查。

## 2.2 实例的推导(deduction)

如果传递了两个 int 给参数类型 T const&，那么编译器可以自行推导出：T 必须是 int。

注：此处不允许进行自动类型转换；每个 T 都必须正确地匹配，例如：
```C++
template<typename T>
inline T const& max(T const& a, T const& b);
...
max(4, 7);      // 可行，因为两个实参的类型都是 int
max(4, 4.2);    // 不可行，因为第一个 T 是 int， 第二个 T 是double
```
对上面这种错误地处理方法：
1. 使用强制类型转换，使它们的类型可以相互匹配：
    ```C++
    max(static_cast<double>(4), 4.2);   // 统一参数类型
    max<double>(4, 4.2);                // 强制返回类型
    ```
2. 显式指定（或者限定）T 的类型。
3. 指定两个参数可以具有不同的类型。

## 2.3 模板参数
函数模板有两种类型的参数：
1. 模板参数：位于函数模板名称的前面，在一对尖括号内进行声明：
`template <typename T>`，其中 T 是模板参数。
2. 调用参数：位于函数模板名称之后，在一对圆括号内部进行声明：
`...max(T const& a, T const& b)`，其中 a 和 b 都是调用参数。

在函数模板内部（这一点和类模板有区别），不能指定缺省的模板实参：
```C++
template<typename T1, typename T2>
inline T1 max(T1 const& a, T2 cosnt& b){
    return a > b ? a : b;
}
...
max(4, 4.2) // 可行，但是第一个参数的类型决定了函数的返回类型
```
在这种实现方法中，T1 决定了函数的返回类型，一般 T2 的类型会与 T1 不同，此时 T2 的类型就要转换为与 T1 相同的类型。

于是，取决于调用实参的顺序，例如 42 和 55.55 的最大值可以是浮点数 55.55(浮点类型先被调用)，也可以是 55(整型先被调用)。这其中还存在着另一个缺点，
第二个参数转型为返回类型的过程中会创建一个局部临时对象，这导致了不能通过引用来返回结果。因此，在上面的代码段中，返回类型必须是 T1，而不能是 T1 const&。

> 对于那些作用域局部于函数内部的值，就不应该通过引用来返回该值（即返回一个值指向该引用）。
> 因为当程序离开这个函数作用域之后，该值将不再存在，该引用也不再有效。

函数模板的推导：调用参数的类型构造自模板参数，所以模板参数和调用参数通常是相关的，这使得可以像调用普通函数那样调用函数模板。

正如前面所提到的，针对某些特定的类型，还可以显示地实例化该模板：
```C++
template<typename T>
inline T const& max(T const& a, T const& b);
...
max<double>(4, 4.2);    // 使用 double 来实例化 T
```

当模板参数和调用参数没有发生关联，即不能由调用参数来决定模板参数时，在调用时就必须显示指定模板参数。
此时，可以引入第 3 个模板实参类型，来定义函数模板的返回类型：
```C++
template<typename T1, typename T2, typename RT>
inline RT max(T1 const& a, T2 const& b);
...
max<int, double, double>(4, 4.2)    // 可行，但是比较麻烦
```

还有一种情况是只显示指定第一个实参，让编译器自行推导出其余的实参。通常情况下，必须指定“最后一个不能被隐式推导的模板实参之前的”所有实参类型，
因此，在上面的例子中，如果改变模板参数的声明顺序，那么调用者只需要指定返回类型：
```C++
template<typename RT, typename T1, typename T2>
inline RT max(T1 const& a, T2 const& b);
...
max<double>(4, 4.2); // 返回类型是double
```
此处调用`max<double>`时显式地把 RT 指定为 double，其他两个参数 T1 和 T2 可以根据调用实参分别推导为 int 和 double。

综上可以看出，这些不同版本的 max() 都不能得到很大的改进，由于在单(模板)参数版本中，传递进来的是两个不同类型的实参，且可以指定参数的类型和返回类型，因此，应该尽量使用单参数版本的max()以保持代码的可读性。

## 2.4 重载函数模板
和普通函数一样，函数模板也可以被重载，也就是说，相同的函数名称可以具有不同的函数定义，于是，当使用函数名称进行函数调用的时候，C++编译器必须决定要调用哪个函数。
```C++
/* 指定类型为 int */
inline int const& max(
       int const& a, 
       int const& b){
   return a < b ? b : a;
}
/* 不指定类型 */
template<typename T>
inline T const& max(T const& a, T const& b){
   return a < b ? b : a;
}
/* 不指定类型 */
template<typename T>
inline T const& max(T const& a, T const& b, T const& c){
   return ::max(::max(a, b), c);
}
int main(){
   ::max(7, 42, 68);    // 使用接受三个参数的模板
   ::max(7.0, 42.0);    // 使用接受两个参数的模板，推导类型为 double 
   ::max('a', 'b');     // 使用接受两个参数的模板，推导类型为 char
   ::max(7, 42);        // 使用int重载的非模板函数
   ::max<>(7, 42);      // 使用接受两个参数的模板，推导类型为 int
   ::max<double>(7, 42);// 使用接受两个参数的模板，显式指定类型为 double
   ::max('a', 42.7);    // 使用int重载的非模板函数
}
```
如上面的例子所示，一个非模板函数可以和一个同名的函数同时存在，而且该函数模板还可以被实例化为这个非模板函数。
对于非模板函数和同名的函数模板，如果其他条件都是相同的话，那么在调用的时候，重载解析过程通常会调用非模板函数，
而不会从该模板中产生出一个实例：`::max(7, 42);`。

然而，如果模板可以产生一个具有更好匹配的函数，那么将选择模板:：`::max(7.0, 42.0);`调用`::max<double>`，`::max('a', 'b')`调用`::max<char>`。

还可以显示指定一个空的模板实参列表，这个语法是在指定编译器只能使用模板来进行匹配，而且所有的模板参数都应该根据调用实参推导出来：`max<>(7, 42)`经推导后得到`max<int>`。

因为模板是不允许自动类型转换的，但普通函数可以进行自动类型转换，所以`::max('a', 42.7)`使用的是非模板函数。

```C++
#include <iostream>
#include <string>
template<typename T>
inline T const& max(T const& a, T const& b){
   return a < b ? b : a;
}

template<typename T>
inline T* const& max(T* const& a, T* const& b){
   return *a < *b ? a : b;
}

// C 字符串风格
template<typename T>
inline char const* const& max(char const* const& a, char const* const& b){
   return std::strcmp(a, b) < 0 ? b : a;
}

int main(){
   int a = 7,
       b = 42;
   ::max(a, b);
   
   std::string s = "hey",
               t = "you";
   ::max(s, t);
   
   int* p1 = &b,
      * p2 = &a;
   ::max(p1, p2);
   
   char const* s1 = "David";
             * s2 = "Nico";
   ::max(s1, s2);
}
```
在所有重载的实现中，都是通过引用来传递每个实参的。  
一般而言，在重载函数模板时，只修改那些需要修改的值，即将需要修改的条件限制在下面的两种情况中： 改变参数的数目或者显式地指定模板参数。

例如，对于原来使用传引用的max()模板，用C-String进行重载，但对于现在基于C-Strings的max()函数，使用过传值来传递参数，那么就不能使用3个参数的max()版本来对3个C-String求最大值：
```C++
#include <iostream>
#include <string>

// 通过引用传递
template<typename T>
inline T const& max(T const& a, T const& b){
   return a < b ? b : a;
}

// 通过值传递
template<typename T>
inline char const* max(char const* a, char const* b){
   return std::strcmp(a, b) < 0 ? b : a;
}

// 通过引用传递
template<typename T>
inline T const& max(T const& a, T const& b, T const& c){
   return max(max(a, b), c);
   // 此处 max(a, b) 如果使用值传递将会发生错误
}

int main(){
   ::max(7, 42, 68);
   const char* s1 = "frederic",
             * s2 = "anica",
             * s3 = "lucas";
   ::max(s1, s2, s3); // error
}
```
此处的问题在于，对三个C-String调用max()，那么语句`return max(max(a, b), c);`将会出现一个错误。
这是因为对于C-String而言，这里的max(a, b)产生了一个新的临时局部变量，该值可能会被外面的max函数以传递引用的方式放回，这将导致传回无效的引用。

事实上，定义一个接受3个参数的max()，而且直到定义处还没有看见一个具有两个int参数的重载max()声明，那么这个具有3个int实参的max()调用将会使用具有两个参数的模板，而不会使用基于int重载本的max():
```C++
// 未指定类型
template<typename T>
inline T const& max(T const& a, T const& b){
   return a < b ? b : a;
}

// 未指定类型，三个参数
template<typename T>
inline T const& max(T const& a, T const& b, T const& c){
   return max(max(a, b), c);  // 当 T 被实例化为 int时，该函数使用的还是模板
                              // 因为 int 类型的重载被声明在了该函数的后面 
}

// 指定类型为 int
inline int const& max(int const& a, int const& b){
   return a < b ? b : a;
}
```
综上可知，函数的所有重载版本的声明应该位于该函数被调用的位置之前。

## 2.5 小结
* 模板函数为不同的模板实参定义了一个函数族。
* 当传递模板实参的时候，可以根据实参的类型来对函数模板进行实例化。
* 可以显式指定模板参数。
* 可以重载函数模板
* 当重载函数模板时，只对需要显式指定的模板参数类型进行修改。
* 一定要让函数模板的所有重载版本的声明都位于它们被调用的位置之前。