# 第三章 资源管理

使用计算机资源，最重要的一个原则就是有借有还。  
C++中最常用的资源就是动态分配内存，如果使用了内存后，不将其返还，那么就会导致资源泄露。  
内存在计算机中是必须管理的众多资源之一，其他常见的资源还包括文件描述器(file descriptor)、互斥锁(mutex locks)、图形界面中的字型和笔刷、数据库连接以及网络sockets。

## 条款13：以对象管理资源
先引出示例：实现一个关于投资行为的程序库，其中各种投资类型继承自一个root class Investment。
```C++
class Investment { ... };   // 继承体系中的一个父类
```
这个程序库通过一个工厂函数来使用特定的Investment对象：
```C++
Investment* createInvestment(); // 返回指针，指向Investment继承体系内的动态分配对象
                                // 使用完后，有必要对其进行删除
```
现使用一个函数来实现上述指针资源的回收(删除):
```C++
void f(){
    Investment* pInv = createInvestment();  // 调用 factory 函数
    ...
    delete pInv;                            // 释放pInv所指的对象
}
```
如果这个函数提早结束了，使之不能到达delete pInv这一句，pInv就无法被正常删除，以此导致的内存泄露是非常危险的。  
同样的情况在循环语句中或许因为continue和goto导致控制流无法执行到delete ...语句，导致资源无法被正常释放。

为确保资源能够被正常释放，可以将资源放进对象中，当控制流离开函数(函数执行完)，该对象的析构函数会自动释放那些资源。  

> 补充：计算中内存的分配和组成
> 1. 栈(stack)  
> ```C++
> void f(){
>   int localVariable = 42; // 分配在栈上
> }
> ```
> 内存布局：栈是由一个后进先出(LIFO)结构，栈顶指针随着函数调用和局部变量的创建而增长，随着函数返回和局部变量的销毁而减少。  
> 用途：用于存储局部变量、函数参数和函数调用的返回地址  
> 特点：
>    * 栈内存是由编译器自动管理的。
>    * 内存分配速度快，但是大小有限(通常由操作系统限制)。
>    * 变量的生命周期是由其作用域决定的，当离开作用域时，内存自动释放。
> 2. 堆(heap)
> ```C++
> int* p = new int(42); // 分配在堆上
> delete p;             // 手动释放内存
> ```
> 内存布局：堆是一个更复杂的区域，由操作系统或运行时库管理，允许自由分配和释放内存。
> 用途：用于动态内存分配，例如通过"new"和"malloc"分配的内存
> 特点:
>    * 需要手动管理内存(分配和释放)。
>    * 可以分配比栈更大的内存块，但速度较慢且容易导致内存泄漏。
>    * 生命周期由程序员控制，直到显式释放内存(通过"delete"或"free")。
> 3. 全局/静态内存区域(Global/Static Memory Area)
> ```C++
> int globalVariable = 42;          // 全局变量
> void f(){
>   static int staticVariable = 42; // 静态变量
> }
> ```
> 内存布局：这部分内存通常在程序的最底层，由操作系统分配和管理
> 用途：用于存储全局变量和静态变量，这些变量在程序的整个生命周期内都存在。
> 特点：
>    * 这些变量在程序启动时分配内存，在程序结束时释放。
>    * 生命周期贯穿整个程序运行期。
> 4. 代码段(code segment)
> 内存布局：代码段包含程序运行的机器指令，是内存中固定的一部分。
> 用途：存储程序可执行代码。
> 特点：
>    * 通常是只读的，以防止意外修改程序代码。
>    * 在程序加载到内存时由操作系统分配。
> 
> 整体内存布局
> ```
> 高地址
> +----------------------+
> |          栈          |
> +----------------------+
> |          堆          |
> +----------------------+
> |          BSS         |
> +----------------------+
> |          数据段       |
> +----------------------+
> |          代码段       |
> +----------------------+
> 低地址
> ```

许多资源被动态分配在heap内，之后被用于单一区块或函数内，它们在控制流离开了所在区块或函数时被释放。  
为了上面这种清醒，智能指针(auto_ptr)就应运而生了,auto_ptr是一个"类指针(pointer-like)对象"，其析构函数自动对其所指对象调用delete以释放资源：
```C++
void f(){
    std::auto_ptr<Investment> pInv(createInvestment());
        /* 调用 工厂函数(factory function)
    ...  * 经由auto_ptr的析构函数自动删除pInv
        */
}       
```
上面这个例子可以体现"以对象管理资源“的两个关键点：
1. 获得资源后立刻放进管理对象(managing object)内，以上代码中createInvestment返回的资源被当作其管理者 auto_ptr 的初值。使用对象管理资源的观念常被称作RAII(Resource Acquisition Is Initialization)，即在获取资源时就进行初始化，因此所有资源在获得的同时应该被立即放入管理对象中。
2. 管理对象(managing object)运用析构函数确保资源被释放，只要控制流离开了函数，其中的对象离开了作用域，其析构函数就会被自动调用，使其资源被释放。

因为当 auto_ptr 被释放时，auto_ptr 指针所指向的对象也被会释放，所以要注意不要让多个 auto_ptr 指向同一个对象，否则会导致一个对象被释放多次，使其产生未定义行为。  
针对此种情况，设计者为auto_ptr添加了一个特性，就是当使用copying函数(copy 构造函数和copy assignment 操作符)对其进行复制时，复制出来的auto_ptr会变成null，这一点就很好地保证了复制所得指针所取得的资源的唯一性。

```C++
std::auto_ptr<Investment> pInv1(createInvestment());    
    // pInv1指向createInvestment创建的对象
std::auto_ptr<Investment> pInv2(pInv1);
    // pInv2指向pInv1所指的对象，pInv1现被设置为null
    // 转移所有权
pInv1 = pInv2;
    // 现pInv1指向pInv2所指的对象，pInv2被设置为null
    // 转移所有权
```
上面这一过程体现出auto_ptr对资源管理的局限性，即auto_ptr指向资源的唯一性。

解决这种问题的一种方案是使用"引用计数智能指针(reference-counting smart pointer-RCSP)"。RCSP也是一种智能指针，
其可持续追踪共有多少对象指向某笔资源，并在无指针指向某资源时，自动释放该资源，但是对于环状引用(即两个指针指向彼此，导致其仍然处在被使用的状态)，RCSP无法解决。
```C++
void f(){
    ...
    std::shared_ptr<Investment> pInv(createInvestment());
    ...
}
```
使用shared_ptr的复制操作相对于auto_ptr要正常得多：
```C++
void f(){
    ...
    std::shared_ptr<Investment> pInv1(createInvestment()); 
    // pInv1指向createInvestment()返回的对象
    std::shared_ptr<Investment> pInv2(pInv1);
    // pInv1和pInv2指向同一个对象
    pInv1 = pInv2;
    // 同上，不发生改变
    ...
    // pInv1和pInv2被释放，那么它们所指的对象也会被释放
}
```
auto_ptr和shared_ptr两者都在其析构函数执行delete而不是delete[]，这就意味着不应该在动态分配的array上使用auto_ptr和shared_ptr，如下：
```C++
std::auto_ptr<std::string> aps(new std::string[10]);
std::shared_ptr<int> spi(new int[1024]);
```
在C++一般使用vector或string这样边长array来替代动态分配的数组，所以针对动态分配的数组并没有特定指针。

总结：
* 使用RAII对象来防止资源泄露，它们在构造函数中获取资源并在析构函数中释放资源。
* 常使用的两个RAII对象分别为shared_ptr和auto_ptr，其中shared_ptr为更好的选择，因为其copy行为较为直观，auto_ptr的复制行为会使其指向null。

## 条款14：在资源类管理中小心copying行为
有时候为了更好地管理资源，还是需要自己实现资源管理类。

示例：使用C API函数处理类型为Mutex的互斥器对象(mutex object)，共有lock和unlock两种函数可用：
```C++
void lick(Mutex* pm);   // 锁定pm所指的互斥器
void unlock(Mutex* pm); // 将互斥器解除锁定
```
为了保证每一个被锁住的互斥器Mutex解锁，可能就需要建立一个类来管理机锁。要设计这样的管理类的管理原则也可以参考RAII对象的设计，即“在获取资源的同时进行初始化，在析构期间释放"：  
* 定义一个RAII对象管理mutexPtr
```C++
class Lock{
public:
    explicit Lock(Mutex* pm): 
    mutexPtr(pm){ lock(mutexPtr); } // 获取资源
    ~Lock() { unlock(mutexPtr); }   // 释放资源
private:
    Mutex* mutexPtr;    // raw pointer
};
```
* 使用该对象
```C++
    Mutex m;            // 定义互斥器
    ...
    {                   // 定义一个 critical section
        Lock ml(&m);    // 锁定互斥器
        ...
    }                   // 自动解除互斥器锁定
```
* 尝试复制Lock对象
```C++
    Lock ml1(&m);       // 锁定 m
    Lock ml2(ml1);      // 尝试将ml1复制到ml2上
```
此时多个RAII对象拥有着同一个互斥器m，这导致在RAII对象释放时，会使互斥器多次释放，导致未定义行为。  
此时解决此问题的方案：
* 禁止复制：明确声明禁止对RAII对象的复制，可以将copying操作声明为private，或者删除copying操作：
  * 将copying操作声明为private：
    ```C++
    class Uncopyable{
    public:
        ...
    protected:
        Uncopyable();
        ~Uncopyable();
    private:
        Uncopyable (const Uncopyable&);
        Uncopyable& operator(const Uncopyable&);
    };
    class Lock: private Uncopyable{
    };
    ```
  * 删除copying操作：
    ```C++
    class Lock{
    public:
      ...  
      
      // 删除copy构造函数和copy assignment操作符
      Lock(const Lock&) = delete;
      Lock& operator=(const Lock&) = delete; 
      
      ...
    };
    ```
* 对底层资源使用"引用计数法(reference-count)"，即当一个资源没有再被使用时将其释放。这种情况下复制RAII对象，该资源的"被引用数"增加。

因为在Lock中的析构函数作用是unlock(解锁)，而不是delete(释放资源)，使用shared_ptr的缺省行为是删除当前引用次数为0的对象，
然而shared_ptr的deleter(删除器，释放器)是一个函数或函数对象，当引用次数为0时便被调用(这种机制在auto_ptr中不存在)，因此可以修改传给shared_ptr的参数：
```C++
class Lock{
public:
    explicit Lock(Mutex* pm): mutexPtr(pm, unlock){
        // 指定 unlock 为shared_ptr的删除器
        lock(mutexPtr.get());
    }
    /* 此处的析构函数调用非static成员变量的析构函数
     * 即shared_ptr的删除器
     */
    
private:
    std::shared_ptr<Mutex> mutexPtr;    
    // 使用 shared_ptr 替代 raw pointer 
};
```
* 复制底部资源，当复制资源管理对象时，进行的是"深度拷贝"，即在复制管理资源对象时，也要对其包含的资源进行复制。有些字符串(一般为可变长)类型由"指向heap内存“的指针构成，
这种字符串对象内包含一个指针指向一块heap内存，当这样的一个字符串对象被复制时，指针和其所指的内存段都会被复制，这就体现了字符串的深度拷贝行为。
* 转移底部资源的拥有权，某些情况下可能希望永远只有一个RAII对象指向一个未加工资源(raw resource)，即使RAII对象被复制依然如此，此时资源的拥有权会从被复制物转移到目标物，这是auto_ptr奉行的复制意义，使其在被复制时资源的拥有权在新的RAII手中，以使资源只被一个RAII对象进行管理，避免后续多个对象尝试释放同一资源的问题。

总结：
* 复制RAII对象必须一并复制它们所管理的资源，所以资源的copying行为决定RAII对象的copying行为。
* 普遍而常见RAII class copying行为是：阻止copying、使用引用计数法等。

## 条款15：在资源管理类中提供对原始资源的访问
有些时候，需要实现多个资源管理类对象的不同资源之间的访问，此时就要在资源管理类中提供对原始资源的访问。  
示例：使用智能指针 auto_ptr 或 shared_ptr 保存 factory 函数如 createInvestment的调用结果：
```C++
shared_ptr<Investment> pInv(createInvestment());
```
假如需要使用某个函数对Investment对象进行处理：
```C++
int daysHeld(const Investment* pi);
```
如果上面这个函数被这么调用：
```C++
int days = daysHeld(pInv);
```
很明显会导致错误，因为daysHeld接受的是一个Investment* 参数，而pInv的类型为`shared_ptr<Investment>`。  
此时就需要一个函数可将RAII class对象(此处为shared_ptr)转换为它所包含的原始资源(此处为Investment*)。  
实现这一目的的方式有两种：显式转换和隐式转换。
* 显式转换：在shared_ptr和auto_ptr中都提供了一个get成员函数，它会返回智能指针内部的原始指针：
  ```C++
  int days = daysHeld(pInv.get());  // 将pInv内的原始指针传给daysHeld
  ```
  * 隐式转换：在shared_ptr和auto_ptr中也重载了指针解引用(pointer dereferencing)操作符(operator->和operator*)，它们允许隐士转换至底部原始指针：
    ```C++
    class Investment{ // investment 继承体系中的一个父类
    public:
      bool isTaxFree() const;
      ...
    };
    {
      Investement* createInvestment();                    // 工厂函数
      std::shared_ptr<Investment> pi1(createInvestment());// 让shared_ptr管理资源
      bool taxable1 = !(pi1->isTaxFree());                // 通过operator->访问资源
      ...
      std::auto_ptr<Investment> pi2(createInvestment());  // 让auto_ptr管理资源
      bool taxable2 = ~((*pi2).isTaxFree());              // 通过operator*访问资源
    }
    ```

如果需要取得RAII对象内的原始资源，就需要提供一个隐式转换函数，示例如下：
```C++
FontHandle getFont(); // 一个无参 C API

void releaseFont(FontHandle fh);  // 与上面一个来自同一个 C API

class Font{ // RAII class
public:
  explicit Font(FontHandle fh)  // 获取资源
  : f(fh)                       // 按值传递 pass by value 
  { }                           
  ~Font() { releaseFont(f); }   // 释放资源
private:
  FontHandle f;
};
```
如果有大量与Font相关的C API，它们处理的是FontHandle，那么就需要频繁地将Font对象转换为FontHandle。Font class可以为此提供一个显式转换函数，如：
```C++
class Font{
public:
  ...
  FontHandle get() const { return f; }  // 显式转换函数
  ...
};
```
这使得每次调用API时都需要使用get():
```C++
void changeFontSize(FontHandle f, int newSize); // C API
Font f(getFont());
int newFontSize();
...
changeFontSize(f.get(), newFontSize); // 显式地将Font转换为FontHandle
```
频繁地要求显式转换，会增加泄露字体风险的可能性，而Font class设计的初衷就是为了防止资源泄露。  
另一种办法就是令Font提供隐式转换函数，转型为FontHandle：
```C++
class Font{
public:
  ...
  operator FontHandle() const // 隐式转换函数
  { return f; }
  ...
};

void f(FontHandle fh){
  ... /* 若接受一个Font类型的参数，其将会被隐式转换为FontHandle */
}
```
经过这样处理过，使得调用 C API 会比较方便：
```C++
Font f(getFont());
int newFontSize;
...
changeFontSize(f, newFontSize); // 隐式地将Font转换为FontHandle
```
但是这个隐式转换会增加错误出现的概率：
```C++
Font f1(getFont());
...
FontHandle f2 = f1; // 要将Font类型的f1拷贝给f2，却将f1的类型隐式转换成了FontHandle
```
因为FontHandle由Font对象f1管理，但是通过隐式转换，FontHandle也可以通过f2来访问，然而，如果f1被销毁，那么f2会变成一个悬空的对象，因为f2依赖于f1的资源管理。  
是否提供一个显式转换或隐式转换函数将RAII class转换为其底部资源取决于RAII class被设计于执行在一个什么样的工作场景中。  

总结：
* API往往要求访问原始资源(raw resources)，所以每一个RAII class应该提供一个"取得其所管理的资源"的办法。
* 对原始资源的访问可能经由显示转换或隐式转换，其中显式转换可能会比较麻烦但是较安全，隐式转换较方便但是不太安全。

## 条款16：成对使用new和delete时要采取相同形式
思考下面这段代码有什么问题：
```C++
  std::string* stringArray = new std::string[100];
  ...
  delete stringArray;
```
这段代码虽然成对使用了new和delete，但其仍产生了未定义行为，stringArray中包含的100个string对象中的99个string无法被正常处理，因为它们的析构函数很可能没有被调用。  
仔细分析一下，当使用new和delete时分别会发生什么事情：
* 当使用new动态生成对象时，会发生两件事：  
  * 第一，内存通过一个名为operator new的函数被分配出来。  
  * 第二，针对此内存段会有一个或多个构造函数被调用。  
* 当使用delete删除对象时，会发生两件事：
  * 第一，针对此内存段会有一个或多个析构函数被调用。
  * 第二，此内存段通过一个名为operator delete的函数被释放。

这个问题在于即将被删除的内存段中有多少个对象，这决定了最终需要调用多少个析构函数。  
首先要考虑的问题：即将被删除的指针所指的是单一对象或对象数组，因为单一对象的内存布局一般而言不同于对象数组的内存布局，更确切的说，
数组所用的内存通常还包括“数组大小”的记录，以便delete知道需要调用多少次析构函数，而单一对象的内存则不需要记录这点，关于单一对象和对象数组的布局可以抽象如下：
```
|
|        __________
单一对象 | Object  |
|        __________
|        ____________________________________________
对象数组 | n | Object0 | Object1 | ... | Object(n-1) |
|        ____________________________________________
|
```
对一个对象数组使用delete，能够准确让delete知道要删除的数组大小的方法就是直接告诉它：
```C++
  std::string* stringPtr1 = new std::string;
  std::string* stringPtr2 = new std::string[100];
  ...
  delete stringPtr1;    // 删除一个对象
  delete [] stringPtr2; // 删除一个对象数组
```
对一个对象数组使用delete[]进行销毁和对单个对象使用delete进行销毁是正确的操作。  
如果对单个对象使用delete[]进行销毁，会让delete认为这单个对象是一个对象数组，会使其多次调用析构函数，产生一些未定义行为，所以这是不可取的。  
当然，如开头所说，对一个对象数组使用delete进行销毁，导致对象数组没有被完全销毁，进而产生未定义行为，对于一些内置类型例如int创建的数组没有使用delete[]那将会产生更糟的结果。  
显而易见，当使用new动态创建对象时，使用了[]那么在使用delete进行销毁使也要对应使用[]，否则，就不要使用。  
当一个有着指向动态分配内存的指针的class时，并实现了多个构造函数时，切记在所有构造函数中使用相同的new方式动态创建对象，否则，析构函数无法知道使用什么形式的delete与其对应。

在使用typedef时也要注意上面这点：
```C++
  typedef std::string AddressLines[4];
  /* 相当于 std::string* AddressLines = new std::string[4]; */
  std::string* pal = new AddressLines;
  
  delete pal;   // 对对象数组使用delete，产生未定义行为
  delete[] pal;
```
提示：在实际使用的时候，为避免因为使用typedef导致的问题，可以使用string, vector等templates进行替代，降低出错风险的概率，

总结：
* 使用new动态创建对象时，如果创建的是单个对象，那么就应该使用delete对其进行销毁，如果创建的是多个对象，那么就应该使用delete[]对其进行销毁。

## 条款17：以独立语句将newed对象置入智能指针
假设存在一个函数用来体现程序处理的优先权，另一个函数用来在某动态分配所得的Widget上进行某些带有优先权的处理：
```C++
int priority();
void processWidget(std::shared_ptr<Widget> pw, int priority);
```
现在调用processWidget，一种错误的写法:
```C++
processWidget(new Widget, priority());
```
此处的shared_ptr构造函数需要一个裸指针(raw pointer)，但构造函数是一个explicit构造函数，无法进行隐式转换，现将new Widget的裸指针转换为processWidget所需要的shared_ptr：
```C++
processWidget(
          std::shared_ptr<Widget>(new Widget), 
          priority()
          );
```
这种使用方法仍然不是安全的，对于第一个实参`std::shared_ptr<Widget>(new Widget)`分析，其由两部分组成：
* 执行 new Widget 表达式
* 调用 shared_ptr 构造函数

在调用processWidget之前，编译器需创建代码，其会做以下三件事：
* 调用 priority
* 执行 new Widget
* 调用 shared_ptr 构造函数

分析一下此处编译器执行的顺序，可以确定的是 new Widget 会在 shared_prt 构造函数调用之前执行，因为这个表达式的结果还要作为一个实参传给shared_ptr的构造函数，一个可能的执行顺序如下：
1. 执行 new Widget
2. 调用 priority
3. 调用 shared_ptr构造函数

此时，如果priority()的调用出现了异常，那么 new Widget 返回的指针就会丢失。  
由于在资源被创建和资源被转换为资源管理对象这个两个过程之间难免会出现异常的干扰，为了避免这样的问题，可以使用分离语句：
1. 创建Widget
2. 将它置入一个智能指针内
3. 将智能指针传给processWidget：
  ```C++
    /* 智能指针存储newed所得的对象 */
    std::shared_ptr<Widget> pw(new Widget);
    processWidget(pw, priority());
    /* 这样就可以规定编译器的执行的顺序 */
  ```
总结：
* 以独立语句将newed对象存储入智能指针内，否则，一旦异常抛出，很可能出现难以察觉的资源泄露。